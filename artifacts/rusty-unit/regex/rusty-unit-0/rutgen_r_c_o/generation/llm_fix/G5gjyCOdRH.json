{
  "name": "regex_syntax::hir::translate::<hir::translate::TranslatorI<'t, 'p> as ast::visitor::Visitor>::visit_class_set_item_post",
  "name_with_impl": "regex_syntax::hir::translate::{impl#4}::visit_class_set_item_post",
  "mod_info": {
    "name": "hir::translate",
    "loc": "regex-syntax/src/hir/mod.rs:29:1:29:19"
  },
  "visible": true,
  "loc": "regex-syntax/src/hir/translate.rs:392:5:482:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: *ast matches ast::ClassSetItem::Union(_) is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "test input ranges: ast::ClassSetItem::Union(_)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "",
                "    let ast_union = ast::ClassSetItem::Union(ast::ClassSetBinaryOp::Union);",
                "",
                "    let mut visitor = TranslatorI::new(&translator, \"sample pattern\");",
                "    visitor.visit_class_set_item_post(&ast_union).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let ast_union = ast::ClassSetItem::Union(ast::ClassSetBinaryOp::Union);",
                  "    let mut visitor = TranslatorI::new(&translator, \"sample pattern\");",
                  "    assert!(visitor.trans().stack.borrow().is_empty());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let ast_union = ast::ClassSetItem::Union(ast::ClassSetBinaryOp::Union);",
                  "    let mut visitor = TranslatorI::new(&translator, \"sample pattern\");",
                  "    visitor.visit_class_set_item_post(&ast_union).unwrap();",
                  "    assert_eq!(visitor.trans().stack.borrow().len(), 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let ast_union = ast::ClassSetItem::Union(ast::ClassSetBinaryOp::Union);",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"sample pattern\");",
                  "    visitor.visit_class_set_item_post(&ast_union).unwrap();",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let ast_union = ast::ClassSetItem::Union(ast::ClassSetBinaryOp::Union);",
                  "    let mut visitor = TranslatorI::new(&translator, \"sample pattern\");",
                  "    assert!(visitor.trans().stack.borrow().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let ast_union = ast::ClassSetItem::Union(ast::ClassSetBinaryOp::Union);",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"sample pattern\");",
                  "    visitor.visit_class_set_item_post(&ast_union).unwrap();",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let ast_union = ast::ClassSetItem::Union(ast::ClassSetBinaryOp::Union);",
                  "    let mut visitor = TranslatorI::new(&translator, \"sample pattern\");",
                  "    visitor.visit_class_set_item_post(&ast_union).unwrap();",
                  "    assert_eq!(visitor.trans().stack.borrow().len(), 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Union` found for struct `ClassSetBinaryOp` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2549:69\n     |\n2549 |     let ast_union = ast::ClassSetItem::Union(ast::ClassSetBinaryOp::Union);\n     |                                                                     ^^^^^ associated item not found in `ClassSetBinaryOp`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1071:1\n     |\n1071 | pub struct ClassSetBinaryOp {\n     | --------------------------- associated item `Union` not found for this struct\n\nerror[E0599]: no associated item named `Union` found for struct `ClassSetBinaryOp` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:69\n     |\n2558 |     let ast_union = ast::ClassSetItem::Union(ast::ClassSetBinaryOp::Union);\n     |                                                                     ^^^^^ associated item not found in `ClassSetBinaryOp`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1071:1\n     |\n1071 | pub struct ClassSetBinaryOp {\n     | --------------------------- associated item `Union` not found for this struct\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Union` found for struct `ClassSetBinaryOp` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2549:69\n     |\n2549 |     let ast_union = ast::ClassSetItem::Union(ast::ClassSetBinaryOp::Union);\n     |                                                                     ^^^^^ associated item not found in `ClassSetBinaryOp`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1071:1\n     |\n1071 | pub struct ClassSetBinaryOp {\n     | --------------------------- associated item `Union` not found for this struct\n\nerror[E0599]: no associated item named `Union` found for struct `ClassSetBinaryOp` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:69\n     |\n2558 |     let ast_union = ast::ClassSetItem::Union(ast::ClassSetBinaryOp::Union);\n     |                                                                     ^^^^^ associated item not found in `ClassSetBinaryOp`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1071:1\n     |\n1071 | pub struct ClassSetBinaryOp {\n     | --------------------------- associated item `Union` not found for this struct\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![HirFrame::Expr(Hir { kind: HirKind::Concat, info: HirInfo::default() })]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "",
                "    let ast_union = ast::ClassSetItem::Union(ast::ClassSetBinaryOp::Union);",
                "",
                "    let mut visitor = TranslatorI::new(&translator, \"sample pattern\");",
                "    visitor.visit_class_set_item_post(&ast_union).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::Expr(Hir { kind: HirKind::Concat, info: HirInfo::default() })]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let ast_union = ast::ClassSetItem::Union(ast::ClassSetBinaryOp::Union);",
                  "    let mut visitor = TranslatorI::new(&translator, \"sample pattern\");",
                  "    visitor.visit_class_set_item_post(&ast_union).unwrap();",
                  "    assert_eq!(visitor.pop().unwrap(), HirFrame::Expr(Hir { kind: HirKind::Concat, info: HirInfo::default() }));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::Expr(Hir { kind: HirKind::Concat, info: HirInfo::default() })]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let ast_union = ast::ClassSetItem::Union(ast::ClassSetBinaryOp::Union);",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"sample pattern\");",
                  "    visitor.visit_class_set_item_post(&ast_union).unwrap();",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::Expr(Hir { kind: HirKind::Concat, info: HirInfo::default() })]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let ast_union = ast::ClassSetItem::Union(ast::ClassSetBinaryOp::Union);",
                  "    let mut visitor = TranslatorI::new(&translator, \"sample pattern\");",
                  "    visitor.visit_class_set_item_post(&ast_union).unwrap();",
                  "    assert_eq!(visitor.pop().unwrap(), HirFrame::Expr(Hir { kind: HirKind::Concat, info: HirInfo::default() }));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2544:61\n     |\n2544 |         stack: RefCell::new(vec![HirFrame::Expr(Hir { kind: HirKind::Concat, info: HirInfo::default() })]),\n     |                                                             ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/translate.rs:2544:84\n     |\n2544 |         stack: RefCell::new(vec![HirFrame::Expr(Hir { kind: HirKind::Concat, info: HirInfo::default() })]),\n     |                                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2554:57\n     |\n2554 |     stack: RefCell::new(vec![HirFrame::Expr(Hir { kind: HirKind::Concat, info: HirInfo::default() })]),\n     |                                                         ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/translate.rs:2554:80\n     |\n2554 |     stack: RefCell::new(vec![HirFrame::Expr(Hir { kind: HirKind::Concat, info: HirInfo::default() })]),\n     |                                                                                ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2561:67\n     |\n2561 |     assert_eq!(visitor.pop().unwrap(), HirFrame::Expr(Hir { kind: HirKind::Concat, info: HirInfo::default() }));\n     |                                                                   ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/translate.rs:2561:90\n     |\n2561 |     assert_eq!(visitor.pop().unwrap(), HirFrame::Expr(Hir { kind: HirKind::Concat, info: HirInfo::default() }));\n     |                                                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Union` found for struct `ClassSetBinaryOp` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2549:69\n     |\n2549 |     let ast_union = ast::ClassSetItem::Union(ast::ClassSetBinaryOp::Union);\n     |                                                                     ^^^^^ associated item not found in `ClassSetBinaryOp`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1071:1\n     |\n1071 | pub struct ClassSetBinaryOp {\n     | --------------------------- associated item `Union` not found for this struct\n\nerror[E0599]: no associated item named `Union` found for struct `ClassSetBinaryOp` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:69\n     |\n2558 |     let ast_union = ast::ClassSetItem::Union(ast::ClassSetBinaryOp::Union);\n     |                                                                     ^^^^^ associated item not found in `ClassSetBinaryOp`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1071:1\n     |\n1071 | pub struct ClassSetBinaryOp {\n     | --------------------------- associated item `Union` not found for this struct\n\nerror[E0369]: binary operation `==` cannot be applied to type `translate::HirFrame`\n    --> regex-syntax/src/hir/translate.rs:2561:5\n     |\n2561 |     assert_eq!(visitor.pop().unwrap(), HirFrame::Expr(Hir { kind: HirKind::Concat, info: HirInfo::default() }));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     translate::HirFrame\n     |     translate::HirFrame\n     |\nnote: an implementation of `PartialEq` might be missing for `translate::HirFrame`\n    --> regex-syntax/src/hir/translate.rs:154:1\n     |\n154  | enum HirFrame {\n     | ^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `translate::HirFrame` with `#[derive(PartialEq)]`\n     |\n154  + #[derive(PartialEq)]\n155  | enum HirFrame {\n     |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0433, E0599.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "",
                "    let ast_union = ast::ClassSetItem::Union(ast::ClassSetBinaryOp::Union);",
                "",
                "    let mut visitor = TranslatorI::new(&translator, \"sample pattern\");",
                "    visitor.visit_class_set_item_post(&ast_union).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let ast_union = ast::ClassSetItem::Union(ast::ClassSetBinaryOp::Union);",
                  "    let mut visitor = TranslatorI::new(&translator, \"sample pattern\");",
                  "    visitor.visit_class_set_item_post(&ast_union).unwrap();",
                  "    assert!(visitor.pop().is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let ast_union = ast::ClassSetItem::Union(ast::ClassSetBinaryOp::Union);",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"sample pattern\");",
                  "    visitor.visit_class_set_item_post(&ast_union).unwrap();",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let ast_union = ast::ClassSetItem::Union(ast::ClassSetBinaryOp::Union);",
                  "    let mut visitor = TranslatorI::new(&translator, \"sample pattern\");",
                  "    visitor.visit_class_set_item_post(&ast_union).unwrap();",
                  "    assert!(visitor.pop().is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no associated item named `Union` found for struct `ClassSetBinaryOp` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2549:69\n     |\n2549 |     let ast_union = ast::ClassSetItem::Union(ast::ClassSetBinaryOp::Union);\n     |                                                                     ^^^^^ associated item not found in `ClassSetBinaryOp`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1071:1\n     |\n1071 | pub struct ClassSetBinaryOp {\n     | --------------------------- associated item `Union` not found for this struct\n\nerror[E0599]: no associated item named `Union` found for struct `ClassSetBinaryOp` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:69\n     |\n2558 |     let ast_union = ast::ClassSetItem::Union(ast::ClassSetBinaryOp::Union);\n     |                                                                     ^^^^^ associated item not found in `ClassSetBinaryOp`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1071:1\n     |\n1071 | pub struct ClassSetBinaryOp {\n     | --------------------------- associated item `Union` not found for this struct\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0599`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: *ast matches ast::ClassSetItem::Bracketed(ref ast) is true\n",
        "// constraint: *ast matches ast::ClassSetItem::Bracketed(ref ast) is true\n",
        "// constraint: self.flags().unicode() is true\n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.pop().unwrap() is \n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "ast::ClassSetItem::Bracketed(ref Span { start, end }) with start as 0x0020 and end as 0x007F, self.flags().unicode() is true, self.pop().is_some() and returns a valid HirFrame that can be mutated.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(true),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let pattern = \"test_pattern\";",
                "    let translator_instance = TranslatorI::new(&trans, pattern);",
                "",
                "    let span = Span {",
                "        start: Position(32), // 0x0020",
                "        end: Position(127),  // 0x007F",
                "    };",
                "",
                "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                "        span,",
                "        negated: false,",
                "        kind: ClassSet::Normal, // assuming this is a valid kind",
                "    }));",
                "",
                "    translator_instance.visit_class_set_item_post(&bracketed_class_item).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test_pattern\";",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position(32), end: Position(127) };",
                  "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal }));",
                  "    translator_instance.pop();",
                  "    translator_instance.push(HirFrame::ClassUnicode(hir::ClassUnicode::new(vec![])));",
                  "    let result = translator_instance.visit_class_set_item_post(&bracketed_class_item);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test_pattern\";",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position(32), end: Position(127) };",
                  "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal }));",
                  "    translator_instance.pop();",
                  "    translator_instance.push(HirFrame::ClassUnicode(hir::ClassUnicode::new(vec![])));",
                  "    let result = translator_instance.visit_class_set_item_post(&bracketed_class_item);",
                  "    let top_frame = translator_instance.pop().unwrap();",
                  "    assert!(matches!(top_frame, HirFrame::ClassUnicode(_)));"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test_pattern\";",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position(32), end: Position(127) };",
                  "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal }));",
                  "    translator_instance.pop();",
                  "    translator_instance.push(HirFrame::ClassUnicode(hir::ClassUnicode::new(vec![])));",
                  "    let result = translator_instance.visit_class_set_item_post(&bracketed_class_item);",
                  "    let top_frame = translator_instance.pop().unwrap();",
                  "    let cls_unicode = top_frame.unwrap_class_unicode();",
                  "    assert_eq!(cls_unicode.iter().count(), 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"test_pattern\";",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let span = Span {",
                  "        start: Position(32), // 0x0020",
                  "        end: Position(127),  // 0x007F",
                  "    };",
                  "",
                  "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Normal, // assuming this is a valid kind",
                  "    }));",
                  "",
                  "    translator_instance.visit_class_set_item_post(&bracketed_class_item).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test_pattern\";",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position(32), end: Position(127) };",
                  "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal }));",
                  "    translator_instance.pop();",
                  "    translator_instance.push(HirFrame::ClassUnicode(hir::ClassUnicode::new(vec![])));",
                  "    let result = translator_instance.visit_class_set_item_post(&bracketed_class_item);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"test_pattern\";",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let span = Span {",
                  "        start: Position(32), // 0x0020",
                  "        end: Position(127),  // 0x007F",
                  "    };",
                  "",
                  "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Normal, // assuming this is a valid kind",
                  "    }));",
                  "",
                  "    translator_instance.visit_class_set_item_post(&bracketed_class_item).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test_pattern\";",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position(32), end: Position(127) };",
                  "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal }));",
                  "    translator_instance.pop();",
                  "    translator_instance.push(HirFrame::ClassUnicode(hir::ClassUnicode::new(vec![])));",
                  "    let result = translator_instance.visit_class_set_item_post(&bracketed_class_item);",
                  "    let top_frame = translator_instance.pop().unwrap();",
                  "    assert!(matches!(top_frame, HirFrame::ClassUnicode(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"test_pattern\";",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let span = Span {",
                  "        start: Position(32), // 0x0020",
                  "        end: Position(127),  // 0x007F",
                  "    };",
                  "",
                  "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Normal, // assuming this is a valid kind",
                  "    }));",
                  "",
                  "    translator_instance.visit_class_set_item_post(&bracketed_class_item).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test_pattern\";",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position(32), end: Position(127) };",
                  "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal }));",
                  "    translator_instance.pop();",
                  "    translator_instance.push(HirFrame::ClassUnicode(hir::ClassUnicode::new(vec![])));",
                  "    let result = translator_instance.visit_class_set_item_post(&bracketed_class_item);",
                  "    let top_frame = translator_instance.pop().unwrap();",
                  "    let cls_unicode = top_frame.unwrap_class_unicode();",
                  "    assert_eq!(cls_unicode.iter().count(), 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2563:15\n     |\n2563 |         kind: ClassSet::Normal, // assuming this is a valid kind\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2571:120\n     |\n2571 |     let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal }));\n     |                                                                                                                        ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n2556 |         start: Position(32), // 0x0020\n     |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:14\n     |\n2557 |         end: Position(127),  // 0x007F\n     |              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:30\n     |\n2570 |     let span = Span { start: Position(32), end: Position(127) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:49\n     |\n2570 |     let span = Span { start: Position(32), end: Position(127) };\n     |                                                 ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2563:15\n     |\n2563 |         kind: ClassSet::Normal, // assuming this is a valid kind\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2571:120\n     |\n2571 |     let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal }));\n     |                                                                                                                        ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n2556 |         start: Position(32), // 0x0020\n     |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:14\n     |\n2557 |         end: Position(127),  // 0x007F\n     |              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:30\n     |\n2570 |     let span = Span { start: Position(32), end: Position(127) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:49\n     |\n2570 |     let span = Span { start: Position(32), end: Position(127) };\n     |                                                 ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2563:15\n     |\n2563 |         kind: ClassSet::Normal, // assuming this is a valid kind\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2571:120\n     |\n2571 |     let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span, negated: false, kind: ClassSet::Normal }));\n     |                                                                                                                        ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n2556 |         start: Position(32), // 0x0020\n     |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:14\n     |\n2557 |         end: Position(127),  // 0x007F\n     |              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:30\n     |\n2570 |     let span = Span { start: Position(32), end: Position(127) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:49\n     |\n2570 |     let span = Span { start: Position(32), end: Position(127) };\n     |                                                 ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(true),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let pattern = \"test_pattern\";",
                "    let translator_instance = TranslatorI::new(&trans, pattern);",
                "",
                "    let span = Span {",
                "        start: Position(32), // 0x0020",
                "        end: Position(127),  // 0x007F",
                "    };",
                "",
                "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                "        span,",
                "        negated: true,",
                "        kind: ClassSet::Normal, // assuming this is a valid kind",
                "    }));",
                "",
                "    translator_instance.visit_class_set_item_post(&bracketed_class_item).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test_pattern\";",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position(32), end: Position(127) };",
                  "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span, negated: true, kind: ClassSet::Normal }));",
                  "    assert!(translator_instance.pop().is_none());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test_pattern\";",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position(32), end: Position(127) };",
                  "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span, negated: true, kind: ClassSet::Normal }));",
                  "    translator_instance.visit_class_set_item_post(&bracketed_class_item).unwrap();",
                  "    let frame = translator_instance.pop().unwrap();",
                  "    assert!(matches!(frame, HirFrame::ClassUnicode(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"test_pattern\";",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let span = Span {",
                  "        start: Position(32), // 0x0020",
                  "        end: Position(127),  // 0x007F",
                  "    };",
                  "",
                  "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span,",
                  "        negated: true,",
                  "        kind: ClassSet::Normal, // assuming this is a valid kind",
                  "    }));",
                  "",
                  "    translator_instance.visit_class_set_item_post(&bracketed_class_item).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test_pattern\";",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position(32), end: Position(127) };",
                  "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span, negated: true, kind: ClassSet::Normal }));",
                  "    assert!(translator_instance.pop().is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"test_pattern\";",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let span = Span {",
                  "        start: Position(32), // 0x0020",
                  "        end: Position(127),  // 0x007F",
                  "    };",
                  "",
                  "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span,",
                  "        negated: true,",
                  "        kind: ClassSet::Normal, // assuming this is a valid kind",
                  "    }));",
                  "",
                  "    translator_instance.visit_class_set_item_post(&bracketed_class_item).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test_pattern\";",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position(32), end: Position(127) };",
                  "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span, negated: true, kind: ClassSet::Normal }));",
                  "    translator_instance.visit_class_set_item_post(&bracketed_class_item).unwrap();",
                  "    let frame = translator_instance.pop().unwrap();",
                  "    assert!(matches!(frame, HirFrame::ClassUnicode(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2563:15\n     |\n2563 |         kind: ClassSet::Normal, // assuming this is a valid kind\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2571:119\n     |\n2571 |     let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span, negated: true, kind: ClassSet::Normal }));\n     |                                                                                                                       ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n2556 |         start: Position(32), // 0x0020\n     |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:14\n     |\n2557 |         end: Position(127),  // 0x007F\n     |              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:30\n     |\n2570 |     let span = Span { start: Position(32), end: Position(127) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:49\n     |\n2570 |     let span = Span { start: Position(32), end: Position(127) };\n     |                                                 ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2563:15\n     |\n2563 |         kind: ClassSet::Normal, // assuming this is a valid kind\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2571:119\n     |\n2571 |     let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span, negated: true, kind: ClassSet::Normal }));\n     |                                                                                                                       ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n2556 |         start: Position(32), // 0x0020\n     |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:14\n     |\n2557 |         end: Position(127),  // 0x007F\n     |              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:30\n     |\n2570 |     let span = Span { start: Position(32), end: Position(127) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:49\n     |\n2570 |     let span = Span { start: Position(32), end: Position(127) };\n     |                                                 ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![",
                "            HirFrame::ClassUnicode(hir::ClassUnicode::empty()), // initialized valid state",
                "            HirFrame::ClassUnicode(hir::ClassUnicode::empty()), // another valid state",
                "        ]),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(true),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let pattern = \"test_pattern\";",
                "    let translator_instance = TranslatorI::new(&trans, pattern);",
                "",
                "    let span = Span {",
                "        start: Position(32), // 0x0020",
                "        end: Position(127),  // 0x007F",
                "    };",
                "",
                "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                "        span,",
                "        negated: false,",
                "        kind: ClassSet::Normal, // assuming this is a valid kind",
                "    }));",
                "",
                "    translator_instance.visit_class_set_item_post(&bracketed_class_item).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![",
                  "    HirFrame::ClassUnicode(hir::ClassUnicode::empty()),",
                  "    HirFrame::ClassUnicode(hir::ClassUnicode::empty()),",
                  "    ]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    assert!(trans.stack.borrow().len() == 2);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![",
                  "    HirFrame::ClassUnicode(hir::ClassUnicode::empty()),",
                  "    HirFrame::ClassUnicode(hir::ClassUnicode::empty()),",
                  "    ]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let span = Span {",
                  "    start: Position(32),",
                  "    end: Position(127),",
                  "    };",
                  "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    }));",
                  "    let result = translator_instance.visit_class_set_item_post(&bracketed_class_item);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![",
                  "    HirFrame::ClassUnicode(hir::ClassUnicode::empty()),",
                  "    HirFrame::ClassUnicode(hir::ClassUnicode::empty()),",
                  "    ]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let span = Span {",
                  "    start: Position(32),",
                  "    end: Position(127),",
                  "    };",
                  "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    }));",
                  "    let result = translator_instance.visit_class_set_item_post(&bracketed_class_item);",
                  "    assert!(trans.stack.borrow().len() == 2);  // Ensure stack size is unchanged after visiting."
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![",
                  "    HirFrame::ClassUnicode(hir::ClassUnicode::empty()),",
                  "    HirFrame::ClassUnicode(hir::ClassUnicode::empty()),",
                  "    ]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let span = Span {",
                  "    start: Position(32),",
                  "    end: Position(127),",
                  "    };",
                  "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    }));",
                  "    let result = translator_instance.visit_class_set_item_post(&bracketed_class_item);",
                  "    let last_frame = trans.stack.borrow().last().unwrap();",
                  "    assert!(matches!(last_frame, HirFrame::ClassUnicode(_)));  // Ensure last frame is still a ClassUnicode."
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![",
                  "            HirFrame::ClassUnicode(hir::ClassUnicode::empty()), // initialized valid state",
                  "            HirFrame::ClassUnicode(hir::ClassUnicode::empty()), // another valid state",
                  "        ]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"test_pattern\";",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let span = Span {",
                  "        start: Position(32), // 0x0020",
                  "        end: Position(127),  // 0x007F",
                  "    };",
                  "",
                  "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Normal, // assuming this is a valid kind",
                  "    }));",
                  "",
                  "    translator_instance.visit_class_set_item_post(&bracketed_class_item).unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![",
                  "    HirFrame::ClassUnicode(hir::ClassUnicode::empty()),",
                  "    HirFrame::ClassUnicode(hir::ClassUnicode::empty()),",
                  "    ]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    assert!(trans.stack.borrow().len() == 2);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![",
                  "            HirFrame::ClassUnicode(hir::ClassUnicode::empty()), // initialized valid state",
                  "            HirFrame::ClassUnicode(hir::ClassUnicode::empty()), // another valid state",
                  "        ]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"test_pattern\";",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let span = Span {",
                  "        start: Position(32), // 0x0020",
                  "        end: Position(127),  // 0x007F",
                  "    };",
                  "",
                  "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Normal, // assuming this is a valid kind",
                  "    }));",
                  "",
                  "    translator_instance.visit_class_set_item_post(&bracketed_class_item).unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![",
                  "    HirFrame::ClassUnicode(hir::ClassUnicode::empty()),",
                  "    HirFrame::ClassUnicode(hir::ClassUnicode::empty()),",
                  "    ]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let span = Span {",
                  "    start: Position(32),",
                  "    end: Position(127),",
                  "    };",
                  "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    }));",
                  "    let result = translator_instance.visit_class_set_item_post(&bracketed_class_item);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![",
                  "            HirFrame::ClassUnicode(hir::ClassUnicode::empty()), // initialized valid state",
                  "            HirFrame::ClassUnicode(hir::ClassUnicode::empty()), // another valid state",
                  "        ]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"test_pattern\";",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let span = Span {",
                  "        start: Position(32), // 0x0020",
                  "        end: Position(127),  // 0x007F",
                  "    };",
                  "",
                  "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Normal, // assuming this is a valid kind",
                  "    }));",
                  "",
                  "    translator_instance.visit_class_set_item_post(&bracketed_class_item).unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![",
                  "    HirFrame::ClassUnicode(hir::ClassUnicode::empty()),",
                  "    HirFrame::ClassUnicode(hir::ClassUnicode::empty()),",
                  "    ]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let span = Span {",
                  "    start: Position(32),",
                  "    end: Position(127),",
                  "    };",
                  "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    }));",
                  "    let result = translator_instance.visit_class_set_item_post(&bracketed_class_item);",
                  "    assert!(trans.stack.borrow().len() == 2);  // Ensure stack size is unchanged after visiting.",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![",
                  "            HirFrame::ClassUnicode(hir::ClassUnicode::empty()), // initialized valid state",
                  "            HirFrame::ClassUnicode(hir::ClassUnicode::empty()), // another valid state",
                  "        ]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"test_pattern\";",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let span = Span {",
                  "        start: Position(32), // 0x0020",
                  "        end: Position(127),  // 0x007F",
                  "    };",
                  "",
                  "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span,",
                  "        negated: false,",
                  "        kind: ClassSet::Normal, // assuming this is a valid kind",
                  "    }));",
                  "",
                  "    translator_instance.visit_class_set_item_post(&bracketed_class_item).unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![",
                  "    HirFrame::ClassUnicode(hir::ClassUnicode::empty()),",
                  "    HirFrame::ClassUnicode(hir::ClassUnicode::empty()),",
                  "    ]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let span = Span {",
                  "    start: Position(32),",
                  "    end: Position(127),",
                  "    };",
                  "    let bracketed_class_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span,",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    }));",
                  "    let result = translator_instance.visit_class_set_item_post(&bracketed_class_item);",
                  "    let last_frame = trans.stack.borrow().last().unwrap();",
                  "    assert!(matches!(last_frame, HirFrame::ClassUnicode(_)));  // Ensure last frame is still a ClassUnicode.",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2566:15\n     |\n2566 |         kind: ClassSet::Normal, // assuming this is a valid kind\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:16\n     |\n2559 |         start: Position(32), // 0x0020\n     |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:14\n     |\n2560 |         end: Position(127),  // 0x007F\n     |              ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2566:15\n     |\n2566 |         kind: ClassSet::Normal, // assuming this is a valid kind\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2590:11\n     |\n2590 |     kind: ClassSet::Normal,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:16\n     |\n2559 |         start: Position(32), // 0x0020\n     |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:14\n     |\n2560 |         end: Position(127),  // 0x007F\n     |              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2584:12\n     |\n2584 |     start: Position(32),\n     |            ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2585:10\n     |\n2585 |     end: Position(127),\n     |          ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2566:15\n     |\n2566 |         kind: ClassSet::Normal, // assuming this is a valid kind\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2590:11\n     |\n2590 |     kind: ClassSet::Normal,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:16\n     |\n2559 |         start: Position(32), // 0x0020\n     |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:14\n     |\n2560 |         end: Position(127),  // 0x007F\n     |              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2584:12\n     |\n2584 |     start: Position(32),\n     |            ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2585:10\n     |\n2585 |     end: Position(127),\n     |          ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2566:15\n     |\n2566 |         kind: ClassSet::Normal, // assuming this is a valid kind\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2590:11\n     |\n2590 |     kind: ClassSet::Normal,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:16\n     |\n2559 |         start: Position(32), // 0x0020\n     |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:14\n     |\n2560 |         end: Position(127),  // 0x007F\n     |              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2584:12\n     |\n2584 |     start: Position(32),\n     |            ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2585:10\n     |\n2585 |     end: Position(127),\n     |          ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: *ast matches ast::ClassSetItem::Bracketed(ref ast) is true\n",
        "// constraint: *ast matches ast::ClassSetItem::Bracketed(ref ast) is true\n",
        "// constraint: self.flags().unicode() is false\n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.bytes_fold_and_negate(\n                        &ast.span, ast.negated, &mut cls1)? is Err/None\n"
      ],
      "input_infer": "ast::ClassSetItem::Bracketed(ref ast) with negated = true, self.pop() returns Some(HirFrame::ClassBytes(cls)), self.flags().unicode() is false, self.bytes_fold_and_negate() triggers an error (non-ASCII range) with ast.span = Span { start: Position(0), end: Position(1) }\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(false),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let pattern = \"[^a-z]\";",
                "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                "        span: Span { start: Position(0), end: Position(1) },",
                "        negated: true,",
                "        kind: ClassSet::Default, // assuming a default kind",
                "    }));",
                "",
                "    let mut translator = TranslatorI::new(&trans, pattern);",
                "    translator.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                "",
                "    let result = translator.visit_class_set_item_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    assert_eq!(trans.stack.borrow().len(), 0);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[^a-z]\";",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    negated: true,",
                  "    kind: ClassSet::Default,",
                  "    }));",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let result = translator.visit_class_set_item_post(&ast);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[^a-z]\";",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    negated: true,",
                  "    kind: ClassSet::Default,",
                  "    }));",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let result = translator.visit_class_set_item_post(&ast);",
                  "    assert_eq!(translator.pop().is_none(), true);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[^a-z]\";",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    negated: true,",
                  "    kind: ClassSet::Default,",
                  "    }));",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let result = translator.visit_class_set_item_post(&ast);",
                  "    assert_eq!(translator.flags().unicode(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"[^a-z]\";",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        negated: true,",
                  "        kind: ClassSet::Default, // assuming a default kind",
                  "    }));",
                  "",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let result = translator.visit_class_set_item_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    assert_eq!(trans.stack.borrow().len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"[^a-z]\";",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        negated: true,",
                  "        kind: ClassSet::Default, // assuming a default kind",
                  "    }));",
                  "",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let result = translator.visit_class_set_item_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[^a-z]\";",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    negated: true,",
                  "    kind: ClassSet::Default,",
                  "    }));",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let result = translator.visit_class_set_item_post(&ast);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"[^a-z]\";",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        negated: true,",
                  "        kind: ClassSet::Default, // assuming a default kind",
                  "    }));",
                  "",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let result = translator.visit_class_set_item_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[^a-z]\";",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    negated: true,",
                  "    kind: ClassSet::Default,",
                  "    }));",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let result = translator.visit_class_set_item_post(&ast);",
                  "    assert_eq!(translator.pop().is_none(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"[^a-z]\";",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        negated: true,",
                  "        kind: ClassSet::Default, // assuming a default kind",
                  "    }));",
                  "",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let result = translator.visit_class_set_item_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[^a-z]\";",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    negated: true,",
                  "    kind: ClassSet::Default,",
                  "    }));",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let result = translator.visit_class_set_item_post(&ast);",
                  "    assert_eq!(translator.flags().unicode(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2556:15\n     |\n2556 |         kind: ClassSet::Default, // assuming a default kind\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:42\n     |\n2560 |     translator.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:47\n     |\n2554 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2556:15\n     |\n2556 |         kind: ClassSet::Default, // assuming a default kind\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:42\n     |\n2560 |     translator.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2575:11\n     |\n2575 |     kind: ClassSet::Default,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2578:42\n     |\n2578 |     translator.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:47\n     |\n2554 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2573:25\n     |\n2573 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2573:43\n     |\n2573 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2556:15\n     |\n2556 |         kind: ClassSet::Default, // assuming a default kind\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:42\n     |\n2560 |     translator.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2575:11\n     |\n2575 |     kind: ClassSet::Default,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2578:42\n     |\n2578 |     translator.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:47\n     |\n2554 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2573:25\n     |\n2573 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2573:43\n     |\n2573 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2556:15\n     |\n2556 |         kind: ClassSet::Default, // assuming a default kind\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:42\n     |\n2560 |     translator.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2575:11\n     |\n2575 |     kind: ClassSet::Default,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2578:42\n     |\n2578 |     translator.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:47\n     |\n2554 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2573:25\n     |\n2573 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2573:43\n     |\n2573 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(false),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let pattern = \"[^]\";",
                "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                "        span: Span { start: Position(0), end: Position(1) },",
                "        negated: true,",
                "        kind: ClassSet::Default, // assuming a default kind",
                "    }));",
                "",
                "    let mut translator = TranslatorI::new(&trans, pattern);",
                "    translator.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                "",
                "    let result = translator.visit_class_set_item_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[^]\";",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    negated: true,",
                  "    kind: ClassSet::Default,",
                  "    }));",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let result = translator.visit_class_set_item_post(&ast);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[^]\";",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    negated: true,",
                  "    kind: ClassSet::Default,",
                  "    }));",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let result = translator.visit_class_set_item_post(&ast);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::InvalidUtf8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"[^]\";",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        negated: true,",
                  "        kind: ClassSet::Default, // assuming a default kind",
                  "    }));",
                  "",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let result = translator.visit_class_set_item_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[^]\";",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    negated: true,",
                  "    kind: ClassSet::Default,",
                  "    }));",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let result = translator.visit_class_set_item_post(&ast);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"[^]\";",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        negated: true,",
                  "        kind: ClassSet::Default, // assuming a default kind",
                  "    }));",
                  "",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let result = translator.visit_class_set_item_post(&ast);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"[^]\";",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    negated: true,",
                  "    kind: ClassSet::Default,",
                  "    }));",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let result = translator.visit_class_set_item_post(&ast);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::InvalidUtf8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2556:15\n     |\n2556 |         kind: ClassSet::Default, // assuming a default kind\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:42\n     |\n2560 |     translator.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2575:11\n     |\n2575 |     kind: ClassSet::Default,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2578:42\n     |\n2578 |     translator.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:47\n     |\n2554 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2573:25\n     |\n2573 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2573:43\n     |\n2573 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2556:15\n     |\n2556 |         kind: ClassSet::Default, // assuming a default kind\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:42\n     |\n2560 |     translator.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2575:11\n     |\n2575 |     kind: ClassSet::Default,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2578:42\n     |\n2578 |     translator.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:47\n     |\n2554 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2573:25\n     |\n2573 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2573:43\n     |\n2573 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(false),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let pattern = \"[^]\";",
                "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                "        span: Span { start: Position(0), end: Position(1) },",
                "        negated: true,",
                "        kind: ClassSet::Default, // assuming a default kind",
                "    }));",
                "",
                "    let mut translator = TranslatorI::new(&trans, pattern);",
                "    translator.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                "",
                "    let result = translator.visit_class_set_item_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut cls1 = translator.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut cls1 = translator.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(cls1.is_empty());"
                ],
                [
                  "    let mut cls1 = translator.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(cls1.ranges().len(), 0);"
                ],
                [
                  "    let mut cls1 = translator.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(translator.trans().stack.borrow().len(), 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"[^]\";",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        negated: true,",
                  "        kind: ClassSet::Default, // assuming a default kind",
                  "    }));",
                  "",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let result = translator.visit_class_set_item_post(&ast);",
                  "    let mut cls1 = translator.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"[^]\";",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        negated: true,",
                  "        kind: ClassSet::Default, // assuming a default kind",
                  "    }));",
                  "",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let result = translator.visit_class_set_item_post(&ast);",
                  "    let mut cls1 = translator.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(cls1.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"[^]\";",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        negated: true,",
                  "        kind: ClassSet::Default, // assuming a default kind",
                  "    }));",
                  "",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let result = translator.visit_class_set_item_post(&ast);",
                  "    let mut cls1 = translator.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(cls1.ranges().len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let pattern = \"[^]\";",
                  "    let ast = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        negated: true,",
                  "        kind: ClassSet::Default, // assuming a default kind",
                  "    }));",
                  "",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let result = translator.visit_class_set_item_post(&ast);",
                  "    let mut cls1 = translator.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(translator.trans().stack.borrow().len(), 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2556:15\n     |\n2556 |         kind: ClassSet::Default, // assuming a default kind\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:42\n     |\n2560 |     translator.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:47\n     |\n2554 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2556:15\n     |\n2556 |         kind: ClassSet::Default, // assuming a default kind\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:42\n     |\n2560 |     translator.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:47\n     |\n2554 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `is_empty` found for struct `hir::ClassBytes` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:18\n     |\n2564 |     assert!(cls1.is_empty());\n     |                  ^^^^^^^^ method not found in `ClassBytes`\n     |\n    ::: regex-syntax/src/hir/mod.rs:913:1\n     |\n913  | pub struct ClassBytes {\n     | --------------------- method `is_empty` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `is_empty`, perhaps you need to implement it:\n             candidate #1: `ExactSizeIterator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2556:15\n     |\n2556 |         kind: ClassSet::Default, // assuming a default kind\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:42\n     |\n2560 |     translator.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:47\n     |\n2554 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2556:15\n     |\n2556 |         kind: ClassSet::Default, // assuming a default kind\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:42\n     |\n2560 |     translator.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:47\n     |\n2554 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: *ast matches ast::ClassSetItem::Bracketed(ref ast) is true\n",
        "// constraint: *ast matches ast::ClassSetItem::Bracketed(ref ast) is true\n",
        "// constraint: self.flags().unicode() is false\n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.bytes_fold_and_negate(\n                        &ast.span, ast.negated, &mut cls1)? is Ok/Some\n",
        "// constraint: self.pop().unwrap() is \n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "start: 0, end: 255, span: (0, 1), negated: false\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(false),",
                "            ..Flags::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"test\";",
                "    let mut translator = TranslatorI::new(&trans, pattern);",
                "",
                "    let ast_class_set_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                "        span: Span { start: Position(0), end: Position(1) },",
                "        negated: false,",
                "        kind: ClassSet::Normal,",
                "    }));",
                "",
                "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));",
                "    let result = translator.visit_class_set_item_post(&ast_class_set_item);",
                "",
                "    // Here the result is only expected to be Ok(()) by the function's design.",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast_class_set_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    }));",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));",
                  "    let result = translator.visit_class_set_item_post(&ast_class_set_item);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast_class_set_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    }));",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));",
                  "    let result = translator.visit_class_set_item_post(&ast_class_set_item);",
                  "    assert_eq!(translator.pop().unwrap().unwrap_class_bytes().ranges().len(), 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let ast_class_set_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        negated: false,",
                  "        kind: ClassSet::Normal,",
                  "    }));",
                  "",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));",
                  "    let result = translator.visit_class_set_item_post(&ast_class_set_item);",
                  "",
                  "    // Here the result is only expected to be Ok(()) by the function's design.",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast_class_set_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    }));",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));",
                  "    let result = translator.visit_class_set_item_post(&ast_class_set_item);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let ast_class_set_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        negated: false,",
                  "        kind: ClassSet::Normal,",
                  "    }));",
                  "",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));",
                  "    let result = translator.visit_class_set_item_post(&ast_class_set_item);",
                  "",
                  "    // Here the result is only expected to be Ok(()) by the function's design.",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast_class_set_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    negated: false,",
                  "    kind: ClassSet::Normal,",
                  "    }));",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));",
                  "    let result = translator.visit_class_set_item_post(&ast_class_set_item);",
                  "    assert_eq!(translator.pop().unwrap().unwrap_class_bytes().ranges().len(), 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2557:15\n     |\n2557 |         kind: ClassSet::Normal,\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:42\n     |\n2560 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2577:11\n     |\n2577 |     kind: ClassSet::Normal,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2579:42\n     |\n2579 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2575:25\n     |\n2575 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2575:43\n     |\n2575 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2557:15\n     |\n2557 |         kind: ClassSet::Normal,\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:42\n     |\n2560 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2577:11\n     |\n2577 |     kind: ClassSet::Normal,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2579:42\n     |\n2579 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2575:25\n     |\n2575 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2575:43\n     |\n2575 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(false),",
                "            ..Flags::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"test\";",
                "    let mut translator = TranslatorI::new(&trans, pattern);",
                "",
                "    let ast_class_set_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                "        span: Span { start: Position(0), end: Position(1) },",
                "        negated: true,",
                "        kind: ClassSet::Normal,",
                "    }));",
                "",
                "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));",
                "    ",
                "    let result = translator.visit_class_set_item_post(&ast_class_set_item);",
                "",
                "    // As this is also a valid case, it is expected to return Ok(()), due to the constraints provided.",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let pattern = \"test\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast_class_set_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span { start: Position(0), end: Position(1) }, negated: true, kind: ClassSet::Normal, }));",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));",
                  "    let result = translator.visit_class_set_item_post(&ast_class_set_item);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let ast_class_set_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        negated: true,",
                  "        kind: ClassSet::Normal,",
                  "    }));",
                  "",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));",
                  "    ",
                  "    let result = translator.visit_class_set_item_post(&ast_class_set_item);",
                  "",
                  "    // As this is also a valid case, it is expected to return Ok(()), due to the constraints provided.",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let pattern = \"test\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast_class_set_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed { span: Span { start: Position(0), end: Position(1) }, negated: true, kind: ClassSet::Normal, }));",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));",
                  "    let result = translator.visit_class_set_item_post(&ast_class_set_item);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2557:15\n     |\n2557 |         kind: ClassSet::Normal,\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:42\n     |\n2560 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2568:164\n     |\n2568 | ...(0), end: Position(1) }, negated: true, kind: ClassSet::Normal, }));\n     |                                                  ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2569:42\n     |\n2569 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:110\n     |\n2568 | ...Box::new(ast::ClassBracketed { span: Span { start: Position(0), end: Position(1) }, negated: true, kind: ClassSet::Normal, }));\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:128\n     |\n2568 | ...sBracketed { span: Span { start: Position(0), end: Position(1) }, negated: true, kind: ClassSet::Normal, }));\n     |                                                       ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(false),",
                "            ..Flags::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"test\";",
                "    let mut translator = TranslatorI::new(&trans, pattern);",
                "",
                "    let ast_class_set_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                "        span: Span { start: Position(0), end: Position(1) },",
                "        negated: false,",
                "        kind: ClassSet::Empty,",
                "    }));",
                "",
                "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));",
                "    ",
                "    let result = translator.visit_class_set_item_post(&ast_class_set_item);",
                "",
                "    // This case too should successfully obtain Ok(()), satisfying all runtime conditions.",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast_class_set_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    negated: false,",
                  "    kind: ClassSet::Empty,",
                  "    }));",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast_class_set_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    negated: false,",
                  "    kind: ClassSet::Empty,",
                  "    }));",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));",
                  "    assert_eq!(result.unwrap(), ());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let ast_class_set_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        negated: false,",
                  "        kind: ClassSet::Empty,",
                  "    }));",
                  "",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));",
                  "    ",
                  "    let result = translator.visit_class_set_item_post(&ast_class_set_item);",
                  "",
                  "    // This case too should successfully obtain Ok(()), satisfying all runtime conditions.",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast_class_set_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    negated: false,",
                  "    kind: ClassSet::Empty,",
                  "    }));",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let ast_class_set_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        negated: false,",
                  "        kind: ClassSet::Empty,",
                  "    }));",
                  "",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));",
                  "    ",
                  "    let result = translator.visit_class_set_item_post(&ast_class_set_item);",
                  "",
                  "    // This case too should successfully obtain Ok(()), satisfying all runtime conditions.",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let mut translator = TranslatorI::new(&trans, pattern);",
                  "    let ast_class_set_item = ast::ClassSetItem::Bracketed(Box::new(ast::ClassBracketed {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    negated: false,",
                  "    kind: ClassSet::Empty,",
                  "    }));",
                  "    translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));",
                  "    assert_eq!(result.unwrap(), ());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2557:15\n     |\n2557 |         kind: ClassSet::Empty,\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:42\n     |\n2560 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2578:11\n     |\n2578 |     kind: ClassSet::Empty,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2580:42\n     |\n2580 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2576:25\n     |\n2576 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2576:43\n     |\n2576 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2557:15\n     |\n2557 |         kind: ClassSet::Empty,\n     |               ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:42\n     |\n2560 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassSet`\n    --> regex-syntax/src/hir/translate.rs:2578:11\n     |\n2578 |     kind: ClassSet::Empty,\n     |           ^^^^^^^^ use of undeclared type `ClassSet`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::ClassSet;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2580:42\n     |\n2580 |     translator.push(HirFrame::ClassBytes(ClassBytes::new(vec![])));\n     |                                          ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2576:25\n     |\n2576 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2576:43\n     |\n2576 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: *ast matches ast::ClassSetItem::Perl(ref x) is true\n",
        "// constraint: *ast matches ast::ClassSetItem::Perl(ref x) is true\n",
        "// constraint: self.flags().unicode() is true\n",
        "// constraint: self.pop().unwrap() is \n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "ast::ClassSetItem::Perl { kind: ast::ClassPerlKind::Digit, negated: false }\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(1) };",
                "    let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };",
                "    let ast_flags = ast::Flags::default();",
                "    let trans = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                "",
                "    let perl_class = ast::ClassPerl {",
                "        span: span.clone(),",
                "        kind: ast::ClassPerlKind::Digit,",
                "        negated: false,",
                "    };",
                "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                "",
                "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                "",
                "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                "    // This would usually be followed by an assertion based on expected outcomes. ",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };",
                  "    let ast_flags = ast::Flags::default();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                  "    let perl_class = ast::ClassPerl {",
                  "    span: span.clone(),",
                  "    kind: ast::ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                  "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };",
                  "    let ast_flags = ast::Flags::default();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                  "    let perl_class = ast::ClassPerl {",
                  "    span: span.clone(),",
                  "    kind: ast::ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                  "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    let class = visitor.pop().unwrap().unwrap_class_unicode();",
                  "    assert_eq!(class.ranges().len(), 1);"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };",
                  "    let ast_flags = ast::Flags::default();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                  "    let perl_class = ast::ClassPerl {",
                  "    span: span.clone(),",
                  "    kind: ast::ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                  "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    let class = visitor.pop().unwrap().unwrap_class_unicode();",
                  "    let range = class.ranges()[0];",
                  "    assert_eq!(range.start(), '0');"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };",
                  "    let ast_flags = ast::Flags::default();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                  "    let perl_class = ast::ClassPerl {",
                  "    span: span.clone(),",
                  "    kind: ast::ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                  "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    let class = visitor.pop().unwrap().unwrap_class_unicode();",
                  "    let range = class.ranges()[0];",
                  "    assert_eq!(range.end(), '0');"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };",
                  "    let ast_flags = ast::Flags::default();",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                  "",
                  "    let perl_class = ast::ClassPerl {",
                  "        span: span.clone(),",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                  "",
                  "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    // This would usually be followed by an assertion based on expected outcomes. ",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };",
                  "    let ast_flags = ast::Flags::default();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                  "    let perl_class = ast::ClassPerl {",
                  "    span: span.clone(),",
                  "    kind: ast::ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                  "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };",
                  "    let ast_flags = ast::Flags::default();",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                  "",
                  "    let perl_class = ast::ClassPerl {",
                  "        span: span.clone(),",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                  "",
                  "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    // This would usually be followed by an assertion based on expected outcomes. ",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };",
                  "    let ast_flags = ast::Flags::default();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                  "    let perl_class = ast::ClassPerl {",
                  "    span: span.clone(),",
                  "    kind: ast::ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                  "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    let class = visitor.pop().unwrap().unwrap_class_unicode();",
                  "    assert_eq!(class.ranges().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };",
                  "    let ast_flags = ast::Flags::default();",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                  "",
                  "    let perl_class = ast::ClassPerl {",
                  "        span: span.clone(),",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                  "",
                  "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    // This would usually be followed by an assertion based on expected outcomes. ",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };",
                  "    let ast_flags = ast::Flags::default();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                  "    let perl_class = ast::ClassPerl {",
                  "    span: span.clone(),",
                  "    kind: ast::ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                  "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    let class = visitor.pop().unwrap().unwrap_class_unicode();",
                  "    let range = class.ranges()[0];",
                  "    assert_eq!(range.start(), '0');",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };",
                  "    let ast_flags = ast::Flags::default();",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                  "",
                  "    let perl_class = ast::ClassPerl {",
                  "        span: span.clone(),",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                  "",
                  "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    // This would usually be followed by an assertion based on expected outcomes. ",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };",
                  "    let ast_flags = ast::Flags::default();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                  "    let perl_class = ast::ClassPerl {",
                  "    span: span.clone(),",
                  "    kind: ast::ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                  "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    let class = visitor.pop().unwrap().unwrap_class_unicode();",
                  "    let range = class.ranges()[0];",
                  "    assert_eq!(range.end(), '0');",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:19\n     |\n2544 |     let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2544:55\n     |\n2544 |     let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                                                       ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:19\n     |\n2565 |     let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2565:55\n     |\n2565 |     let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                                                       ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:30\n     |\n2543 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:48\n     |\n2543 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:33\n     |\n2545 |     let ast_flags = ast::Flags::default();\n     |                                 ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1269:1\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:30\n     |\n2564 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:48\n     |\n2564 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:33\n     |\n2566 |     let ast_flags = ast::Flags::default();\n     |                                 ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1269:1\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:19\n     |\n2544 |     let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2544:55\n     |\n2544 |     let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                                                       ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:19\n     |\n2565 |     let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2565:55\n     |\n2565 |     let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                                                       ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:30\n     |\n2543 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:48\n     |\n2543 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:33\n     |\n2545 |     let ast_flags = ast::Flags::default();\n     |                                 ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1269:1\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:30\n     |\n2564 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:48\n     |\n2564 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:33\n     |\n2566 |     let ast_flags = ast::Flags::default();\n     |                                 ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1269:1\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:19\n     |\n2544 |     let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2544:55\n     |\n2544 |     let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                                                       ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:19\n     |\n2565 |     let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2565:55\n     |\n2565 |     let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                                                       ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:30\n     |\n2543 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:48\n     |\n2543 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:33\n     |\n2545 |     let ast_flags = ast::Flags::default();\n     |                                 ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1269:1\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:30\n     |\n2564 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:48\n     |\n2564 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:33\n     |\n2566 |     let ast_flags = ast::Flags::default();\n     |                                 ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1269:1\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:19\n     |\n2544 |     let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2544:55\n     |\n2544 |     let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                                                       ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:19\n     |\n2565 |     let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2565:55\n     |\n2565 |     let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                                                       ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:30\n     |\n2543 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:48\n     |\n2543 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:33\n     |\n2545 |     let ast_flags = ast::Flags::default();\n     |                                 ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1269:1\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:30\n     |\n2564 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:48\n     |\n2564 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:33\n     |\n2566 |     let ast_flags = ast::Flags::default();\n     |                                 ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1269:1\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(1) };",
                "    let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };",
                "    let ast_flags = ast::Flags::default();",
                "    let trans = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                "",
                "    let perl_class = ast::ClassPerl {",
                "        span: span.clone(),",
                "        kind: ast::ClassPerlKind::Digit,",
                "        negated: true,",
                "    };",
                "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                "",
                "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                "",
                "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };",
                  "    let ast_flags = ast::Flags::default();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                  "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };",
                  "    let ast_flags = ast::Flags::default();",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                  "",
                  "    let perl_class = ast::ClassPerl {",
                  "        span: span.clone(),",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: true,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                  "",
                  "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };",
                  "    let ast_flags = ast::Flags::default();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                  "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:19\n     |\n2544 |     let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2544:55\n     |\n2544 |     let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                                                       ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:19\n     |\n2564 |     let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2564:55\n     |\n2564 |     let literal = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                                                       ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:30\n     |\n2543 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:48\n     |\n2543 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2545:33\n     |\n2545 |     let ast_flags = ast::Flags::default();\n     |                                 ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1269:1\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:30\n     |\n2563 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:48\n     |\n2563 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `ast::Flags` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:33\n     |\n2565 |     let ast_flags = ast::Flags::default();\n     |                                 ^^^^^^^ function or associated item not found in `ast::Flags`\n     |\n    ::: regex-syntax/src/ast/mod.rs:1269:1\n     |\n1269 | pub struct Flags {\n     | ---------------- function or associated item `default` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(1) };",
                "    let trans = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                "",
                "    let perl_class = ast::ClassPerl {",
                "        span: span.clone(),",
                "        kind: ast::ClassPerlKind::Space,",
                "        negated: false,",
                "    };",
                "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                "",
                "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                "",
                "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                "}"
              ],
              "oracles": [],
              "codes": [],
              "can_compile": [],
              "repaired": []
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(1) };",
                "    let trans = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                "",
                "    let perl_class = ast::ClassPerl {",
                "        span: span.clone(),",
                "        kind: ast::ClassPerlKind::Word,",
                "        negated: false,",
                "    };",
                "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                "",
                "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                "",
                "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                  "    let perl_class = ast::ClassPerl {",
                  "    span: span.clone(),",
                  "    kind: ast::ClassPerlKind::Word,",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                  "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                  "    let perl_class = ast::ClassPerl {",
                  "    span: span.clone(),",
                  "    kind: ast::ClassPerlKind::Word,",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                  "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    assert!(visitor.pop().is_some());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                  "    let perl_class = ast::ClassPerl {",
                  "    span: span.clone(),",
                  "    kind: ast::ClassPerlKind::Word,",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                  "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    assert!(matches!(visitor.pop().unwrap(), HirFrame::ClassUnicode(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                  "",
                  "    let perl_class = ast::ClassPerl {",
                  "        span: span.clone(),",
                  "        kind: ast::ClassPerlKind::Word,",
                  "        negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                  "",
                  "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                  "    let perl_class = ast::ClassPerl {",
                  "    span: span.clone(),",
                  "    kind: ast::ClassPerlKind::Word,",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                  "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                  "",
                  "    let perl_class = ast::ClassPerl {",
                  "        span: span.clone(),",
                  "        kind: ast::ClassPerlKind::Word,",
                  "        negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                  "",
                  "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                  "    let perl_class = ast::ClassPerl {",
                  "    span: span.clone(),",
                  "    kind: ast::ClassPerlKind::Word,",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                  "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    assert!(visitor.pop().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                  "",
                  "    let perl_class = ast::ClassPerl {",
                  "        span: span.clone(),",
                  "        kind: ast::ClassPerlKind::Word,",
                  "        negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                  "",
                  "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, \"pattern\");",
                  "    let perl_class = ast::ClassPerl {",
                  "    span: span.clone(),",
                  "    kind: ast::ClassPerlKind::Word,",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Perl(perl_class);",
                  "    visitor.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    assert!(matches!(visitor.pop().unwrap(), HirFrame::ClassUnicode(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:30\n     |\n2543 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:48\n     |\n2543 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:30\n     |\n2561 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:48\n     |\n2561 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:30\n     |\n2543 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:48\n     |\n2543 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:30\n     |\n2561 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:48\n     |\n2561 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:30\n     |\n2543 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2543:48\n     |\n2543 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:30\n     |\n2561 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:48\n     |\n2561 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "// constraint: *ast matches ast::ClassSetItem::Perl(ref x) is true\n",
        "// constraint: *ast matches ast::ClassSetItem::Perl(ref x) is true\n",
        "// constraint: self.flags().unicode() is false\n",
        "// constraint: self.pop().unwrap() is \n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "(0x00, 0xFF)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                "    ",
                "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                "        span: Span { start: Position(0), end: Position(1) },",
                "        kind: ast::ClassPerlKind::Digit,",
                "        negated: false,",
                "    });",
                "    ",
                "    visitor.pop(); // Initialize the stack",
                "    ",
                "    let _ = visitor.visit_class_set_item_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    });",
                  "    visitor.visit_class_set_item_post(&ast).unwrap();",
                  "    let frame = visitor.pop().unwrap();",
                  "    assert!(matches!(frame, HirFrame::ClassBytes(_)));"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    });",
                  "    visitor.visit_class_set_item_post(&ast).unwrap();",
                  "    let frame = visitor.pop().unwrap();",
                  "    let class_bytes = if let HirFrame::ClassBytes(cls) = frame { cls } else { panic!() };",
                  "    assert!(class_bytes.iter().count() > 0);"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    });",
                  "    visitor.visit_class_set_item_post(&ast).unwrap();",
                  "    let frame = visitor.pop().unwrap();",
                  "    let class_bytes = if let HirFrame::ClassBytes(cls) = frame { cls } else { panic!() };",
                  "    let range = class_bytes.ranges();",
                  "    assert_eq!(range.len(), 1);"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    });",
                  "    visitor.visit_class_set_item_post(&ast).unwrap();",
                  "    let frame = visitor.pop().unwrap();",
                  "    let class_bytes = if let HirFrame::ClassBytes(cls) = frame { cls } else { panic!() };",
                  "    let range = class_bytes.ranges();",
                  "    assert_eq!(range[0].start(), b'0');"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    });",
                  "    visitor.visit_class_set_item_post(&ast).unwrap();",
                  "    let frame = visitor.pop().unwrap();",
                  "    let class_bytes = if let HirFrame::ClassBytes(cls) = frame { cls } else { panic!() };",
                  "    let range = class_bytes.ranges();",
                  "    assert_eq!(range[0].end(), b'9');"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "    ",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: false,",
                  "    });",
                  "    ",
                  "    visitor.pop(); // Initialize the stack",
                  "    ",
                  "    let _ = visitor.visit_class_set_item_post(&ast);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    });",
                  "    visitor.visit_class_set_item_post(&ast).unwrap();",
                  "    let frame = visitor.pop().unwrap();",
                  "    assert!(matches!(frame, HirFrame::ClassBytes(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "    ",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: false,",
                  "    });",
                  "    ",
                  "    visitor.pop(); // Initialize the stack",
                  "    ",
                  "    let _ = visitor.visit_class_set_item_post(&ast);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    });",
                  "    visitor.visit_class_set_item_post(&ast).unwrap();",
                  "    let frame = visitor.pop().unwrap();",
                  "    let class_bytes = if let HirFrame::ClassBytes(cls) = frame { cls } else { panic!() };",
                  "    assert!(class_bytes.iter().count() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "    ",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: false,",
                  "    });",
                  "    ",
                  "    visitor.pop(); // Initialize the stack",
                  "    ",
                  "    let _ = visitor.visit_class_set_item_post(&ast);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    });",
                  "    visitor.visit_class_set_item_post(&ast).unwrap();",
                  "    let frame = visitor.pop().unwrap();",
                  "    let class_bytes = if let HirFrame::ClassBytes(cls) = frame { cls } else { panic!() };",
                  "    let range = class_bytes.ranges();",
                  "    assert_eq!(range.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "    ",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: false,",
                  "    });",
                  "    ",
                  "    visitor.pop(); // Initialize the stack",
                  "    ",
                  "    let _ = visitor.visit_class_set_item_post(&ast);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    });",
                  "    visitor.visit_class_set_item_post(&ast).unwrap();",
                  "    let frame = visitor.pop().unwrap();",
                  "    let class_bytes = if let HirFrame::ClassBytes(cls) = frame { cls } else { panic!() };",
                  "    let range = class_bytes.ranges();",
                  "    assert_eq!(range[0].start(), b'0');",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "    ",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: false,",
                  "    });",
                  "    ",
                  "    visitor.pop(); // Initialize the stack",
                  "    ",
                  "    let _ = visitor.visit_class_set_item_post(&ast);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassPerlKind::Digit,",
                  "    negated: false,",
                  "    });",
                  "    visitor.visit_class_set_item_post(&ast).unwrap();",
                  "    let frame = visitor.pop().unwrap();",
                  "    let class_bytes = if let HirFrame::ClassBytes(cls) = frame { cls } else { panic!() };",
                  "    let range = class_bytes.ranges();",
                  "    assert_eq!(range[0].end(), b'9');",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:51\n     |\n2560 |     stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]),\n     |                                                   ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n2551 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:47\n     |\n2551 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:43\n     |\n2566 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:51\n     |\n2560 |     stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]),\n     |                                                   ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n2551 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:47\n     |\n2551 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:43\n     |\n2566 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:51\n     |\n2560 |     stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]),\n     |                                                   ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n2551 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:47\n     |\n2551 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:43\n     |\n2566 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:51\n     |\n2560 |     stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]),\n     |                                                   ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n2551 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:47\n     |\n2551 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:43\n     |\n2566 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:51\n     |\n2560 |     stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]),\n     |                                                   ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n2551 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:47\n     |\n2551 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:43\n     |\n2566 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                "",
                "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                "        span: Span { start: Position(2), end: Position(3) },",
                "        kind: ast::ClassPerlKind::Space,",
                "        negated: false,",
                "    });",
                "    ",
                "    visitor.pop(); // Initialize the stack",
                "    ",
                "    let _ = visitor.visit_class_set_item_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "    span: Span { start: Position(2), end: Position(3) },",
                  "    kind: ast::ClassPerlKind::Space,",
                  "    negated: false,",
                  "    });",
                  "    visitor.pop(); // Initialize the stack",
                  "    let result = visitor.visit_class_set_item_post(&ast);",
                  "    assert_eq!(result.is_ok(), true);"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "    span: Span { start: Position(2), end: Position(3) },",
                  "    kind: ast::ClassPerlKind::Space,",
                  "    negated: false,",
                  "    });",
                  "    visitor.pop(); // Initialize the stack",
                  "    let result = visitor.visit_class_set_item_post(&ast);",
                  "    let frame = visitor.pop();",
                  "    assert!(frame.is_some());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "    span: Span { start: Position(2), end: Position(3) },",
                  "    kind: ast::ClassPerlKind::Space,",
                  "    negated: false,",
                  "    });",
                  "    visitor.pop(); // Initialize the stack",
                  "    let result = visitor.visit_class_set_item_post(&ast);",
                  "    let frame = visitor.pop();",
                  "    let cls = frame.unwrap().unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges().len(), expected_length); // Replace expected_length with the actual expected value."
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "        span: Span { start: Position(2), end: Position(3) },",
                  "        kind: ast::ClassPerlKind::Space,",
                  "        negated: false,",
                  "    });",
                  "    ",
                  "    visitor.pop(); // Initialize the stack",
                  "    ",
                  "    let _ = visitor.visit_class_set_item_post(&ast);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "    span: Span { start: Position(2), end: Position(3) },",
                  "    kind: ast::ClassPerlKind::Space,",
                  "    negated: false,",
                  "    });",
                  "    visitor.pop(); // Initialize the stack",
                  "    let result = visitor.visit_class_set_item_post(&ast);",
                  "    assert_eq!(result.is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "        span: Span { start: Position(2), end: Position(3) },",
                  "        kind: ast::ClassPerlKind::Space,",
                  "        negated: false,",
                  "    });",
                  "    ",
                  "    visitor.pop(); // Initialize the stack",
                  "    ",
                  "    let _ = visitor.visit_class_set_item_post(&ast);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "    span: Span { start: Position(2), end: Position(3) },",
                  "    kind: ast::ClassPerlKind::Space,",
                  "    negated: false,",
                  "    });",
                  "    visitor.pop(); // Initialize the stack",
                  "    let result = visitor.visit_class_set_item_post(&ast);",
                  "    let frame = visitor.pop();",
                  "    assert!(frame.is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "        span: Span { start: Position(2), end: Position(3) },",
                  "        kind: ast::ClassPerlKind::Space,",
                  "        negated: false,",
                  "    });",
                  "    ",
                  "    visitor.pop(); // Initialize the stack",
                  "    ",
                  "    let _ = visitor.visit_class_set_item_post(&ast);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "    span: Span { start: Position(2), end: Position(3) },",
                  "    kind: ast::ClassPerlKind::Space,",
                  "    negated: false,",
                  "    });",
                  "    visitor.pop(); // Initialize the stack",
                  "    let result = visitor.visit_class_set_item_post(&ast);",
                  "    let frame = visitor.pop();",
                  "    let cls = frame.unwrap().unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges().len(), expected_length); // Replace expected_length with the actual expected value.",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n2551 |         span: Span { start: Position(2), end: Position(3) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:47\n     |\n2551 |         span: Span { start: Position(2), end: Position(3) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     span: Span { start: Position(2), end: Position(3) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:43\n     |\n2566 |     span: Span { start: Position(2), end: Position(3) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n2551 |         span: Span { start: Position(2), end: Position(3) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:47\n     |\n2551 |         span: Span { start: Position(2), end: Position(3) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     span: Span { start: Position(2), end: Position(3) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:43\n     |\n2566 |     span: Span { start: Position(2), end: Position(3) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `expected_length` in this scope\n    --> regex-syntax/src/hir/translate.rs:2574:36\n     |\n2574 |     assert_eq!(cls.ranges().len(), expected_length); // Replace expected_length with the actual expected value.\n     |                                    ^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n2551 |         span: Span { start: Position(2), end: Position(3) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:47\n     |\n2551 |         span: Span { start: Position(2), end: Position(3) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     span: Span { start: Position(2), end: Position(3) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:43\n     |\n2566 |     span: Span { start: Position(2), end: Position(3) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                "",
                "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                "        span: Span { start: Position(4), end: Position(5) },",
                "        kind: ast::ClassPerlKind::Word,",
                "        negated: false,",
                "    });",
                "    ",
                "    visitor.pop(); // Initialize the stack",
                "    ",
                "    let _ = visitor.visit_class_set_item_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl { span: Span { start: Position(4), end: Position(5) }, kind: ast::ClassPerlKind::Word, negated: false, });",
                  "    visitor.pop();",
                  "    let result = visitor.visit_class_set_item_post(&ast);",
                  "    assert_eq!(result, Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "        span: Span { start: Position(4), end: Position(5) },",
                  "        kind: ast::ClassPerlKind::Word,",
                  "        negated: false,",
                  "    });",
                  "    ",
                  "    visitor.pop(); // Initialize the stack",
                  "    ",
                  "    let _ = visitor.visit_class_set_item_post(&ast);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl { span: Span { start: Position(4), end: Position(5) }, kind: ast::ClassPerlKind::Word, negated: false, });",
                  "    visitor.pop();",
                  "    let result = visitor.visit_class_set_item_post(&ast);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n2551 |         span: Span { start: Position(4), end: Position(5) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:47\n     |\n2551 |         span: Span { start: Position(4), end: Position(5) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:76\n     |\n2561 |     let ast = ast::ClassSetItem::Perl(ast::ClassPerl { span: Span { start: Position(4), end: Position(5) }, kind: ast::ClassPerlKind::Wor...\n     |                                                                            ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:94\n     |\n2561 |     let ast = ast::ClassSetItem::Perl(ast::ClassPerl { span: Span { start: Position(4), end: Position(5) }, kind: ast::ClassPerlKind::Wor...\n     |                                                                                              ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                "",
                "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                "        span: Span { start: Position(6), end: Position(7) },",
                "        kind: ast::ClassPerlKind::Digit,",
                "        negated: true,",
                "    });",
                "    ",
                "    visitor.pop(); // Initialize the stack",
                "    ",
                "    let _ = visitor.visit_class_set_item_post(&ast);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    assert!(visitor.pop().is_none());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut cls = visitor.pop().unwrap().unwrap_class_bytes();",
                  "    cls.union(visitor.hir_perl_byte_class(&ast));",
                  "    visitor.push(HirFrame::ClassBytes(cls));",
                  "    assert_eq!(visitor.pop().is_some(), true);"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut cls = visitor.pop().unwrap().unwrap_class_bytes();",
                  "    cls.union(visitor.hir_perl_byte_class(&ast));",
                  "    visitor.push(HirFrame::ClassBytes(cls));",
                  "    assert!(visitor.visit_class_set_item_post(&ast).is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "        span: Span { start: Position(6), end: Position(7) },",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: true,",
                  "    });",
                  "    ",
                  "    visitor.pop(); // Initialize the stack",
                  "    ",
                  "    let _ = visitor.visit_class_set_item_post(&ast);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    assert!(visitor.pop().is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "        span: Span { start: Position(6), end: Position(7) },",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: true,",
                  "    });",
                  "    ",
                  "    visitor.pop(); // Initialize the stack",
                  "    ",
                  "    let _ = visitor.visit_class_set_item_post(&ast);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut cls = visitor.pop().unwrap().unwrap_class_bytes();",
                  "    cls.union(visitor.hir_perl_byte_class(&ast));",
                  "    visitor.push(HirFrame::ClassBytes(cls));",
                  "    assert_eq!(visitor.pop().is_some(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&translator, \"test_pattern\");",
                  "",
                  "    let ast = ast::ClassSetItem::Perl(ast::ClassPerl {",
                  "        span: Span { start: Position(6), end: Position(7) },",
                  "        kind: ast::ClassPerlKind::Digit,",
                  "        negated: true,",
                  "    });",
                  "    ",
                  "    visitor.pop(); // Initialize the stack",
                  "    ",
                  "    let _ = visitor.visit_class_set_item_post(&ast);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut cls = visitor.pop().unwrap().unwrap_class_bytes();",
                  "    cls.union(visitor.hir_perl_byte_class(&ast));",
                  "    visitor.push(HirFrame::ClassBytes(cls));",
                  "    assert!(visitor.visit_class_set_item_post(&ast).is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n2551 |         span: Span { start: Position(6), end: Position(7) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:47\n     |\n2551 |         span: Span { start: Position(6), end: Position(7) },\n     |                                               ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n2551 |         span: Span { start: Position(6), end: Position(7) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:47\n     |\n2551 |         span: Span { start: Position(6), end: Position(7) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:43\n     |\n2565 |     cls.union(visitor.hir_perl_byte_class(&ast));\n     |                       ------------------- ^^^^ expected `&ClassPerl`, found `&ClassSetItem`\n     |                       |\n     |                       arguments to this method are incorrect\n     |\n     = note: expected reference `&ClassPerl`\n                found reference `&ClassSetItem`\nnote: method defined here\n    --> regex-syntax/src/hir/translate.rs:853:8\n     |\n853  |     fn hir_perl_byte_class(\n     |        ^^^^^^^^^^^^^^^^^^^\n854  |         &self,\n855  |         ast_class: &ast::ClassPerl,\n     |         --------------------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:15\n     |\n2565 |     cls.union(visitor.hir_perl_byte_class(&ast));\n     |         ----- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassBytes`, found `ClassBytes`\n     |         |\n     |         arguments to this method are incorrect\n     |\nnote: method defined here\n    --> regex-syntax/src/hir/mod.rs:970:12\n     |\n970  |     pub fn union(&mut self, other: &ClassBytes) {\n     |            ^^^^^            ------------------\nhelp: consider borrowing here\n     |\n2565 |     cls.union(&visitor.hir_perl_byte_class(&ast));\n     |               +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n2551 |         span: Span { start: Position(6), end: Position(7) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:47\n     |\n2551 |         span: Span { start: Position(6), end: Position(7) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:43\n     |\n2565 |     cls.union(visitor.hir_perl_byte_class(&ast));\n     |                       ------------------- ^^^^ expected `&ClassPerl`, found `&ClassSetItem`\n     |                       |\n     |                       arguments to this method are incorrect\n     |\n     = note: expected reference `&ClassPerl`\n                found reference `&ClassSetItem`\nnote: method defined here\n    --> regex-syntax/src/hir/translate.rs:853:8\n     |\n853  |     fn hir_perl_byte_class(\n     |        ^^^^^^^^^^^^^^^^^^^\n854  |         &self,\n855  |         ast_class: &ast::ClassPerl,\n     |         --------------------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2565:15\n     |\n2565 |     cls.union(visitor.hir_perl_byte_class(&ast));\n     |         ----- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&ClassBytes`, found `ClassBytes`\n     |         |\n     |         arguments to this method are incorrect\n     |\nnote: method defined here\n    --> regex-syntax/src/hir/mod.rs:970:12\n     |\n970  |     pub fn union(&mut self, other: &ClassBytes) {\n     |            ^^^^^            ------------------\nhelp: consider borrowing here\n     |\n2565 |     cls.union(&visitor.hir_perl_byte_class(&ast));\n     |               +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 7,
      "prompt_conds": [
        "// constraint: *ast matches ast::ClassSetItem::Unicode(ref x) is true\n",
        "// constraint: *ast matches ast::ClassSetItem::Unicode(ref x) is true\n",
        "// constraint: self.hir_unicode_class(x)? is Err/None\n"
      ],
      "input_infer": "start: 0x0000, end: 0x10FFFF\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut flags = Flags::default();",
                "    flags.unicode = Some(true);",
                "    ",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    ",
                "    let span = Span { start: Position(0), end: Position(10) };",
                "    let ast_class = ast::ClassUnicode {",
                "        span,",
                "        kind: ast::ClassUnicodeKind::OneLetter(\"unknown_property\"),",
                "        negated: false,",
                "    };",
                "    ",
                "    let ast = ast::ClassSetItem::Unicode(ast_class.clone());",
                "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                "",
                "    translator_i.visit_class_set_item_post(&ast).unwrap_err();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let ast_class = ast::ClassUnicode {",
                  "    span,",
                  "    kind: ast::ClassUnicodeKind::OneLetter(\"unknown_property\"),",
                  "    negated: false,",
                  "    };",
                  "    let ast = ast::ClassSetItem::Unicode(ast_class.clone());",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.visit_class_set_item_post(&ast);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let ast_class = ast::ClassUnicode {",
                  "    span,",
                  "    kind: ast::ClassUnicodeKind::OneLetter(\"unknown_property\"),",
                  "    negated: false,",
                  "    };",
                  "    let ast = ast::ClassSetItem::Unicode(ast_class.clone());",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.visit_class_set_item_post(&ast);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::UnicodePropertyNotFound);"
                ],
                [
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let ast_class = ast::ClassUnicode {",
                  "    span,",
                  "    kind: ast::ClassUnicodeKind::OneLetter(\"unknown_property\"),",
                  "    negated: false,",
                  "    };",
                  "    let ast = ast::ClassSetItem::Unicode(ast_class.clone());",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.visit_class_set_item_post(&ast);",
                  "    assert_eq!(result.err().unwrap().pattern, \"pattern\");"
                ],
                [
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let ast_class = ast::ClassUnicode {",
                  "    span,",
                  "    kind: ast::ClassUnicodeKind::OneLetter(\"unknown_property\"),",
                  "    negated: false,",
                  "    };",
                  "    let ast = ast::ClassSetItem::Unicode(ast_class.clone());",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.visit_class_set_item_post(&ast);",
                  "    assert_eq!(result.err().unwrap().span, span);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let ast_class = ast::ClassUnicode {",
                  "        span,",
                  "        kind: ast::ClassUnicodeKind::OneLetter(\"unknown_property\"),",
                  "        negated: false,",
                  "    };",
                  "    ",
                  "    let ast = ast::ClassSetItem::Unicode(ast_class.clone());",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap_err();",
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let ast_class = ast::ClassUnicode {",
                  "    span,",
                  "    kind: ast::ClassUnicodeKind::OneLetter(\"unknown_property\"),",
                  "    negated: false,",
                  "    };",
                  "    let ast = ast::ClassSetItem::Unicode(ast_class.clone());",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.visit_class_set_item_post(&ast);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let ast_class = ast::ClassUnicode {",
                  "        span,",
                  "        kind: ast::ClassUnicodeKind::OneLetter(\"unknown_property\"),",
                  "        negated: false,",
                  "    };",
                  "    ",
                  "    let ast = ast::ClassSetItem::Unicode(ast_class.clone());",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap_err();",
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let ast_class = ast::ClassUnicode {",
                  "    span,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('u'),",
                  "    negated: false,",
                  "    };",
                  "    let ast = ast::ClassSetItem::Unicode(ast_class.clone());",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.visit_class_set_item_post(&ast);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::UnicodePropertyNotFound);",
                  "}"
                ],
                [
                  "{",
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let ast_class = ast::ClassUnicode {",
                  "        span,",
                  "        kind: ast::ClassUnicodeKind::OneLetter(\"unknown_property\"),",
                  "        negated: false,",
                  "    };",
                  "    ",
                  "    let ast = ast::ClassSetItem::Unicode(ast_class.clone());",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap_err();",
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let ast_class = ast::ClassUnicode {",
                  "    span,",
                  "    kind: ast::ClassUnicodeKind::OneLetter(\"unknown_property\"),",
                  "    negated: false,",
                  "    };",
                  "    let ast = ast::ClassSetItem::Unicode(ast_class.clone());",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.visit_class_set_item_post(&ast);",
                  "    assert_eq!(result.err().unwrap().pattern, \"pattern\");",
                  "}"
                ],
                [
                  "{",
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let ast_class = ast::ClassUnicode {",
                  "        span,",
                  "        kind: ast::ClassUnicodeKind::OneLetter(\"unknown_property\"),",
                  "        negated: false,",
                  "    };",
                  "    ",
                  "    let ast = ast::ClassSetItem::Unicode(ast_class.clone());",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap_err();",
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let ast_class = ast::ClassUnicode {",
                  "    span,",
                  "    kind: ast::ClassUnicodeKind::OneLetter(\"unknown_property\"),",
                  "    negated: false,",
                  "    };",
                  "    let ast = ast::ClassSetItem::Unicode(ast_class.clone());",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.visit_class_set_item_post(&ast);",
                  "    assert_eq!(result.err().unwrap().span, span);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:48\n     |\n2555 |         kind: ast::ClassUnicodeKind::OneLetter(\"unknown_property\"),\n     |               -------------------------------- ^^^^^^^^^^^^^^^^^^ expected `char`, found `&str`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:873:5\n     |\n873  |     OneLetter(char),\n     |     ^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:30\n     |\n2570 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:48\n     |\n2570 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:44\n     |\n2573 |     kind: ast::ClassUnicodeKind::OneLetter(\"unknown_property\"),\n     |           -------------------------------- ^^^^^^^^^^^^^^^^^^ expected `char`, found `&str`\n     |           |\n     |           arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:873:5\n     |\n873  |     OneLetter(char),\n     |     ^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:48\n     |\n2555 |         kind: ast::ClassUnicodeKind::OneLetter(\"unknown_property\"),\n     |               -------------------------------- ^^^^^^^^^^^^^^^^^^ expected `char`, found `&str`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:873:5\n     |\n873  |     OneLetter(char),\n     |     ^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:30\n     |\n2570 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:48\n     |\n2570 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:48\n     |\n2555 |         kind: ast::ClassUnicodeKind::OneLetter(\"unknown_property\"),\n     |               -------------------------------- ^^^^^^^^^^^^^^^^^^ expected `char`, found `&str`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:873:5\n     |\n873  |     OneLetter(char),\n     |     ^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:30\n     |\n2570 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:48\n     |\n2570 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:44\n     |\n2573 |     kind: ast::ClassUnicodeKind::OneLetter(\"unknown_property\"),\n     |           -------------------------------- ^^^^^^^^^^^^^^^^^^ expected `char`, found `&str`\n     |           |\n     |           arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:873:5\n     |\n873  |     OneLetter(char),\n     |     ^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2555:48\n     |\n2555 |         kind: ast::ClassUnicodeKind::OneLetter(\"unknown_property\"),\n     |               -------------------------------- ^^^^^^^^^^^^^^^^^^ expected `char`, found `&str`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:873:5\n     |\n873  |     OneLetter(char),\n     |     ^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:30\n     |\n2570 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:48\n     |\n2570 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:44\n     |\n2573 |     kind: ast::ClassUnicodeKind::OneLetter(\"unknown_property\"),\n     |           -------------------------------- ^^^^^^^^^^^^^^^^^^ expected `char`, found `&str`\n     |           |\n     |           arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:873:5\n     |\n873  |     OneLetter(char),\n     |     ^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut flags = Flags::default();",
                "    flags.unicode = Some(true);",
                "    ",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    ",
                "    let span = Span { start: Position(0), end: Position(10) };",
                "    let ast_class = ast::ClassUnicode {",
                "        span,",
                "        kind: ast::ClassUnicodeKind::NamedValue {",
                "            name: \"unknown_property\",",
                "            value: \"unknown_value\",",
                "            negated: false,",
                "        },",
                "        negated: false,",
                "    };",
                "    ",
                "    let ast = ast::ClassSetItem::Unicode(ast_class);",
                "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                "",
                "    translator_i.visit_class_set_item_post(&ast).unwrap_err();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let ast_class = ast::ClassUnicode {",
                  "    span,",
                  "    kind: ast::ClassUnicodeKind::NamedValue {",
                  "    name: \"unknown_property\",",
                  "    value: \"unknown_value\",",
                  "    negated: false,",
                  "    },",
                  "    negated: false,",
                  "    };",
                  "    let ast = ast::ClassSetItem::Unicode(ast_class);",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.visit_class_set_item_post(&ast);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let ast_class = ast::ClassUnicode {",
                  "    span,",
                  "    kind: ast::ClassUnicodeKind::NamedValue {",
                  "    name: \"unknown_property\",",
                  "    value: \"unknown_value\",",
                  "    negated: false,",
                  "    },",
                  "    negated: false,",
                  "    };",
                  "    let ast = ast::ClassSetItem::Unicode(ast_class);",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.visit_class_set_item_post(&ast);",
                  "    assert_eq!(result.unwrap_err().kind, ErrorKind::UnicodePropertyNotFound);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let ast_class = ast::ClassUnicode {",
                  "        span,",
                  "        kind: ast::ClassUnicodeKind::NamedValue {",
                  "            name: \"unknown_property\",",
                  "            value: \"unknown_value\",",
                  "            negated: false,",
                  "        },",
                  "        negated: false,",
                  "    };",
                  "    ",
                  "    let ast = ast::ClassSetItem::Unicode(ast_class);",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap_err();",
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let ast_class = ast::ClassUnicode {",
                  "    span,",
                  "    kind: ast::ClassUnicodeKind::NamedValue {",
                  "    name: \"unknown_property\",",
                  "    value: \"unknown_value\",",
                  "    negated: false,",
                  "    },",
                  "    negated: false,",
                  "    };",
                  "    let ast = ast::ClassSetItem::Unicode(ast_class);",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.visit_class_set_item_post(&ast);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "",
                  "    let ast_class = ast::ClassUnicode {",
                  "        span,",
                  "        kind: ast::ClassUnicodeKind::NamedValue {",
                  "            name: \"unknown_property\",",
                  "            value: \"unknown_value\",",
                  "            negated: false,",
                  "        },",
                  "        negated: false,",
                  "    };",
                  "    ",
                  "    let ast = ast::ClassSetItem::Unicode(ast_class);",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap_err();",
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let ast_class = ast::ClassUnicode {",
                  "    span,",
                  "    kind: ast::ClassUnicodeKind::NamedValue {",
                  "    name: \"unknown_property\",",
                  "    value: \"unknown_value\",",
                  "    negated: false,",
                  "    },",
                  "    negated: false,",
                  "    };",
                  "    let ast = ast::ClassSetItem::Unicode(ast_class);",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.visit_class_set_item_post(&ast);",
                  "    assert_eq!(result.unwrap_err().kind, ErrorKind::UnicodePropertyNotFound);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:19\n     |\n2556 |             name: \"unknown_property\",\n     |                   ^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n     |                   |\n     |                   expected `String`, found `&str`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:20\n     |\n2557 |             value: \"unknown_value\",\n     |                    ^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n     |                    |\n     |                    expected `String`, found `&str`\n\nerror[E0559]: variant `ClassUnicodeKind::NamedValue` has no field named `negated`\n    --> regex-syntax/src/hir/translate.rs:2558:13\n     |\n2558 |             negated: false,\n     |             ^^^^^^^ `ClassUnicodeKind::NamedValue` does not have this field\n     |\n     = note: available fields are: `op`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2574:30\n     |\n2574 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2574:48\n     |\n2574 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2578:11\n     |\n2578 |     name: \"unknown_property\",\n     |           ^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n     |           |\n     |           expected `String`, found `&str`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:12\n     |\n2579 |     value: \"unknown_value\",\n     |            ^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n     |            |\n     |            expected `String`, found `&str`\n\nerror[E0559]: variant `ClassUnicodeKind::NamedValue` has no field named `negated`\n    --> regex-syntax/src/hir/translate.rs:2580:5\n     |\n2580 |     negated: false,\n     |     ^^^^^^^ `ClassUnicodeKind::NamedValue` does not have this field\n     |\n     = note: available fields are: `op`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0559.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0425]: cannot find value `span` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:9\n     |\n2554 |         span,\n     |         ^^^^ not found in this scope\n     |\nnote: function `ast::parse::tests::span` exists but is inaccessible\n    --> regex-syntax/src/ast/parse.rs:2336:5\n     |\n2336 |     fn span(range: Range<usize>) -> Span {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not accessible\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2556:19\n     |\n2556 |             name: \"unknown_property\",\n     |                   ^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n     |                   |\n     |                   expected `String`, found `&str`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:20\n     |\n2557 |             value: \"unknown_value\",\n     |                    ^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n     |                    |\n     |                    expected `String`, found `&str`\n\nerror[E0559]: variant `ClassUnicodeKind::NamedValue` has no field named `negated`\n    --> regex-syntax/src/hir/translate.rs:2558:13\n     |\n2558 |             negated: false,\n     |             ^^^^^^^ `ClassUnicodeKind::NamedValue` does not have this field\n     |\n     = note: available fields are: `op`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2574:30\n     |\n2574 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2574:48\n     |\n2574 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2578:11\n     |\n2578 |     name: \"unknown_property\",\n     |           ^^^^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n     |           |\n     |           expected `String`, found `&str`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:12\n     |\n2579 |     value: \"unknown_value\",\n     |            ^^^^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n     |            |\n     |            expected `String`, found `&str`\n\nerror[E0559]: variant `ClassUnicodeKind::NamedValue` has no field named `negated`\n    --> regex-syntax/src/hir/translate.rs:2580:5\n     |\n2580 |     negated: false,\n     |     ^^^^^^^ `ClassUnicodeKind::NamedValue` does not have this field\n     |\n     = note: available fields are: `op`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0559.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut flags = Flags::default();",
                "    flags.unicode = Some(true);",
                "",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let span = Span { start: Position(0), end: Position(10) };",
                "    let ast_class = ast::ClassUnicode {",
                "        span,",
                "        kind: ast::ClassUnicodeKind::OneLetter('A'),",
                "        negated: false,",
                "    };",
                "",
                "    let ast = ast::ClassSetItem::Unicode(ast_class);",
                "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                "",
                "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let ast_class = ast::ClassUnicode {",
                  "    span,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "    negated: false,",
                  "    };",
                  "    let ast = ast::ClassSetItem::Unicode(ast_class);",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.visit_class_set_item_post(&ast);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let ast_class = ast::ClassUnicode {",
                  "    span,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "    negated: false,",
                  "    };",
                  "    let ast = ast::ClassSetItem::Unicode(ast_class);",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.visit_class_set_item_post(&ast);",
                  "    assert_eq!(result.unwrap_err().kind, ErrorKind::UnicodePropertyNotFound);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let ast_class = ast::ClassUnicode {",
                  "        span,",
                  "        kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "        negated: false,",
                  "    };",
                  "",
                  "    let ast = ast::ClassSetItem::Unicode(ast_class);",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let ast_class = ast::ClassUnicode {",
                  "    span,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "    negated: false,",
                  "    };",
                  "    let ast = ast::ClassSetItem::Unicode(ast_class);",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.visit_class_set_item_post(&ast);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let ast_class = ast::ClassUnicode {",
                  "        span,",
                  "        kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "        negated: false,",
                  "    };",
                  "",
                  "    let ast = ast::ClassSetItem::Unicode(ast_class);",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(10) };",
                  "    let ast_class = ast::ClassUnicode {",
                  "    span,",
                  "    kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "    negated: false,",
                  "    };",
                  "    let ast = ast::ClassSetItem::Unicode(ast_class);",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.visit_class_set_item_post(&ast);",
                  "    assert_eq!(result.unwrap_err().kind, ErrorKind::UnicodePropertyNotFound);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:30\n     |\n2570 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:48\n     |\n2570 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:30\n     |\n2570 |     let span = Span { start: Position(0), end: Position(10) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:48\n     |\n2570 |     let span = Span { start: Position(0), end: Position(10) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut flags = Flags::default();",
                "    flags.unicode = Some(true);",
                "",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let ast = ast::ClassSetItem::Empty(Span { start: Position(0), end: Position(10) });",
                "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                "",
                "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = ast::ClassSetItem::Unicode(/* fill with a mock value */);",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    assert!(translator_i.visit_class_set_item_post(&ast).is_err());"
                ],
                [
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = ast::ClassSetItem::Unicode(/* fill with a mock value */);",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let ast = ast::ClassSetItem::Empty(Span { start: Position(0), end: Position(10) });",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = ast::ClassSetItem::Unicode(/* fill with a mock value */);",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    assert!(translator_i.visit_class_set_item_post(&ast).is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let ast = ast::ClassSetItem::Empty(Span { start: Position(0), end: Position(10) });",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut flags = Flags::default();",
                  "    flags.unicode = Some(true);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast = ast::ClassSetItem::Unicode(/* fill with a mock value */);",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:54\n     |\n2552 |     let ast = ast::ClassSetItem::Empty(Span { start: Position(0), end: Position(10) });\n     |                                                      ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:72\n     |\n2552 |     let ast = ast::ClassSetItem::Empty(Span { start: Position(0), end: Position(10) });\n     |                                                                        ^^^^^^^^ not found in this scope\n\nerror[E0061]: this enum variant takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/translate.rs:2563:15\n     |\n2563 |     let ast = ast::ClassSetItem::Unicode(/* fill with a mock value */);\n     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^------------------------------ argument #1 of type `ast::ClassUnicode` is missing\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:977:5\n     |\n977  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\nhelp: provide the argument\n     |\n2563 |     let ast = ast::ClassSetItem::Unicode(/* ast::ClassUnicode */);\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0425.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:54\n     |\n2552 |     let ast = ast::ClassSetItem::Empty(Span { start: Position(0), end: Position(10) });\n     |                                                      ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:72\n     |\n2552 |     let ast = ast::ClassSetItem::Empty(Span { start: Position(0), end: Position(10) });\n     |                                                                        ^^^^^^^^ not found in this scope\n\nerror[E0061]: this enum variant takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/translate.rs:2563:15\n     |\n2563 |     let ast = ast::ClassSetItem::Unicode(/* fill with a mock value */);\n     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^------------------------------ argument #1 of type `ast::ClassUnicode` is missing\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:977:5\n     |\n977  |     Unicode(ClassUnicode),\n     |     ^^^^^^^\nhelp: provide the argument\n     |\n2563 |     let ast = ast::ClassSetItem::Unicode(/* ast::ClassUnicode */);\n     |                                         ~~~~~~~~~~~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0425.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 8,
      "prompt_conds": [
        "// constraint: *ast matches ast::ClassSetItem::Unicode(ref x) is true\n",
        "// constraint: *ast matches ast::ClassSetItem::Unicode(ref x) is true\n",
        "// constraint: self.hir_unicode_class(x)? is Ok/Some\n",
        "// constraint: self.pop().unwrap() is \n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "ast::ClassSetItem::Unicode(ref x) where x is valid, self.pop().unwrap() returns a valid HirFrame, self.hir_unicode_class(x) returns Ok with valid ClassUnicode ranges.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    ",
                "    let unicode_class = ast::ClassUnicode {",
                "        span: Span { start: Position(0), end: Position(10) },",
                "        kind: ast::ClassUnicodeKind::OneLetter('A'),",
                "        negated: false,",
                "    };",
                "",
                "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                "",
                "    translator.visit_class_set_item_post(&class_set_item).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    assert_eq!(translator.stack.borrow().len(), 1);"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    assert!(matches!(translator.stack.borrow().last(), Some(HirFrame::ClassUnicode(_))));"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    translator.visit_class_set_item_post(&class_set_item).unwrap();",
                  "    assert_eq!(translator.stack.borrow().len(), 1);"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    translator.visit_class_set_item_post(&class_set_item).unwrap();",
                  "    assert!(matches!(translator.stack.borrow().last(), Some(HirFrame::ClassUnicode(_))));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "        negated: false,",
                  "    };",
                  "",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    translator.visit_class_set_item_post(&class_set_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    assert_eq!(translator.stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "        negated: false,",
                  "    };",
                  "",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    translator.visit_class_set_item_post(&class_set_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    assert!(matches!(translator.stack.borrow().last(), Some(HirFrame::ClassUnicode(_))));",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "        negated: false,",
                  "    };",
                  "",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    translator.visit_class_set_item_post(&class_set_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    translator.visit_class_set_item_post(&class_set_item).unwrap();",
                  "    assert_eq!(translator.stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "        negated: false,",
                  "    };",
                  "",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    translator.visit_class_set_item_post(&class_set_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassUnicodeKind::OneLetter('A'),",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    translator.visit_class_set_item_post(&class_set_item).unwrap();",
                  "    assert!(matches!(translator.stack.borrow().last(), Some(HirFrame::ClassUnicode(_))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:29\n     |\n2550 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:47\n     |\n2550 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2556 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2558 |     translator.visit_class_set_item_post(&class_set_item).unwrap();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:25\n     |\n2565 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:43\n     |\n2565 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2570 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:29\n     |\n2550 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:47\n     |\n2550 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2556 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2558 |     translator.visit_class_set_item_post(&class_set_item).unwrap();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:25\n     |\n2565 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:43\n     |\n2565 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2570 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:29\n     |\n2550 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:47\n     |\n2550 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2556 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2558 |     translator.visit_class_set_item_post(&class_set_item).unwrap();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:25\n     |\n2565 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:43\n     |\n2565 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2570 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2571:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2571 |     translator.visit_class_set_item_post(&class_set_item).unwrap();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:29\n     |\n2550 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:47\n     |\n2550 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2556 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2558 |     translator.visit_class_set_item_post(&class_set_item).unwrap();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:25\n     |\n2565 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:43\n     |\n2565 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2570 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2571:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2571 |     translator.visit_class_set_item_post(&class_set_item).unwrap();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let unicode_class = ast::ClassUnicode {",
                "        span: Span { start: Position(0), end: Position(10) },",
                "        kind: ast::ClassUnicodeKind::Named(\"Greek\"),",
                "        negated: true,",
                "    };",
                "",
                "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                "",
                "    translator.visit_class_set_item_post(&class_set_item).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassUnicodeKind::Named(\"Greek\"),",
                  "    negated: true,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassUnicodeKind::Named(\"Greek\"),",
                  "    negated: true,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    assert!(matches!(frame, HirFrame::ClassUnicode(_)));"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassUnicodeKind::Named(\"Greek\"),",
                  "    negated: true,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    let cls = frame.unwrap_class_unicode();",
                  "    assert!(cls.iter().next().is_some());"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassUnicodeKind::Named(\"Greek\"),",
                  "    negated: true,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    let cls = frame.unwrap_class_unicode();",
                  "    assert!(cls.negated);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassUnicodeKind::Named(\"Greek\"),",
                  "        negated: true,",
                  "    };",
                  "",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    translator.visit_class_set_item_post(&class_set_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassUnicodeKind::Named(\"Greek\"),",
                  "    negated: true,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassUnicodeKind::Named(\"Greek\"),",
                  "        negated: true,",
                  "    };",
                  "",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    translator.visit_class_set_item_post(&class_set_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassUnicodeKind::Named(\"Greek\"),",
                  "    negated: true,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    assert!(matches!(frame, HirFrame::ClassUnicode(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassUnicodeKind::Named(\"Greek\"),",
                  "        negated: true,",
                  "    };",
                  "",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    translator.visit_class_set_item_post(&class_set_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassUnicodeKind::Named(\"Greek\"),",
                  "    negated: true,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    let cls = frame.unwrap_class_unicode();",
                  "    assert!(cls.iter().next().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassUnicodeKind::Named(\"Greek\"),",
                  "        negated: true,",
                  "    };",
                  "",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    translator.visit_class_set_item_post(&class_set_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassUnicodeKind::Named(\"Greek\"),",
                  "    negated: true,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    let cls = frame.unwrap_class_unicode();",
                  "    assert!(cls.negated);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:29\n     |\n2550 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:47\n     |\n2550 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2551:44\n     |\n2551 |         kind: ast::ClassUnicodeKind::Named(\"Greek\"),\n     |               ---------------------------- ^^^^^^^- help: try using a conversion method: `.to_string()`\n     |               |                            |\n     |               |                            expected `String`, found `&str`\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:876:5\n     |\n876  |     Named(String),\n     |     ^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2556 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2558 |     translator.visit_class_set_item_post(&class_set_item).unwrap();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:25\n     |\n2565 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:43\n     |\n2565 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:40\n     |\n2566 |     kind: ast::ClassUnicodeKind::Named(\"Greek\"),\n     |           ---------------------------- ^^^^^^^- help: try using a conversion method: `.to_string()`\n     |           |                            |\n     |           |                            expected `String`, found `&str`\n     |           arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:876:5\n     |\n876  |     Named(String),\n     |     ^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2570 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2571:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2571 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:29\n     |\n2550 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:47\n     |\n2550 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2551:44\n     |\n2551 |         kind: ast::ClassUnicodeKind::Named(\"Greek\"),\n     |               ---------------------------- ^^^^^^^- help: try using a conversion method: `.to_string()`\n     |               |                            |\n     |               |                            expected `String`, found `&str`\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:876:5\n     |\n876  |     Named(String),\n     |     ^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2556 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2558 |     translator.visit_class_set_item_post(&class_set_item).unwrap();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:25\n     |\n2565 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:43\n     |\n2565 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:40\n     |\n2566 |     kind: ast::ClassUnicodeKind::Named(\"Greek\"),\n     |           ---------------------------- ^^^^^^^- help: try using a conversion method: `.to_string()`\n     |           |                            |\n     |           |                            expected `String`, found `&str`\n     |           arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:876:5\n     |\n876  |     Named(String),\n     |     ^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2570 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2571:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2571 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2572:28\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2572 |     let frame = translator.pop().unwrap();\n     |                            ^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:29\n     |\n2550 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:47\n     |\n2550 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2551:44\n     |\n2551 |         kind: ast::ClassUnicodeKind::Named(\"Greek\"),\n     |               ---------------------------- ^^^^^^^- help: try using a conversion method: `.to_string()`\n     |               |                            |\n     |               |                            expected `String`, found `&str`\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:876:5\n     |\n876  |     Named(String),\n     |     ^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2556 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2558 |     translator.visit_class_set_item_post(&class_set_item).unwrap();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:25\n     |\n2565 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:43\n     |\n2565 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:40\n     |\n2566 |     kind: ast::ClassUnicodeKind::Named(\"Greek\"),\n     |           ---------------------------- ^^^^^^^- help: try using a conversion method: `.to_string()`\n     |           |                            |\n     |           |                            expected `String`, found `&str`\n     |           arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:876:5\n     |\n876  |     Named(String),\n     |     ^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2570 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2571:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2571 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2572:28\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2572 |     let frame = translator.pop().unwrap();\n     |                            ^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:29\n     |\n2550 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:47\n     |\n2550 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2551:44\n     |\n2551 |         kind: ast::ClassUnicodeKind::Named(\"Greek\"),\n     |               ---------------------------- ^^^^^^^- help: try using a conversion method: `.to_string()`\n     |               |                            |\n     |               |                            expected `String`, found `&str`\n     |               arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:876:5\n     |\n876  |     Named(String),\n     |     ^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2556 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2558 |     translator.visit_class_set_item_post(&class_set_item).unwrap();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:25\n     |\n2565 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:43\n     |\n2565 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:40\n     |\n2566 |     kind: ast::ClassUnicodeKind::Named(\"Greek\"),\n     |           ---------------------------- ^^^^^^^- help: try using a conversion method: `.to_string()`\n     |           |                            |\n     |           |                            expected `String`, found `&str`\n     |           arguments to this enum variant are incorrect\n     |\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:876:5\n     |\n876  |     Named(String),\n     |     ^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2570 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2571:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2571 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2572:28\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2572 |     let frame = translator.pop().unwrap();\n     |                            ^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let unicode_class = ast::ClassUnicode {",
                "        span: Span { start: Position(0), end: Position(10) },",
                "        kind: ast::ClassUnicodeKind::NamedValue { name: \"script\".into(), value: \"Latin\".into() },",
                "        negated: false,",
                "    };",
                "",
                "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                "",
                "    translator.visit_class_set_item_post(&class_set_item).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassUnicodeKind::NamedValue { name: \"script\".into(), value: \"Latin\".into() },",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassUnicodeKind::NamedValue { name: \"script\".into(), value: \"Latin\".into() },",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    assert!(matches!(frame, HirFrame::ClassUnicode(_)));"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassUnicodeKind::NamedValue { name: \"script\".into(), value: \"Latin\".into() },",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    let cls = frame.unwrap_class_unicode();",
                  "    assert!(!cls.is_empty());"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassUnicodeKind::NamedValue { name: \"script\".into(), value: \"Latin\".into() },",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    let cls = frame.unwrap_class_unicode();",
                  "    let expected_class = translator.hir_unicode_class(&unicode_class).unwrap();",
                  "    assert!(cls.union(&expected_class));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassUnicodeKind::NamedValue { name: \"script\".into(), value: \"Latin\".into() },",
                  "        negated: false,",
                  "    };",
                  "",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    translator.visit_class_set_item_post(&class_set_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassUnicodeKind::NamedValue { name: \"script\".into(), value: \"Latin\".into() },",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassUnicodeKind::NamedValue { name: \"script\".into(), value: \"Latin\".into() },",
                  "        negated: false,",
                  "    };",
                  "",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    translator.visit_class_set_item_post(&class_set_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassUnicodeKind::NamedValue { name: \"script\".into(), value: \"Latin\".into() },",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    assert!(matches!(frame, HirFrame::ClassUnicode(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassUnicodeKind::NamedValue { name: \"script\".into(), value: \"Latin\".into() },",
                  "        negated: false,",
                  "    };",
                  "",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    translator.visit_class_set_item_post(&class_set_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassUnicodeKind::NamedValue { name: \"script\".into(), value: \"Latin\".into() },",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    let cls = frame.unwrap_class_unicode();",
                  "    assert!(!cls.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let unicode_class = ast::ClassUnicode {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassUnicodeKind::NamedValue { name: \"script\".into(), value: \"Latin\".into() },",
                  "        negated: false,",
                  "    };",
                  "",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    translator.visit_class_set_item_post(&class_set_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let unicode_class = ast::ClassUnicode {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassUnicodeKind::NamedValue { name: \"script\".into(), value: \"Latin\".into() },",
                  "    negated: false,",
                  "    };",
                  "    let class_set_item = ast::ClassSetItem::Unicode(unicode_class);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    let cls = frame.unwrap_class_unicode();",
                  "    let expected_class = translator.hir_unicode_class(&unicode_class).unwrap();",
                  "    assert!(cls.union(&expected_class));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n2547 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:47\n     |\n2547 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `op` in initializer of `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |         kind: ast::ClassUnicodeKind::NamedValue { name: \"script\".into(), value: \"Latin\".into() },\n     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `op`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2553:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2553 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2555:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2555 |     translator.visit_class_set_item_post(&class_set_item).unwrap();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:25\n     |\n2562 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:43\n     |\n2562 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `op` in initializer of `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2563:11\n     |\n2563 |     kind: ast::ClassUnicodeKind::NamedValue { name: \"script\".into(), value: \"Latin\".into() },\n     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `op`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2567 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2568 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n2547 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:47\n     |\n2547 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `op` in initializer of `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |         kind: ast::ClassUnicodeKind::NamedValue { name: \"script\".into(), value: \"Latin\".into() },\n     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `op`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2553:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2553 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2555:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2555 |     translator.visit_class_set_item_post(&class_set_item).unwrap();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:25\n     |\n2562 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:43\n     |\n2562 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `op` in initializer of `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2563:11\n     |\n2563 |     kind: ast::ClassUnicodeKind::NamedValue { name: \"script\".into(), value: \"Latin\".into() },\n     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `op`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2567 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2568 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:28\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2569 |     let frame = translator.pop().unwrap();\n     |                            ^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n2547 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:47\n     |\n2547 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `op` in initializer of `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |         kind: ast::ClassUnicodeKind::NamedValue { name: \"script\".into(), value: \"Latin\".into() },\n     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `op`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2553:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2553 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2555:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2555 |     translator.visit_class_set_item_post(&class_set_item).unwrap();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:25\n     |\n2562 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:43\n     |\n2562 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `op` in initializer of `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2563:11\n     |\n2563 |     kind: ast::ClassUnicodeKind::NamedValue { name: \"script\".into(), value: \"Latin\".into() },\n     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `op`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2567 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2568 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:28\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2569 |     let frame = translator.pop().unwrap();\n     |                            ^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n2547 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:47\n     |\n2547 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `op` in initializer of `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |         kind: ast::ClassUnicodeKind::NamedValue { name: \"script\".into(), value: \"Latin\".into() },\n     |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `op`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2553:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2553 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2555:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2555 |     translator.visit_class_set_item_post(&class_set_item).unwrap();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:25\n     |\n2562 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:43\n     |\n2562 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0063]: missing field `op` in initializer of `ClassUnicodeKind`\n    --> regex-syntax/src/hir/translate.rs:2563:11\n     |\n2563 |     kind: ast::ClassUnicodeKind::NamedValue { name: \"script\".into(), value: \"Latin\".into() },\n     |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ missing `op`\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2567 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2568 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:28\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2569 |     let frame = translator.pop().unwrap();\n     |                            ^^^ method not found in `Translator`\n\nerror[E0599]: no method named `hir_unicode_class` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2571:37\n     |\n118  | pub struct Translator {\n     | --------------------- method `hir_unicode_class` not found for this struct\n...\n2571 |     let expected_class = translator.hir_unicode_class(&unicode_class).unwrap();\n     |                                     ^^^^^^^^^^^^^^^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 9,
      "prompt_conds": [
        "// constraint: *ast matches ast::ClassSetItem::Ascii(ref x) is true\n",
        "// constraint: *ast matches ast::ClassSetItem::Ascii(ref x) is true\n",
        "// constraint: self.flags().unicode() is true\n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: &(s, e) in ascii_class(&x.kind) is true\n",
        "// constraint: &(s, e) in ascii_class(&x.kind) is false\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "test input ranges: \nast::ClassSetItem::Ascii with kind = ClassAsciiKind::Alnum, negated = false and ascii_class() returning valid ranges; \nast::ClassSetItem::Ascii with kind = ClassAsciiKind::Alpha, negated = false and ascii_class() returning valid ranges; \nast::ClassSetItem::Ascii with kind = ClassAsciiKind::Space, negated = false and ascii_class() returning valid ranges; \nself.flags().unicode() = true; \nvalid HirFrame states on self.pop() so no panic occurs.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                "        span: Span { start: Position(0), end: Position(1) },",
                "        kind: ast::ClassAsciiKind::Alnum,",
                "        negated: false,",
                "    });",
                "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Alnum,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let class_frame = translator.pop().unwrap();",
                  "    let class_unicode = class_frame.unwrap_class_unicode();",
                  "    assert_eq!(class_unicode.ranges().len(), expected_length);"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Alnum,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let class_frame = translator.pop().unwrap();",
                  "    let class_unicode = class_frame.unwrap_class_unicode();",
                  "    for &(s, e) in ascii_class(&ast_item.kind) {",
                  "    assert!(class_unicode.ranges().iter().any(|r| r.start() == s && r.end() == e));"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Alnum,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let class_frame = translator.pop().unwrap();",
                  "    let class_unicode = class_frame.unwrap_class_unicode();",
                  "    for &(s, e) in ascii_class(&ast_item.kind) {",
                  "    }",
                  "    assert!(class_unicode.iter().any(|r| r.start() == expected_start && r.end() == expected_end));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::ClassAsciiKind::Alnum,",
                  "        negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Alnum,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let class_frame = translator.pop().unwrap();",
                  "    let class_unicode = class_frame.unwrap_class_unicode();",
                  "    assert_eq!(class_unicode.ranges().len(), expected_length);",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::ClassAsciiKind::Alnum,",
                  "        negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Alnum,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let class_frame = translator.pop().unwrap();",
                  "    let class_unicode = class_frame.unwrap_class_unicode();",
                  "    for &(s, e) in ascii_class(&ast_item.kind) {",
                  "    assert!(class_unicode.ranges().iter().any(|r| r.start() == s && r.end() == e));",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::ClassAsciiKind::Alnum,",
                  "        negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Alnum,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let class_frame = translator.pop().unwrap();",
                  "    let class_unicode = class_frame.unwrap_class_unicode();",
                  "    for &(s, e) in ascii_class(&ast_item.kind) {",
                  "    }",
                  "    assert!(class_unicode.iter().any(|r| r.start() == expected_start && r.end() == expected_end));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2541:57\n     |\n2541 |         stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),\n     |                                                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2552:53\n     |\n2552 |     stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),\n     |                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0425]: cannot find value `expected_length` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:46\n     |\n2564 |     assert_eq!(class_unicode.ranges().len(), expected_length);\n     |                                              ^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:29\n     |\n2546 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:47\n     |\n2546 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2550 |     translator.visit_class_set_item_post(&ast_item).unwrap();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:25\n     |\n2557 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:43\n     |\n2557 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2561:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2561 |     translator.visit_class_set_item_post(&ast_item).unwrap();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2562:34\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2562 |     let class_frame = translator.pop().unwrap();\n     |                                  ^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2567:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2567 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2541:57\n     |\n2541 |         stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),\n     |                                                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2552:53\n     |\n2552 |     stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),\n     |                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0425]: cannot find value `expected_start` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:55\n     |\n2566 |     assert!(class_unicode.iter().any(|r| r.start() == expected_start && r.end() == expected_end));\n     |                                                       ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `expected_end` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:84\n     |\n2566 |     assert!(class_unicode.iter().any(|r| r.start() == expected_start && r.end() == expected_end));\n     |                                                                                    ^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:29\n     |\n2546 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:47\n     |\n2546 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2550 |     translator.visit_class_set_item_post(&ast_item).unwrap();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:25\n     |\n2557 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:43\n     |\n2557 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2561:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2561 |     translator.visit_class_set_item_post(&ast_item).unwrap();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2562:34\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2562 |     let class_frame = translator.pop().unwrap();\n     |                                  ^^^ method not found in `Translator`\n\nerror[E0609]: no field `kind` on type `ClassSetItem`\n    --> regex-syntax/src/hir/translate.rs:2564:42\n     |\n2564 |     for &(s, e) in ascii_class(&ast_item.kind) {\n     |                                          ^^^^ unknown field\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599, E0609.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                "        span: Span { start: Position(0), end: Position(1) },",
                "        kind: ast::ClassAsciiKind::Alpha,",
                "        negated: false,",
                "    });",
                "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let stack = translator.stack.borrow();",
                  "    assert_eq!(stack.len(), 1);"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let stack = translator.stack.borrow();",
                  "    let frame = stack.last().unwrap();",
                  "    if let HirFrame::ClassUnicode(cls) = frame {",
                  "    assert!(!cls.is_empty());"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let stack = translator.stack.borrow();",
                  "    let frame = stack.last().unwrap();",
                  "    if let HirFrame::ClassUnicode(cls) = frame {",
                  "    let ranges = cls.ranges();",
                  "    assert_eq!(ranges.len(), 2); // Assuming 'A-Z' and 'a-z' in ASCII Alpha"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let stack = translator.stack.borrow();",
                  "    let frame = stack.last().unwrap();",
                  "    if let HirFrame::ClassUnicode(cls) = frame {",
                  "    let ranges = cls.ranges();",
                  "    assert_eq!(ranges[0].start(), 'A');"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let stack = translator.stack.borrow();",
                  "    let frame = stack.last().unwrap();",
                  "    if let HirFrame::ClassUnicode(cls) = frame {",
                  "    let ranges = cls.ranges();",
                  "    assert_eq!(ranges[0].end(), 'Z');"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let stack = translator.stack.borrow();",
                  "    let frame = stack.last().unwrap();",
                  "    if let HirFrame::ClassUnicode(cls) = frame {",
                  "    let ranges = cls.ranges();",
                  "    assert_eq!(ranges[1].start(), 'a');"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let stack = translator.stack.borrow();",
                  "    let frame = stack.last().unwrap();",
                  "    if let HirFrame::ClassUnicode(cls) = frame {",
                  "    let ranges = cls.ranges();",
                  "    assert_eq!(ranges[1].end(), 'z');"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::ClassAsciiKind::Alpha,",
                  "        negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let stack = translator.stack.borrow();",
                  "    assert_eq!(stack.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::ClassAsciiKind::Alpha,",
                  "        negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let stack = translator.stack.borrow();",
                  "    let frame = stack.last().unwrap();",
                  "    if let HirFrame::ClassUnicode(cls) = frame {",
                  "    assert!(!cls.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::ClassAsciiKind::Alpha,",
                  "        negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let stack = translator.stack.borrow();",
                  "    let frame = stack.last().unwrap();",
                  "    if let HirFrame::ClassUnicode(cls) = frame {",
                  "    let ranges = cls.ranges();",
                  "    assert_eq!(ranges.len(), 2); // Assuming 'A-Z' and 'a-z' in ASCII Alpha",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::ClassAsciiKind::Alpha,",
                  "        negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let stack = translator.stack.borrow();",
                  "    let frame = stack.last().unwrap();",
                  "    if let HirFrame::ClassUnicode(cls) = frame {",
                  "    let ranges = cls.ranges();",
                  "    assert_eq!(ranges[0].start(), 'A');",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::ClassAsciiKind::Alpha,",
                  "        negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let stack = translator.stack.borrow();",
                  "    let frame = stack.last().unwrap();",
                  "    if let HirFrame::ClassUnicode(cls) = frame {",
                  "    let ranges = cls.ranges();",
                  "    assert_eq!(ranges[0].end(), 'Z');",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::ClassAsciiKind::Alpha,",
                  "        negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let stack = translator.stack.borrow();",
                  "    let frame = stack.last().unwrap();",
                  "    if let HirFrame::ClassUnicode(cls) = frame {",
                  "    let ranges = cls.ranges();",
                  "    assert_eq!(ranges[1].start(), 'a');",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::ClassAsciiKind::Alpha,",
                  "        negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let stack = translator.stack.borrow();",
                  "    let frame = stack.last().unwrap();",
                  "    if let HirFrame::ClassUnicode(cls) = frame {",
                  "    let ranges = cls.ranges();",
                  "    assert_eq!(ranges[1].end(), 'z');",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2541:57\n     |\n2541 |         stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),\n     |                                                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2552:53\n     |\n2552 |     stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),\n     |                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:29\n     |\n2546 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:47\n     |\n2546 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2550 |     translator.visit_class_set_item_post(&ast_item).unwrap();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:25\n     |\n2557 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:43\n     |\n2557 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2561:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2561 |     translator.visit_class_set_item_post(&ast_item).unwrap();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2567:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2567 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2568:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2568 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2568:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2568 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2568:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2568 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2568:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2568 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2568:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2568 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                "        span: Span { start: Position(0), end: Position(1) },",
                "        kind: ast::ClassAsciiKind::Space,",
                "        negated: false,",
                "    });",
                "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Space,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let stack_length = translator.stack.borrow().len();",
                  "    assert_eq!(stack_length, 2);"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Space,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let stack_length = translator.stack.borrow().len();",
                  "    let frame = translator.stack.borrow().last().unwrap();",
                  "    if let HirFrame::ClassUnicode(cls) = frame {",
                  "    let ranges = cls.ranges();",
                  "    assert_eq!(ranges.len(), 2);"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Space,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let stack_length = translator.stack.borrow().len();",
                  "    let frame = translator.stack.borrow().last().unwrap();",
                  "    if let HirFrame::ClassUnicode(cls) = frame {",
                  "    let ranges = cls.ranges();",
                  "    assert_eq!(ranges[0].start(), ' '); // Space character"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Space,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let stack_length = translator.stack.borrow().len();",
                  "    let frame = translator.stack.borrow().last().unwrap();",
                  "    if let HirFrame::ClassUnicode(cls) = frame {",
                  "    let ranges = cls.ranges();",
                  "    assert_eq!(ranges[0].end(), ' ');   // Space character"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::ClassAsciiKind::Space,",
                  "        negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Space,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let stack_length = translator.stack.borrow().len();",
                  "    assert_eq!(stack_length, 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::ClassAsciiKind::Space,",
                  "        negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Space,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let stack_length = translator.stack.borrow().len();",
                  "    let frame = translator.stack.borrow().last().unwrap();",
                  "    if let HirFrame::ClassUnicode(cls) = frame {",
                  "    let ranges = cls.ranges();",
                  "    assert_eq!(ranges.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::ClassAsciiKind::Space,",
                  "        negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Space,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let stack_length = translator.stack.borrow().len();",
                  "    let frame = translator.stack.borrow().last().unwrap();",
                  "    if let HirFrame::ClassUnicode(cls) = frame {",
                  "    let ranges = cls.ranges();",
                  "    assert_eq!(ranges[0].start(), ' '); // Space character",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::ClassAsciiKind::Space,",
                  "        negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let ast_item = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::ClassAsciiKind::Space,",
                  "    negated: false,",
                  "    });",
                  "    translator.visit_class_set_item_post(&ast_item).unwrap();",
                  "    let stack_length = translator.stack.borrow().len();",
                  "    let frame = translator.stack.borrow().last().unwrap();",
                  "    if let HirFrame::ClassUnicode(cls) = frame {",
                  "    let ranges = cls.ranges();",
                  "    assert_eq!(ranges[0].end(), ' ');   // Space character",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2541:57\n     |\n2541 |         stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),\n     |                                                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2552:53\n     |\n2552 |     stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),\n     |                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:29\n     |\n2546 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:47\n     |\n2546 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2550:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2550 |     translator.visit_class_set_item_post(&ast_item).unwrap();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:25\n     |\n2557 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2557:43\n     |\n2557 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2561:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2561 |     translator.visit_class_set_item_post(&ast_item).unwrap();\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2568:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2568 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2568:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2568 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2568:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2568 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 10,
      "prompt_conds": [
        "// constraint: *ast matches ast::ClassSetItem::Ascii(ref x) is true\n",
        "// constraint: *ast matches ast::ClassSetItem::Ascii(ref x) is true\n",
        "// constraint: self.flags().unicode() is true\n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: &(s, e) in ascii_class(&x.kind) is false\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "0 <= s < 128, 0 <= e < 128, x.kind in {Alnum, Alpha, Ascii, Blank, Cntrl, Digit, Graph, Lower, Print, Punct, Space, Upper, Word, Xdigit}, negated = false, self.flags().unicode() = true, self.pop().unwrap().unwrap_class_unicode() is valid\n",
      "answers": [
        {
          "uses": [
            "use hir::ClassUnicodeRange;",
            "use ast;",
            "use ast::ClassSetItem;",
            "use ast::ClassAsciiKind;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{self, ClassAsciiKind, ClassSetItem};",
                "    use hir::ClassUnicodeRange;",
                "",
                "    let span = Span { start: Position::default(), end: Position::default() };",
                "    let pattern = \"a\";",
                "    ",
                "    let flags = Flags {",
                "        unicode: Some(true),",
                "        ..Flags::default()",
                "    };",
                "    ",
                "    let mut trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let mut cls_unicode = ClassUnicode::empty();",
                "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                "",
                "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                "        span,",
                "        kind: ClassAsciiKind::Alnum,",
                "        negated: false,",
                "    });",
                "",
                "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                "    translator_i.visit_class_set_item_post(&x).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \"a\";",
                  "    let flags = Flags { unicode: Some(true), ..Flags::default() };",
                  "    let mut trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(flags), allow_invalid_utf8: false };",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii { span, kind: ClassAsciiKind::Alnum, negated: false });",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_i.visit_class_set_item_post(&x);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \"a\";",
                  "    let flags = Flags { unicode: Some(true), ..Flags::default() };",
                  "    let mut trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(flags), allow_invalid_utf8: false };",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii { span, kind: ClassAsciiKind::Alnum, negated: false });",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_i.visit_class_set_item_post(&x);",
                  "    let frame = trans.stack.borrow_mut().pop().unwrap();",
                  "    if let HirFrame::ClassUnicode(cls) = frame {",
                  "    assert_eq!(cls.ranges().len(), 3);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{self, ClassAsciiKind, ClassSetItem};",
                  "    use hir::ClassUnicodeRange;",
                  "",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \"a\";",
                  "    ",
                  "    let flags = Flags {",
                  "        unicode: Some(true),",
                  "        ..Flags::default()",
                  "    };",
                  "    ",
                  "    let mut trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span,",
                  "        kind: ClassAsciiKind::Alnum,",
                  "        negated: false,",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    translator_i.visit_class_set_item_post(&x).unwrap();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \"a\";",
                  "    let flags = Flags { unicode: Some(true), ..Flags::default() };",
                  "    let mut trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(flags), allow_invalid_utf8: false };",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii { span, kind: ClassAsciiKind::Alnum, negated: false });",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_i.visit_class_set_item_post(&x);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{self, ClassAsciiKind, ClassSetItem};",
                  "    use hir::ClassUnicodeRange;",
                  "",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \"a\";",
                  "    ",
                  "    let flags = Flags {",
                  "        unicode: Some(true),",
                  "        ..Flags::default()",
                  "    };",
                  "    ",
                  "    let mut trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span,",
                  "        kind: ClassAsciiKind::Alnum,",
                  "        negated: false,",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    translator_i.visit_class_set_item_post(&x).unwrap();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \"a\";",
                  "    let flags = Flags { unicode: Some(true), ..Flags::default() };",
                  "    let mut trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(flags), allow_invalid_utf8: false };",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii { span, kind: ClassAsciiKind::Alnum, negated: false });",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_i.visit_class_set_item_post(&x);",
                  "    let frame = trans.stack.borrow_mut().pop().unwrap();",
                  "    if let HirFrame::ClassUnicode(cls) = frame {",
                  "    assert_eq!(cls.ranges().len(), 3);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2543:30\n     |\n2543 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2543:56\n     |\n2543 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2557:27\n     |\n2557 |     let mut cls_unicode = ClassUnicode::empty();\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2568:30\n     |\n2568 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2568:56\n     |\n2568 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2572:27\n     |\n2572 |     let mut cls_unicode = ClassUnicode::empty();\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `hir::ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2541:9\n     |\n2541 |     use hir::ClassUnicodeRange;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2581:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2581 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{self, ClassAsciiKind, ClassSetItem};",
                "    use hir::ClassUnicodeRange;",
                "",
                "    let span = Span { start: Position::default(), end: Position::default() };",
                "    let pattern = \"z\";",
                "",
                "    let flags = Flags {",
                "        unicode: Some(true),",
                "        ..Flags::default()",
                "    };",
                "",
                "    let mut trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let mut cls_unicode = ClassUnicode::empty();",
                "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                "",
                "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                "        span,",
                "        kind: ClassAsciiKind::Upper,",
                "        negated: false,",
                "    });",
                "",
                "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                "    translator_i.visit_class_set_item_post(&x).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \"z\";",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    ..Flags::default()",
                  "    };",
                  "    let mut trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span,",
                  "    kind: ClassAsciiKind::Upper,",
                  "    negated: false,",
                  "    });",
                  "    assert!(matches!(trans.stack.borrow().last(), Some(HirFrame::ClassUnicode(_))));"
                ],
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \"z\";",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    ..Flags::default()",
                  "    };",
                  "    let mut trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span,",
                  "    kind: ClassAsciiKind::Upper,",
                  "    negated: false,",
                  "    });",
                  "    assert!(translator_i.visit_class_set_item_post(&x).is_ok());"
                ],
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \"z\";",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    ..Flags::default()",
                  "    };",
                  "    let mut trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span,",
                  "    kind: ClassAsciiKind::Upper,",
                  "    negated: false,",
                  "    });",
                  "    assert!(matches!(trans.stack.borrow().last(), Some(HirFrame::ClassUnicode(_))));"
                ],
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \"z\";",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    ..Flags::default()",
                  "    };",
                  "    let mut trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span,",
                  "    kind: ClassAsciiKind::Upper,",
                  "    negated: false,",
                  "    });",
                  "    let cls = if let Some(HirFrame::ClassUnicode(cls)) = trans.stack.borrow().last() {",
                  "    cls",
                  "    } else {",
                  "    panic!(\"Expected a ClassUnicode frame on the stack.\");",
                  "    };",
                  "    assert!(!cls.ranges().is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{self, ClassAsciiKind, ClassSetItem};",
                  "    use hir::ClassUnicodeRange;",
                  "",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \"z\";",
                  "",
                  "    let flags = Flags {",
                  "        unicode: Some(true),",
                  "        ..Flags::default()",
                  "    };",
                  "",
                  "    let mut trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span,",
                  "        kind: ClassAsciiKind::Upper,",
                  "        negated: false,",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    translator_i.visit_class_set_item_post(&x).unwrap();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \"z\";",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    ..Flags::default()",
                  "    };",
                  "    let mut trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span,",
                  "    kind: ClassAsciiKind::Upper,",
                  "    negated: false,",
                  "    });",
                  "    assert!(matches!(trans.stack.borrow().last(), Some(HirFrame::ClassUnicode(_))));",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{self, ClassAsciiKind, ClassSetItem};",
                  "    use hir::ClassUnicodeRange;",
                  "",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \"z\";",
                  "",
                  "    let flags = Flags {",
                  "        unicode: Some(true),",
                  "        ..Flags::default()",
                  "    };",
                  "",
                  "    let mut trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span,",
                  "        kind: ClassAsciiKind::Upper,",
                  "        negated: false,",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    translator_i.visit_class_set_item_post(&x).unwrap();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \"z\";",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    ..Flags::default()",
                  "    };",
                  "    let mut trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span,",
                  "    kind: ClassAsciiKind::Upper,",
                  "    negated: false,",
                  "    });",
                  "    assert!(translator_i.visit_class_set_item_post(&x).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{self, ClassAsciiKind, ClassSetItem};",
                  "    use hir::ClassUnicodeRange;",
                  "",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \"z\";",
                  "",
                  "    let flags = Flags {",
                  "        unicode: Some(true),",
                  "        ..Flags::default()",
                  "    };",
                  "",
                  "    let mut trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span,",
                  "        kind: ClassAsciiKind::Upper,",
                  "        negated: false,",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    translator_i.visit_class_set_item_post(&x).unwrap();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \"z\";",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    ..Flags::default()",
                  "    };",
                  "    let mut trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span,",
                  "    kind: ClassAsciiKind::Upper,",
                  "    negated: false,",
                  "    });",
                  "    assert!(matches!(trans.stack.borrow().last(), Some(HirFrame::ClassUnicode(_))));",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{self, ClassAsciiKind, ClassSetItem};",
                  "    use hir::ClassUnicodeRange;",
                  "",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \"z\";",
                  "",
                  "    let flags = Flags {",
                  "        unicode: Some(true),",
                  "        ..Flags::default()",
                  "    };",
                  "",
                  "    let mut trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span,",
                  "        kind: ClassAsciiKind::Upper,",
                  "        negated: false,",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    translator_i.visit_class_set_item_post(&x).unwrap();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \"z\";",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    ..Flags::default()",
                  "    };",
                  "    let mut trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span,",
                  "    kind: ClassAsciiKind::Upper,",
                  "    negated: false,",
                  "    });",
                  "    let cls = if let Some(HirFrame::ClassUnicode(cls)) = trans.stack.borrow().last() {",
                  "    cls",
                  "    } else {",
                  "    panic!(\"Expected a ClassUnicode frame on the stack.\");",
                  "    };",
                  "    assert!(!cls.ranges().is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2543:30\n     |\n2543 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2543:56\n     |\n2543 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2557:27\n     |\n2557 |     let mut cls_unicode = ClassUnicode::empty();\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2568:30\n     |\n2568 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2568:56\n     |\n2568 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2579:27\n     |\n2579 |     let mut cls_unicode = ClassUnicode::empty();\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `hir::ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2541:9\n     |\n2541 |     use hir::ClassUnicodeRange;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2543:30\n     |\n2543 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2543:56\n     |\n2543 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2557:27\n     |\n2557 |     let mut cls_unicode = ClassUnicode::empty();\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2568:30\n     |\n2568 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2568:56\n     |\n2568 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2579:27\n     |\n2579 |     let mut cls_unicode = ClassUnicode::empty();\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `hir::ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2541:9\n     |\n2541 |     use hir::ClassUnicodeRange;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2543:30\n     |\n2543 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2543:56\n     |\n2543 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2557:27\n     |\n2557 |     let mut cls_unicode = ClassUnicode::empty();\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2568:30\n     |\n2568 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2568:56\n     |\n2568 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2579:27\n     |\n2579 |     let mut cls_unicode = ClassUnicode::empty();\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `hir::ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2541:9\n     |\n2541 |     use hir::ClassUnicodeRange;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2543:30\n     |\n2543 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2543:56\n     |\n2543 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2557:27\n     |\n2557 |     let mut cls_unicode = ClassUnicode::empty();\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2568:30\n     |\n2568 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2568:56\n     |\n2568 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2579:27\n     |\n2579 |     let mut cls_unicode = ClassUnicode::empty();\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `hir::ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2541:9\n     |\n2541 |     use hir::ClassUnicodeRange;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{self, ClassAsciiKind, ClassSetItem};",
                "    use hir::ClassUnicodeRange;",
                "",
                "    let span = Span { start: Position::default(), end: Position::default() };",
                "    let pattern = \" \";",
                "",
                "    let flags = Flags {",
                "        unicode: Some(true),",
                "        ..Flags::default()",
                "    };",
                "",
                "    let mut trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let mut cls_unicode = ClassUnicode::empty();",
                "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                "",
                "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                "        span,",
                "        kind: ClassAsciiKind::Blank,",
                "        negated: false,",
                "    });",
                "",
                "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                "    translator_i.visit_class_set_item_post(&x).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \" \";",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    ..Flags::default()",
                  "    };",
                  "    let mut trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span,",
                  "    kind: ClassAsciiKind::Blank,",
                  "    negated: false,",
                  "    });",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    translator_i.visit_class_set_item_post(&x).unwrap();",
                  "    assert_eq!(trans.stack.borrow().len(), 1);"
                ],
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \" \";",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    ..Flags::default()",
                  "    };",
                  "    let mut trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span,",
                  "    kind: ClassAsciiKind::Blank,",
                  "    negated: false,",
                  "    });",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    translator_i.visit_class_set_item_post(&x).unwrap();",
                  "    assert!(matches!(trans.stack.borrow().last(), Some(HirFrame::ClassUnicode(_))));"
                ],
                [
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \" \";",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    ..Flags::default()",
                  "    };",
                  "    let mut trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span,",
                  "    kind: ClassAsciiKind::Blank,",
                  "    negated: false,",
                  "    });",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    translator_i.visit_class_set_item_post(&x).unwrap();",
                  "    assert!(cls_unicode.ranges().is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{self, ClassAsciiKind, ClassSetItem};",
                  "    use hir::ClassUnicodeRange;",
                  "",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \" \";",
                  "",
                  "    let flags = Flags {",
                  "        unicode: Some(true),",
                  "        ..Flags::default()",
                  "    };",
                  "",
                  "    let mut trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span,",
                  "        kind: ClassAsciiKind::Blank,",
                  "        negated: false,",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    translator_i.visit_class_set_item_post(&x).unwrap();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \" \";",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    ..Flags::default()",
                  "    };",
                  "    let mut trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span,",
                  "    kind: ClassAsciiKind::Blank,",
                  "    negated: false,",
                  "    });",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    translator_i.visit_class_set_item_post(&x).unwrap();",
                  "    assert_eq!(trans.stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{self, ClassAsciiKind, ClassSetItem};",
                  "    use hir::ClassUnicodeRange;",
                  "",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \" \";",
                  "",
                  "    let flags = Flags {",
                  "        unicode: Some(true),",
                  "        ..Flags::default()",
                  "    };",
                  "",
                  "    let mut trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span,",
                  "        kind: ClassAsciiKind::Blank,",
                  "        negated: false,",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    translator_i.visit_class_set_item_post(&x).unwrap();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \" \";",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    ..Flags::default()",
                  "    };",
                  "    let mut trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span,",
                  "    kind: ClassAsciiKind::Blank,",
                  "    negated: false,",
                  "    });",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    translator_i.visit_class_set_item_post(&x).unwrap();",
                  "    assert!(matches!(trans.stack.borrow().last(), Some(HirFrame::ClassUnicode(_))));",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{self, ClassAsciiKind, ClassSetItem};",
                  "    use hir::ClassUnicodeRange;",
                  "",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \" \";",
                  "",
                  "    let flags = Flags {",
                  "        unicode: Some(true),",
                  "        ..Flags::default()",
                  "    };",
                  "",
                  "    let mut trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span,",
                  "        kind: ClassAsciiKind::Blank,",
                  "        negated: false,",
                  "    });",
                  "",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    translator_i.visit_class_set_item_post(&x).unwrap();",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let pattern = \" \";",
                  "    let flags = Flags {",
                  "    unicode: Some(true),",
                  "    ..Flags::default()",
                  "    };",
                  "    let mut trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut cls_unicode = ClassUnicode::empty();",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassUnicode(cls_unicode));",
                  "    let x = ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span,",
                  "    kind: ClassAsciiKind::Blank,",
                  "    negated: false,",
                  "    });",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    translator_i.visit_class_set_item_post(&x).unwrap();",
                  "    assert!(cls_unicode.ranges().is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2543:30\n     |\n2543 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2543:56\n     |\n2543 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2557:27\n     |\n2557 |     let mut cls_unicode = ClassUnicode::empty();\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2568:30\n     |\n2568 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2568:56\n     |\n2568 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2579:27\n     |\n2579 |     let mut cls_unicode = ClassUnicode::empty();\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `hir::ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2541:9\n     |\n2541 |     use hir::ClassUnicodeRange;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2543:30\n     |\n2543 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2543:56\n     |\n2543 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2557:27\n     |\n2557 |     let mut cls_unicode = ClassUnicode::empty();\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2568:30\n     |\n2568 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2568:56\n     |\n2568 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2579:27\n     |\n2579 |     let mut cls_unicode = ClassUnicode::empty();\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `hir::ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2541:9\n     |\n2541 |     use hir::ClassUnicodeRange;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2543:30\n     |\n2543 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2543:56\n     |\n2543 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2557:27\n     |\n2557 |     let mut cls_unicode = ClassUnicode::empty();\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2568:30\n     |\n2568 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2568:56\n     |\n2568 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2579:27\n     |\n2579 |     let mut cls_unicode = ClassUnicode::empty();\n     |                           ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `hir::ClassUnicodeRange`\n    --> regex-syntax/src/hir/translate.rs:2541:9\n     |\n2541 |     use hir::ClassUnicodeRange;\n     |         ^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 12,
      "prompt_conds": [
        "// constraint: *ast matches ast::ClassSetItem::Ascii(ref x) is true\n",
        "// constraint: *ast matches ast::ClassSetItem::Ascii(ref x) is true\n",
        "// constraint: self.flags().unicode() is false\n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: &(s, e) in ascii_class(&x.kind) is true\n",
        "// constraint: &(s, e) in ascii_class(&x.kind) is false\n",
        "// constraint: self.bytes_fold_and_negate(\n                        &x.span, x.negated, &mut cls)? is Ok/Some\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "input: ast::ClassSetItem::Ascii(ref x) where x.kind is ClassAsciiKind::Word, x.negated is false, x.span is Span { start: Position(0), end: Position(10) } and self.pop().unwrap() returns a valid ClassBytes; input range: ClassAsciiKind::Alpha, ClassAsciiKind::Digit, ClassAsciiKind::Lower, ClassAsciiKind::Upper, and ClassAsciiKind::Space.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator::default();",
                "    let pattern = \"test\";",
                "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                "        span: Span { start: Position(0), end: Position(10) },",
                "        kind: ast::ClassAsciiKind::Word,",
                "        negated: false,",
                "    });",
                "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Word,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    assert!(frame.unwrap_class_bytes().ranges().is_empty());"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Word,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let expected_range = (b'0', b'9');",
                  "    let cls = frame.unwrap_class_bytes();",
                  "    assert!(cls.iter().any(|range| range.start() == expected_range.0 && range.end() == expected_range.1));"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Word,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let expected_range = (b'0', b'9');",
                  "    let cls = frame.unwrap_class_bytes();",
                  "    assert!(translator_i.visit_class_set_item_post(&ast).is_ok());"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Word,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let expected_range = (b'0', b'9');",
                  "    let cls = frame.unwrap_class_bytes();",
                  "    assert_eq!(translator_i.pop().unwrap().unwrap_class_bytes().ranges().len(), 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Word,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Word,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    assert!(frame.unwrap_class_bytes().ranges().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Word,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Word,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let expected_range = (b'0', b'9');",
                  "    let cls = frame.unwrap_class_bytes();",
                  "    assert!(cls.iter().any(|range| range.start() == expected_range.0 && range.end() == expected_range.1));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Word,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Word,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let expected_range = (b'0', b'9');",
                  "    let cls = frame.unwrap_class_bytes();",
                  "    assert!(translator_i.visit_class_set_item_post(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Word,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Word,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let expected_range = (b'0', b'9');",
                  "    let cls = frame.unwrap_class_bytes();",
                  "    assert_eq!(translator_i.pop().unwrap().unwrap_class_bytes().ranges().len(), 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:44\n     |\n2560 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:25\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:43\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:44\n     |\n2560 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:25\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:43\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:44\n     |\n2560 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:25\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:43\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:44\n     |\n2560 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:25\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:43\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator::default();",
                "    let pattern = \"test\";",
                "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                "        span: Span { start: Position(0), end: Position(10) },",
                "        kind: ast::ClassAsciiKind::Alpha,",
                "        negated: false,",
                "    });",
                "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator = Translator::default();",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test\");",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    assert_eq!(translator_i.flags().unicode(), false);"
                ],
                [
                  "    let mut translator = Translator::default();",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test\");",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    assert!(translator_i.pop().is_some());"
                ],
                [
                  "    let mut translator = Translator::default();",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test\");",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    let cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(cls.ranges().len() > 0);"
                ],
                [
                  "    let mut translator = Translator::default();",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test\");",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    let cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(cls.ranges().iter().all(|range| range.start() as char >= 'A' && range.end() as char <= 'Z' || range.start() as char >= 'a' && range.end() as char <= 'z'));"
                ],
                [
                  "    let mut translator = Translator::default();",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test\");",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    let cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(translator_i.bytes_fold_and_negate(&ast.span, ast.negated, &mut cls).is_ok());"
                ],
                [
                  "    let mut translator = Translator::default();",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test\");",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    let cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(translator_i.visit_class_set_item_post(&ast).is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Alpha,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut translator = Translator::default();",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test\");",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    assert_eq!(translator_i.flags().unicode(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Alpha,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut translator = Translator::default();",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test\");",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    assert!(translator_i.pop().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Alpha,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut translator = Translator::default();",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test\");",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    let cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(cls.ranges().len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Alpha,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut translator = Translator::default();",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test\");",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    let cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(cls.ranges().iter().all(|range| range.start() as char >= 'A' && range.end() as char <= 'Z' || range.start() as char >= 'a' && range.end() as char <= 'z'));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Alpha,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut translator = Translator::default();",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test\");",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    let cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(translator_i.bytes_fold_and_negate(&ast.span, ast.negated, &mut cls).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Alpha,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut translator = Translator::default();",
                  "    let mut translator_i = TranslatorI::new(&translator, \"test\");",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Alpha,",
                  "    negated: false,",
                  "    });",
                  "    let cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(translator_i.visit_class_set_item_post(&ast).is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:25\n     |\n2554 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:43\n     |\n2554 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:25\n     |\n2554 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:43\n     |\n2554 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:25\n     |\n2554 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:43\n     |\n2554 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:25\n     |\n2554 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:43\n     |\n2554 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:25\n     |\n2554 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:43\n     |\n2554 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0609]: no field `span` on type `ClassSetItem`\n    --> regex-syntax/src/hir/translate.rs:2559:53\n     |\n2559 |     assert!(translator_i.bytes_fold_and_negate(&ast.span, ast.negated, &mut cls).is_ok());\n     |                                                     ^^^^ unknown field\n\nerror[E0609]: no field `negated` on type `ClassSetItem`\n    --> regex-syntax/src/hir/translate.rs:2559:63\n     |\n2559 |     assert!(translator_i.bytes_fold_and_negate(&ast.span, ast.negated, &mut cls).is_ok());\n     |                                                               ^^^^^^^ unknown field\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599, E0609.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:38\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let mut translator = Translator::default();\n     |                                      ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:25\n     |\n2554 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:43\n     |\n2554 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator::default();",
                "    let pattern = \"test\";",
                "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                "        span: Span { start: Position(0), end: Position(10) },",
                "        kind: ast::ClassAsciiKind::Digit,",
                "        negated: false,",
                "    });",
                "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Digit,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    assert!(matches!(frame, HirFrame::ClassBytes(_)));"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Digit,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let cls = frame.unwrap_class_bytes();",
                  "    assert!(!cls.is_all_ascii());"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Digit,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let cls = frame.unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges().len(), 1);"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Digit,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let cls = frame.unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges()[0].start(), b'0');"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Digit,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let cls = frame.unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges()[0].end(), b'9');"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Digit,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Digit,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    assert!(matches!(frame, HirFrame::ClassBytes(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Digit,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Digit,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let cls = frame.unwrap_class_bytes();",
                  "    assert!(!cls.is_all_ascii());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Digit,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Digit,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let cls = frame.unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Digit,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Digit,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let cls = frame.unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges()[0].start(), b'0');",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Digit,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Digit,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let cls = frame.unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges()[0].end(), b'9');",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:44\n     |\n2560 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:25\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:43\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:44\n     |\n2560 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:25\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:43\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:44\n     |\n2560 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:25\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:43\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:44\n     |\n2560 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:25\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:43\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:44\n     |\n2560 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:25\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:43\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator::default();",
                "    let pattern = \"test\";",
                "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                "        span: Span { start: Position(0), end: Position(10) },",
                "        kind: ast::ClassAsciiKind::Lower,",
                "        negated: false,",
                "    });",
                "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    let expected_range = hir::ClassBytesRange::new(b'a', b'z');",
                  "    assert_eq!(cls.ranges(), &[expected_range]);"
                ],
                [
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    let expected_range = hir::ClassBytesRange::new(b'a', b'z');",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(!cls.is_all_ascii());"
                ],
                [
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    let expected_range = hir::ClassBytesRange::new(b'a', b'z');",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(translator_i.trans().flags.get().unicode().is_false());"
                ],
                [
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    let expected_range = hir::ClassBytesRange::new(b'a', b'z');",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges().len(), 1);"
                ],
                [
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    let expected_range = hir::ClassBytesRange::new(b'a', b'z');",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(translator_i.visit_class_set_item_post(&ast).is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Lower,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    let expected_range = hir::ClassBytesRange::new(b'a', b'z');",
                  "    assert_eq!(cls.ranges(), &[expected_range]);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Lower,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    let expected_range = hir::ClassBytesRange::new(b'a', b'z');",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(!cls.is_all_ascii());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Lower,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    let expected_range = hir::ClassBytesRange::new(b'a', b'z');",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(translator_i.trans().flags.get().unicode().is_false());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Lower,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    let expected_range = hir::ClassBytesRange::new(b'a', b'z');",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Lower,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    let expected_range = hir::ClassBytesRange::new(b'a', b'z');",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(translator_i.visit_class_set_item_post(&ast).is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `is_false` found for type `bool` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:56\n     |\n2554 |     assert!(translator_i.trans().flags.get().unicode().is_false());\n     |                                                        ^^^^^^^^ method not found in `bool`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator::default();",
                "    let pattern = \"test\";",
                "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                "        span: Span { start: Position(0), end: Position(10) },",
                "        kind: ast::ClassAsciiKind::Upper,",
                "        negated: false,",
                "    });",
                "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Upper,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    assert!(matches!(frame, HirFrame::ClassBytes(_)));"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Upper,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let cls_bytes = frame.unwrap_class_bytes();",
                  "    assert!(cls_bytes.ranges().is_empty());"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Upper,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let cls_bytes = frame.unwrap_class_bytes();",
                  "    assert_eq!(cls_bytes.is_all_ascii(), true);"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Upper,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let cls_bytes = frame.unwrap_class_bytes();",
                  "    assert!(translator_i.visit_class_set_item_post(&ast).is_ok());"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Upper,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let cls_bytes = frame.unwrap_class_bytes();",
                  "    let frame_after = translator_i.pop().unwrap();",
                  "    assert!(matches!(frame_after, HirFrame::ClassBytes(_)));"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Upper,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let cls_bytes = frame.unwrap_class_bytes();",
                  "    let frame_after = translator_i.pop().unwrap();",
                  "    let new_cls_bytes = frame_after.unwrap_class_bytes();",
                  "    assert!(new_cls_bytes.ranges().len() > 0);"
                ],
                [
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Upper,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let cls_bytes = frame.unwrap_class_bytes();",
                  "    let frame_after = translator_i.pop().unwrap();",
                  "    let new_cls_bytes = frame_after.unwrap_class_bytes();",
                  "    assert_eq!(new_cls_bytes.is_all_ascii(), true);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Upper,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Upper,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    assert!(matches!(frame, HirFrame::ClassBytes(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Upper,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Upper,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let cls_bytes = frame.unwrap_class_bytes();",
                  "    assert!(cls_bytes.ranges().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Upper,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Upper,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let cls_bytes = frame.unwrap_class_bytes();",
                  "    assert_eq!(cls_bytes.is_all_ascii(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Upper,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Upper,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let cls_bytes = frame.unwrap_class_bytes();",
                  "    assert!(translator_i.visit_class_set_item_post(&ast).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Upper,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Upper,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let cls_bytes = frame.unwrap_class_bytes();",
                  "    let frame_after = translator_i.pop().unwrap();",
                  "    assert!(matches!(frame_after, HirFrame::ClassBytes(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Upper,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Upper,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let cls_bytes = frame.unwrap_class_bytes();",
                  "    let frame_after = translator_i.pop().unwrap();",
                  "    let new_cls_bytes = frame_after.unwrap_class_bytes();",
                  "    assert!(new_cls_bytes.ranges().len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Upper,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "    span: Span { start: Position(0), end: Position(10) },",
                  "    kind: ast::ClassAsciiKind::Upper,",
                  "    negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let frame = translator_i.pop().unwrap();",
                  "    let cls_bytes = frame.unwrap_class_bytes();",
                  "    let frame_after = translator_i.pop().unwrap();",
                  "    let new_cls_bytes = frame_after.unwrap_class_bytes();",
                  "    assert_eq!(new_cls_bytes.is_all_ascii(), true);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:44\n     |\n2560 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:25\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:43\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:44\n     |\n2560 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:25\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:43\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:44\n     |\n2560 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:25\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:43\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:44\n     |\n2560 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:25\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:43\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:44\n     |\n2560 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:25\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:43\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:44\n     |\n2560 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:25\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:43\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2560:44\n     |\n2560 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2551 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:25\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:43\n     |\n2555 |     span: Span { start: Position(0), end: Position(10) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator::default();",
                "    let pattern = \"test\";",
                "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                "        span: Span { start: Position(0), end: Position(10) },",
                "        kind: ast::ClassAsciiKind::Space,",
                "        negated: false,",
                "    });",
                "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges().len(), expected_length);"
                ],
                [
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(cls.ranges().iter().all(|range| range.start() >= expected_start && range.end() <= expected_end));"
                ],
                [
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(cls.is_all_ascii());"
                ],
                [
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges()[0].start(), expected_start_byte);"
                ],
                [
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges()[0].end(), expected_end_byte);"
                ],
                [
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(cls.ranges().iter().any(|range| range.start() == expected_specific_start && range.end() == expected_specific_end));"
                ],
                [
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(cls.ranges().iter().any(|range| range.start() == expected_additional_start && range.end() == expected_additional_end));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Space,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges().len(), expected_length);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Space,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(cls.ranges().iter().all(|range| range.start() >= expected_start && range.end() <= expected_end));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Space,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(cls.is_all_ascii());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Space,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges()[0].start(), expected_start_byte);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Space,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges()[0].end(), expected_end_byte);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Space,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(cls.ranges().iter().any(|range| range.start() == expected_specific_start && range.end() == expected_specific_end));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator::default();",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&translator, pattern);",
                  "    let ast = ast::ClassSetItem::Ascii(ast::ClassAscii {",
                  "        span: Span { start: Position(0), end: Position(10) },",
                  "        kind: ast::ClassAsciiKind::Space,",
                  "        negated: false,",
                  "    });",
                  "    translator_i.trans().flags.set(Flags { unicode: Some(false), ..Default::default() });",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_i.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(cls.ranges().iter().any(|range| range.start() == expected_additional_start && range.end() == expected_additional_end));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0425]: cannot find value `expected_length` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:36\n     |\n2552 |     assert_eq!(cls.ranges().len(), expected_length);\n     |                                    ^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0425]: cannot find value `expected_start` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:62\n     |\n2552 |     assert!(cls.ranges().iter().all(|range| range.start() >= expected_start && range.end() <= expected_end));\n     |                                                              ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `expected_end` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:95\n     |\n2552 |     assert!(cls.ranges().iter().all(|range| range.start() >= expected_start && range.end() <= expected_end));\n     |                                                                                               ^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0425]: cannot find value `expected_start_byte` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:41\n     |\n2552 |     assert_eq!(cls.ranges()[0].start(), expected_start_byte);\n     |                                         ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0425]: cannot find value `expected_end_byte` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:39\n     |\n2552 |     assert_eq!(cls.ranges()[0].end(), expected_end_byte);\n     |                                       ^^^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0425]: cannot find value `expected_specific_start` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:62\n     |\n2552 |     assert!(cls.ranges().iter().any(|range| range.start() == expected_specific_start && range.end() == expected_specific_end));\n     |                                                              ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `expected_specific_end` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:104\n     |\n2552 |     assert!(cls.ranges().iter().any(|range| range.start() == expected_specific_start && range.end() == expected_specific_end));\n     |                                                                                                        ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2549:44\n     |\n2549 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0425]: cannot find value `expected_additional_start` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:62\n     |\n2552 |     assert!(cls.ranges().iter().any(|range| range.start() == expected_additional_start && range.end() == expected_additional_end));\n     |                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `expected_additional_end` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:106\n     |\n2552 |     assert!(cls.ranges().iter().any(|range| range.start() == expected_additional_start && range.end() == expected_additional_end));\n     |                                                                                                          ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no function or associated item named `default` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2540:34\n     |\n118  | pub struct Translator {\n     | --------------------- function or associated item `default` not found for this struct\n...\n2540 |     let translator = Translator::default();\n     |                                  ^^^^^^^ function or associated item not found in `Translator`\n     |\nnote: if you're trying to build a new `translate::Translator`, consider using `translate::Translator::new` which returns `translate::Translator`\n    --> regex-syntax/src/hir/translate.rs:129:5\n     |\n129  |     pub fn new() -> Translator {\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `default`, perhaps you need to implement it:\n             candidate #1: `Default`\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:29\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2544:47\n     |\n2544 |         span: Span { start: Position(0), end: Position(10) },\n     |                                               ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 13,
      "prompt_conds": [
        "// constraint: *ast matches ast::ClassSetItem::Ascii(ref x) is true\n",
        "// constraint: *ast matches ast::ClassSetItem::Ascii(ref x) is true\n",
        "// constraint: self.flags().unicode() is false\n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: &(s, e) in ascii_class(&x.kind) is false\n",
        "// constraint: self.bytes_fold_and_negate(\n                        &x.span, x.negated, &mut cls)? is Err/None\n"
      ],
      "input_infer": "test input ranges: self.flags().unicode() = false, self.pop().unwrap() = valid ClassBytes instance, ascii_class(&x.kind) for x.kind in [Alnum, Alpha, Ascii, Blank, Cntrl, Digit, Graph, Lower, Print, Punct, Space, Upper, Word, Xdigit], negated in [true, false], x.span = valid Span instance, self.bytes_fold_and_negate returns Err/None when input is invalid or not all ASCII.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"test_pattern\";",
                "    let mut visitor = TranslatorI::new(&trans, pattern);",
                "    let span = Span { start: Position::default(), end: Position::default() };",
                "    let literal = ast::Literal { span: span.clone(), kind: ast::LiteralKind::Char, c: 'c' };",
                "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Digit, negated: true };",
                "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                "    ",
                "    visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));",
                "    visitor.visit_class_set_item_post(&class_set_item).ok();",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let literal = ast::Literal { span: span.clone(), kind: ast::LiteralKind::Char, c: 'c' };",
                  "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Digit, negated: true };",
                  "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                  "    visitor.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let literal = ast::Literal { span: span.clone(), kind: ast::LiteralKind::Char, c: 'c' };",
                  "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Digit, negated: true };",
                  "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                  "    visitor.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    assert_eq!(visitor.pop().unwrap(), HirFrame::ClassBytes(ClassBytes::empty()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let literal = ast::Literal { span: span.clone(), kind: ast::LiteralKind::Char, c: 'c' };",
                  "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Digit, negated: true };",
                  "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                  "    ",
                  "    visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    visitor.visit_class_set_item_post(&class_set_item).ok();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let literal = ast::Literal { span: span.clone(), kind: ast::LiteralKind::Char, c: 'c' };",
                  "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Digit, negated: true };",
                  "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                  "    visitor.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let literal = ast::Literal { span: span.clone(), kind: ast::LiteralKind::Char, c: 'c' };",
                  "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Digit, negated: true };",
                  "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                  "    ",
                  "    visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    visitor.visit_class_set_item_post(&class_set_item).ok();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let literal = ast::Literal { span: span.clone(), kind: ast::LiteralKind::Char, c: 'c' };",
                  "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Digit, negated: true };",
                  "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                  "    visitor.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let result = visitor.visit_class_set_item_post(&class_set_item);",
                  "    assert_eq!(visitor.pop().unwrap(), HirFrame::ClassBytes(ClassBytes::empty()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:56\n     |\n2547 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2552:45\n     |\n2552 |     visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:30\n     |\n2557 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:56\n     |\n2557 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2561:39\n     |\n2561 |     visitor.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:78\n     |\n2548 |     let literal = ast::Literal { span: span.clone(), kind: ast::LiteralKind::Char, c: 'c' };\n     |                                                                              ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0615]: attempted to take value of method `pop` on type `translate::TranslatorI<'_, '_>`\n    --> regex-syntax/src/hir/translate.rs:2552:13\n     |\n2552 |     visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));\n     |             ^^^ method, not a field\n     |\n     = help: methods are immutable and cannot be assigned to\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:78\n     |\n2558 |     let literal = ast::Literal { span: span.clone(), kind: ast::LiteralKind::Char, c: 'c' };\n     |                                                                              ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599, E0615.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:56\n     |\n2547 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2552:45\n     |\n2552 |     visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:30\n     |\n2557 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:56\n     |\n2557 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2561:39\n     |\n2561 |     visitor.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2563:61\n     |\n2563 |     assert_eq!(visitor.pop().unwrap(), HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2548:78\n     |\n2548 |     let literal = ast::Literal { span: span.clone(), kind: ast::LiteralKind::Char, c: 'c' };\n     |                                                                              ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0615]: attempted to take value of method `pop` on type `translate::TranslatorI<'_, '_>`\n    --> regex-syntax/src/hir/translate.rs:2552:13\n     |\n2552 |     visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));\n     |             ^^^ method, not a field\n     |\n     = help: methods are immutable and cannot be assigned to\n\nerror[E0599]: no variant or associated item named `Char` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:78\n     |\n2558 |     let literal = ast::Literal { span: span.clone(), kind: ast::LiteralKind::Char, c: 'c' };\n     |                                                                              ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Char` not found for this enum\n\nerror[E0369]: binary operation `==` cannot be applied to type `translate::HirFrame`\n    --> regex-syntax/src/hir/translate.rs:2563:5\n     |\n2563 |     assert_eq!(visitor.pop().unwrap(), HirFrame::ClassBytes(ClassBytes::empty()));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n     |     |\n     |     translate::HirFrame\n     |     translate::HirFrame\n     |\nnote: an implementation of `PartialEq` might be missing for `translate::HirFrame`\n    --> regex-syntax/src/hir/translate.rs:154:1\n     |\n154  | enum HirFrame {\n     | ^^^^^^^^^^^^^ must implement `PartialEq`\n     = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider annotating `translate::HirFrame` with `#[derive(PartialEq)]`\n     |\n154  + #[derive(PartialEq)]\n155  | enum HirFrame {\n     |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0369, E0432, E0433, E0599, E0615.\nFor more information about an error, try `rustc --explain E0369`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let pattern = \"test_pattern\";",
                "    let mut visitor = TranslatorI::new(&trans, pattern);",
                "    let span = Span { start: Position::default(), end: Position::default() };",
                "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Space, negated: false };",
                "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                "    ",
                "    visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));",
                "    visitor.visit_class_set_item_post(&class_set_item).ok();",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: true };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Space, negated: false };",
                  "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                  "    let popped_frame = visitor.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(popped_frame.ranges().is_empty(), true);"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: true };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Space, negated: false };",
                  "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                  "    let popped_frame = visitor.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(visitor.bytes_fold_and_negate(&span, false, &mut popped_frame).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Space, negated: false };",
                  "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                  "    ",
                  "    visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    visitor.visit_class_set_item_post(&class_set_item).ok();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: true };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Space, negated: false };",
                  "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                  "    let popped_frame = visitor.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(popped_frame.ranges().is_empty(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Space, negated: false };",
                  "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                  "    ",
                  "    visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    visitor.visit_class_set_item_post(&class_set_item).ok();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: true };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Space, negated: false };",
                  "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                  "    let popped_frame = visitor.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(visitor.bytes_fold_and_negate(&span, false, &mut popped_frame).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:56\n     |\n2547 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2551:45\n     |\n2551 |     visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2556:30\n     |\n2556 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2556:56\n     |\n2556 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0615]: attempted to take value of method `pop` on type `translate::TranslatorI<'_, '_>`\n    --> regex-syntax/src/hir/translate.rs:2551:13\n     |\n2551 |     visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));\n     |             ^^^ method, not a field\n     |\n     = help: methods are immutable and cannot be assigned to\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0615.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:56\n     |\n2547 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2551:45\n     |\n2551 |     visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2556:30\n     |\n2556 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2556:56\n     |\n2556 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0615]: attempted to take value of method `pop` on type `translate::TranslatorI<'_, '_>`\n    --> regex-syntax/src/hir/translate.rs:2551:13\n     |\n2551 |     visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));\n     |             ^^^ method, not a field\n     |\n     = help: methods are immutable and cannot be assigned to\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0615.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"test_pattern\";",
                "    let mut visitor = TranslatorI::new(&trans, pattern);",
                "    let span = Span { start: Position::default(), end: Position::default() };",
                "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Digit, negated: false };",
                "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                "    ",
                "    visitor.visit_class_set_item_post(&class_set_item).ok();",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Digit, negated: false };",
                  "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                  "    assert!(visitor.pop().is_none());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Digit, negated: false };",
                  "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                  "    assert!(self.bytes_fold_and_negate(&x.span, x.negated, &mut cls).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Digit, negated: false };",
                  "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                  "    ",
                  "    visitor.visit_class_set_item_post(&class_set_item).ok();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Digit, negated: false };",
                  "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                  "    assert!(visitor.pop().is_none());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Digit, negated: false };",
                  "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                  "    ",
                  "    visitor.visit_class_set_item_post(&class_set_item).ok();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Digit, negated: false };",
                  "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                  "    assert!(self.bytes_fold_and_negate(&x.span, x.negated, &mut cls).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2548:30\n     |\n2548 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2548:56\n     |\n2548 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2560:30\n     |\n2560 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2560:56\n     |\n2560 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2548:30\n     |\n2548 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2548:56\n     |\n2548 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2560:30\n     |\n2560 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2560:56\n     |\n2560 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0424]: expected value, found module `self`\n    --> regex-syntax/src/hir/translate.rs:2563:13\n     |\n2539 | fn test_visit_class_set_item_post_132()\n     |    ---------------------------------- this function can't have a `self` parameter\n...\n2563 |     assert!(self.bytes_fold_and_negate(&x.span, x.negated, &mut cls).is_err());\n     |             ^^^^ `self` value is a keyword only available in methods with a `self` parameter\n\nerror[E0425]: cannot find value `x` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:41\n     |\n2563 |     assert!(self.bytes_fold_and_negate(&x.span, x.negated, &mut cls).is_err());\n     |                                         ^ not found in this scope\n\nerror[E0425]: cannot find value `x` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:49\n     |\n2563 |     assert!(self.bytes_fold_and_negate(&x.span, x.negated, &mut cls).is_err());\n     |                                                 ^ not found in this scope\n\nerror[E0425]: cannot find value `cls` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:65\n     |\n2563 |     assert!(self.bytes_fold_and_negate(&x.span, x.negated, &mut cls).is_err());\n     |                                                                 ^^^ not found in this scope\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0424, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0424`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let pattern = \"test_pattern\";",
                "    let mut visitor = TranslatorI::new(&trans, pattern);",
                "    let span = Span { start: Position::default(), end: Position::default() };",
                "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Alpha, negated: false };",
                "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                "    ",
                "    visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));",
                "    visitor.visit_class_set_item_post(&class_set_item).ok();",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let class_bytes = visitor.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(class_bytes.is_empty());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let class_bytes = visitor.pop().unwrap().unwrap_class_bytes();",
                  "    let cls_range = class_bytes.ranges();",
                  "    assert_eq!(cls_range.len(), 0);"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let class_bytes = visitor.pop().unwrap().unwrap_class_bytes();",
                  "    let cls_range = class_bytes.ranges();",
                  "    assert!(cls_range.is_empty());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let class_bytes = visitor.pop().unwrap().unwrap_class_bytes();",
                  "    let cls_range = class_bytes.ranges();",
                  "    assert!(visitor.trans().stack.borrow().is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Alpha, negated: false };",
                  "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                  "    ",
                  "    visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    visitor.visit_class_set_item_post(&class_set_item).ok();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let class_bytes = visitor.pop().unwrap().unwrap_class_bytes();",
                  "    assert!(class_bytes.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Alpha, negated: false };",
                  "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                  "    ",
                  "    visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    visitor.visit_class_set_item_post(&class_set_item).ok();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let class_bytes = visitor.pop().unwrap().unwrap_class_bytes();",
                  "    let cls_range = class_bytes.ranges();",
                  "    assert_eq!(cls_range.len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Alpha, negated: false };",
                  "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                  "    ",
                  "    visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    visitor.visit_class_set_item_post(&class_set_item).ok();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let class_bytes = visitor.pop().unwrap().unwrap_class_bytes();",
                  "    let cls_range = class_bytes.ranges();",
                  "    assert!(cls_range.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"test_pattern\";",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let span = Span { start: Position::default(), end: Position::default() };",
                  "    let ascii = ast::ClassAscii { span: span.clone(), kind: ast::ClassAsciiKind::Alpha, negated: false };",
                  "    let class_set_item = ast::ClassSetItem::Ascii(ascii);",
                  "    ",
                  "    visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    visitor.visit_class_set_item_post(&class_set_item).ok();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let mut visitor = TranslatorI::new(&trans, pattern);",
                  "    let class_bytes = visitor.pop().unwrap().unwrap_class_bytes();",
                  "    let cls_range = class_bytes.ranges();",
                  "    assert!(visitor.trans().stack.borrow().is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:56\n     |\n2547 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2551:45\n     |\n2551 |     visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0615]: attempted to take value of method `pop` on type `translate::TranslatorI<'_, '_>`\n    --> regex-syntax/src/hir/translate.rs:2551:13\n     |\n2551 |     visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));\n     |             ^^^ method, not a field\n     |\n     = help: methods are immutable and cannot be assigned to\n\nerror[E0599]: no method named `is_empty` found for struct `hir::ClassBytes` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2560:25\n     |\n2560 |     assert!(class_bytes.is_empty());\n     |                         ^^^^^^^^ method not found in `ClassBytes`\n     |\n    ::: regex-syntax/src/hir/mod.rs:913:1\n     |\n913  | pub struct ClassBytes {\n     | --------------------- method `is_empty` not found for this struct\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\n     = note: the following trait defines an item `is_empty`, perhaps you need to implement it:\n             candidate #1: `ExactSizeIterator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0599, E0615.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:56\n     |\n2547 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2551:45\n     |\n2551 |     visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0615]: attempted to take value of method `pop` on type `translate::TranslatorI<'_, '_>`\n    --> regex-syntax/src/hir/translate.rs:2551:13\n     |\n2551 |     visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));\n     |             ^^^ method, not a field\n     |\n     = help: methods are immutable and cannot be assigned to\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0615.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:56\n     |\n2547 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2551:45\n     |\n2551 |     visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0615]: attempted to take value of method `pop` on type `translate::TranslatorI<'_, '_>`\n    --> regex-syntax/src/hir/translate.rs:2551:13\n     |\n2551 |     visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));\n     |             ^^^ method, not a field\n     |\n     = help: methods are immutable and cannot be assigned to\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0615.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                              ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2547:56\n     |\n2547 |     let span = Span { start: Position::default(), end: Position::default() };\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2551:45\n     |\n2551 |     visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0615]: attempted to take value of method `pop` on type `translate::TranslatorI<'_, '_>`\n    --> regex-syntax/src/hir/translate.rs:2551:13\n     |\n2551 |     visitor.pop = Some(HirFrame::ClassBytes(ClassBytes::empty()));\n     |             ^^^ method, not a field\n     |\n     = help: methods are immutable and cannot be assigned to\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0432, E0433, E0615.\nFor more information about an error, try `rustc --explain E0432`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 14,
      "prompt_conds": [
        "// constraint: *ast matches ast::ClassSetItem::Ascii(ref x) is true\n",
        "// constraint: *ast matches ast::ClassSetItem::Ascii(ref x) is true\n",
        "// constraint: self.flags().unicode() is false\n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: &(s, e) in ascii_class(&x.kind) is false\n",
        "// constraint: self.bytes_fold_and_negate(\n                        &x.span, x.negated, &mut cls)? is Ok/Some\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "0 <= x.start.c <= x.end.c <= 127, negated = false, self.pop().unwrap() is valid, x.span.start <= x.span.end <= 127, self.flags().unicode() = false\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let span = Span { start: Position(0), end: Position(1) };",
                "    let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'a' };",
                "    let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'b' };",
                "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Alnum, negated: false });",
                "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                "",
                "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                "}"
              ],
              "oracles": [
                [
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let frame = translator.stack.borrow_mut().pop().unwrap();",
                  "    assert!(matches!(frame, HirFrame::ClassBytes(_)));"
                ],
                [
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let frame = translator.stack.borrow_mut().pop().unwrap();",
                  "    let cls = frame.unwrap_class_bytes();",
                  "    assert!(cls.ranges().len() > 0);"
                ],
                [
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let frame = translator.stack.borrow_mut().pop().unwrap();",
                  "    let cls = frame.unwrap_class_bytes();",
                  "    assert!(cls.is_all_ascii());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'a' };",
                  "    let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'b' };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Alnum, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'a' };",
                  "    let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'b' };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Alnum, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let frame = translator.stack.borrow_mut().pop().unwrap();",
                  "    assert!(matches!(frame, HirFrame::ClassBytes(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'a' };",
                  "    let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'b' };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Alnum, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let frame = translator.stack.borrow_mut().pop().unwrap();",
                  "    let cls = frame.unwrap_class_bytes();",
                  "    assert!(cls.ranges().len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'a' };",
                  "    let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'b' };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Alnum, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let frame = translator.stack.borrow_mut().pop().unwrap();",
                  "    let cls = frame.unwrap_class_bytes();",
                  "    assert!(cls.is_all_ascii());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:25\n     |\n2547 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'a' };\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2547:61\n     |\n2547 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'a' };\n     |                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:23\n     |\n2548 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'b' };\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:59\n     |\n2548 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'b' };\n     |                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2550:61\n     |\n2550 |     translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:25\n     |\n2547 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'a' };\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2547:61\n     |\n2547 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'a' };\n     |                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:23\n     |\n2548 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'b' };\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:59\n     |\n2548 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'b' };\n     |                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2550:61\n     |\n2550 |     translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:25\n     |\n2547 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'a' };\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2547:61\n     |\n2547 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'a' };\n     |                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:23\n     |\n2548 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'b' };\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:59\n     |\n2548 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'b' };\n     |                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2550:61\n     |\n2550 |     translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:25\n     |\n2547 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'a' };\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2547:61\n     |\n2547 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'a' };\n     |                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:23\n     |\n2548 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'b' };\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:59\n     |\n2548 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'b' };\n     |                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2550:61\n     |\n2550 |     translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let span = Span { start: Position(0), end: Position(1) };",
                "    let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };",
                "    let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: '9' };",
                "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Digit, negated: false });",
                "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                "",
                "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                "}"
              ],
              "oracles": [
                [
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };",
                  "    let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: '9' };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Digit, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };",
                  "    let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: '9' };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Digit, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let frame = visitor.pop().unwrap();",
                  "    assert_eq!(frame.unwrap_class_bytes().ranges().len(), 10);  // for digit '0' to '9'"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };",
                  "    let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: '9' };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Digit, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };",
                  "    let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: '9' };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Digit, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };",
                  "    let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: '9' };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Digit, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };",
                  "    let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: '9' };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Digit, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let frame = visitor.pop().unwrap();",
                  "    assert_eq!(frame.unwrap_class_bytes().ranges().len(), 10);  // for digit '0' to '9'",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:25\n     |\n2547 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2547:61\n     |\n2547 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:23\n     |\n2548 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: '9' };\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:59\n     |\n2548 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: '9' };\n     |                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2550:61\n     |\n2550 |     translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:25\n     |\n2561 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2561:61\n     |\n2561 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:23\n     |\n2562 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: '9' };\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2562:59\n     |\n2562 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: '9' };\n     |                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2564:61\n     |\n2564 |     translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:30\n     |\n2560 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:48\n     |\n2560 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:25\n     |\n2547 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2547:61\n     |\n2547 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:23\n     |\n2548 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: '9' };\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:59\n     |\n2548 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: '9' };\n     |                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2550:61\n     |\n2550 |     translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:25\n     |\n2561 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2561:61\n     |\n2561 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: '0' };\n     |                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:23\n     |\n2562 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: '9' };\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2562:59\n     |\n2562 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: '9' };\n     |                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2564:61\n     |\n2564 |     translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:30\n     |\n2560 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:48\n     |\n2560 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let span = Span { start: Position(0), end: Position(0) };",
                "    let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                "    let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Upper, negated: false });",
                "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                "",
                "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                "}"
              ],
              "oracles": [
                [
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                  "    let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Upper, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                  "    let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Upper, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    assert!(translator.stack.borrow().len() == 1);"
                ],
                [
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                  "    let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Upper, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let cls = translator.stack.borrow().last().unwrap().unwrap_class_bytes();",
                  "    assert!(cls.ranges().len() > 0);"
                ],
                [
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                  "    let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Upper, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let cls = translator.stack.borrow().last().unwrap().unwrap_class_bytes();",
                  "    assert!(cls.ranges().iter().all(|range| range.start() == 'A' as u8 && range.end() == 'A' as u8));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                  "    let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Upper, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                  "    let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Upper, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                  "    let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Upper, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                  "    let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Upper, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    assert!(translator.stack.borrow().len() == 1);",
                  "}"
                ],
                [
                  "{",
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                  "    let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Upper, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                  "    let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Upper, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let cls = translator.stack.borrow().last().unwrap().unwrap_class_bytes();",
                  "    assert!(cls.ranges().len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                  "    let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Upper, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(flags),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                  "    let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Upper, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let cls = translator.stack.borrow().last().unwrap().unwrap_class_bytes();",
                  "    assert!(cls.ranges().iter().all(|range| range.start() == 'A' as u8 && range.end() == 'A' as u8));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:25\n     |\n2547 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2547:61\n     |\n2547 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:23\n     |\n2548 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:59\n     |\n2548 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2550:61\n     |\n2550 |     translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:25\n     |\n2561 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2561:61\n     |\n2561 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:23\n     |\n2562 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2562:59\n     |\n2562 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2564:61\n     |\n2564 |     translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:30\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:48\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:25\n     |\n2547 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2547:61\n     |\n2547 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:23\n     |\n2548 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:59\n     |\n2548 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2550:61\n     |\n2550 |     translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:25\n     |\n2561 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2561:61\n     |\n2561 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:23\n     |\n2562 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2562:59\n     |\n2562 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2564:61\n     |\n2564 |     translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:30\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:48\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:25\n     |\n2547 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2547:61\n     |\n2547 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:23\n     |\n2548 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:59\n     |\n2548 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2550:61\n     |\n2550 |     translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:25\n     |\n2561 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2561:61\n     |\n2561 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:23\n     |\n2562 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2562:59\n     |\n2562 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2564:61\n     |\n2564 |     translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:30\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:48\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:25\n     |\n2547 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2547:61\n     |\n2547 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:23\n     |\n2548 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:59\n     |\n2548 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2550:61\n     |\n2550 |     translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:25\n     |\n2561 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2561:61\n     |\n2561 |     let literal_start = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                                                             ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:23\n     |\n2562 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2562:59\n     |\n2562 |     let literal_end = Literal { span: span.clone(), kind: LiteralKind::Char, c: 'A' };\n     |                                                           ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2564:61\n     |\n2564 |     translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:30\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:48\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let span = Span { start: Position(0), end: Position(1) };",
                "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Print, negated: false });",
                "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                "",
                "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                "}"
              ],
              "oracles": [
                [
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(flags), allow_invalid_utf8: false };",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Print, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    assert_eq!(result.is_ok(), true);"
                ],
                [
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(flags), allow_invalid_utf8: false };",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Print, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    assert_eq!(translator.stack.borrow().len(), 2);"
                ],
                [
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(flags), allow_invalid_utf8: false };",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Print, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    assert!(matches!(translator.stack.borrow().last(), Some(HirFrame::ClassBytes(_))));"
                ],
                [
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(flags), allow_invalid_utf8: false };",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Print, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    assert!(matches!(translator.stack.borrow().get(translator.stack.borrow().len() - 2), Some(HirFrame::ClassBytes(_))));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Print, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(flags), allow_invalid_utf8: false };",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Print, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    assert_eq!(result.is_ok(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Print, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(flags), allow_invalid_utf8: false };",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Print, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    assert_eq!(translator.stack.borrow().len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Print, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(flags), allow_invalid_utf8: false };",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Print, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    assert!(matches!(translator.stack.borrow().last(), Some(HirFrame::ClassBytes(_))));",
                  "}"
                ],
                [
                  "{",
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Print, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    let flags = Flags { unicode: Some(false), ..Flags::default() };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(flags), allow_invalid_utf8: false };",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let ascii_class = ast::ClassSetItem::Ascii(ast::ClassAscii { span, kind: ast::ClassAsciiKind::Print, negated: false });",
                  "    translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    let mut visitor = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = visitor.visit_class_set_item_post(&ascii_class);",
                  "    assert!(matches!(translator.stack.borrow().get(translator.stack.borrow().len() - 2), Some(HirFrame::ClassBytes(_))));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2548:61\n     |\n2548 |     translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2556:61\n     |\n2556 |     translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:30\n     |\n2554 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:48\n     |\n2554 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2548:61\n     |\n2548 |     translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2556:61\n     |\n2556 |     translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:30\n     |\n2554 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:48\n     |\n2554 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2548:61\n     |\n2548 |     translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2556:61\n     |\n2556 |     translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:30\n     |\n2554 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:48\n     |\n2554 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2548:61\n     |\n2548 |     translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2556:61\n     |\n2556 |     translator.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                             ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:30\n     |\n2546 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:48\n     |\n2546 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:30\n     |\n2554 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:48\n     |\n2554 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 15,
      "prompt_conds": [
        "// constraint: *ast matches ast::ClassSetItem::Range(ref x) is true\n",
        "// constraint: *ast matches ast::ClassSetItem::Range(ref x) is true\n",
        "// constraint: self.flags().unicode() is true\n",
        "// constraint: self.pop().unwrap() is \n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "start: 'a', end: 'z'\n",
      "answers": [
        {
          "uses": [
            "use ast::Literal;",
            "use ast::ClassSetRange;",
            "use ast::ClassSetItem;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{ClassSetItem, ClassSetRange, Literal};",
                "    ",
                "    // Initialize necessary components for the test",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"test\";",
                "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                "",
                "    // Construct a range for unicode characters",
                "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'a' };",
                "    let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: 'z' };",
                "    let range_item = ClassSetItem::Range(ClassSetRange {",
                "        span: Span { start: Position(0), end: Position(5) },",
                "        start: start_literal,",
                "        end: end_literal,",
                "    });",
                "",
                "    // Push a dummy frame before invoking the method",
                "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                "    ",
                "    // Invoke the method under test with the range item",
                "    translator_i.visit_class_set_item_post(&range_item).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    assert_eq!(cls.ranges().len(), 1);"
                ],
                [
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    assert_eq!(cls.ranges()[0].start(), 'a');"
                ],
                [
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    assert_eq!(cls.ranges()[0].end(), 'z');"
                ],
                [
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{ClassSetItem, ClassSetRange, Literal};",
                  "    ",
                  "    // Initialize necessary components for the test",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "",
                  "    // Construct a range for unicode characters",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'a' };",
                  "    let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: 'z' };",
                  "    let range_item = ClassSetItem::Range(ClassSetRange {",
                  "        span: Span { start: Position(0), end: Position(5) },",
                  "        start: start_literal,",
                  "        end: end_literal,",
                  "    });",
                  "",
                  "    // Push a dummy frame before invoking the method",
                  "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    ",
                  "    // Invoke the method under test with the range item",
                  "    translator_i.visit_class_set_item_post(&range_item).unwrap();",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    assert_eq!(cls.ranges().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, ClassSetRange, Literal};",
                  "    ",
                  "    // Initialize necessary components for the test",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "",
                  "    // Construct a range for unicode characters",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'a' };",
                  "    let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: 'z' };",
                  "    let range_item = ClassSetItem::Range(ClassSetRange {",
                  "        span: Span { start: Position(0), end: Position(5) },",
                  "        start: start_literal,",
                  "        end: end_literal,",
                  "    });",
                  "",
                  "    // Push a dummy frame before invoking the method",
                  "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    ",
                  "    // Invoke the method under test with the range item",
                  "    translator_i.visit_class_set_item_post(&range_item).unwrap();",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    assert_eq!(cls.ranges()[0].start(), 'a');",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, ClassSetRange, Literal};",
                  "    ",
                  "    // Initialize necessary components for the test",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "",
                  "    // Construct a range for unicode characters",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'a' };",
                  "    let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: 'z' };",
                  "    let range_item = ClassSetItem::Range(ClassSetRange {",
                  "        span: Span { start: Position(0), end: Position(5) },",
                  "        start: start_literal,",
                  "        end: end_literal,",
                  "    });",
                  "",
                  "    // Push a dummy frame before invoking the method",
                  "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    ",
                  "    // Invoke the method under test with the range item",
                  "    translator_i.visit_class_set_item_post(&range_item).unwrap();",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    assert_eq!(cls.ranges()[0].end(), 'z');",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{ClassSetItem, ClassSetRange, Literal};",
                  "    ",
                  "    // Initialize necessary components for the test",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "",
                  "    // Construct a range for unicode characters",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'a' };",
                  "    let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: 'z' };",
                  "    let range_item = ClassSetItem::Range(ClassSetRange {",
                  "        span: Span { start: Position(0), end: Position(5) },",
                  "        start: start_literal,",
                  "        end: end_literal,",
                  "    });",
                  "",
                  "    // Push a dummy frame before invoking the method",
                  "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    ",
                  "    // Invoke the method under test with the range item",
                  "    translator_i.visit_class_set_item_post(&range_item).unwrap();",
                  "    let mut cls = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    assert_eq!(translator_i.trans().stack.borrow().len(), 1);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2552:94\n     |\n2552 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'a' };\n     |                                                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2553:92\n     |\n2553 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: 'z' };\n     |                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:55\n     |\n2552 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'a' };\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:73\n     |\n2552 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'a' };\n     |                                                                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:53\n     |\n2553 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: 'z' };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:71\n     |\n2553 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: 'z' };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(5) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(5) },\n     |                                               ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2552:94\n     |\n2552 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'a' };\n     |                                                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2553:92\n     |\n2553 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: 'z' };\n     |                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:55\n     |\n2552 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'a' };\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:73\n     |\n2552 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'a' };\n     |                                                                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:53\n     |\n2553 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: 'z' };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:71\n     |\n2553 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: 'z' };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(5) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(5) },\n     |                                               ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2552:94\n     |\n2552 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'a' };\n     |                                                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2553:92\n     |\n2553 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: 'z' };\n     |                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:55\n     |\n2552 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'a' };\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:73\n     |\n2552 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'a' };\n     |                                                                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:53\n     |\n2553 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: 'z' };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:71\n     |\n2553 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: 'z' };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(5) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(5) },\n     |                                               ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2552:94\n     |\n2552 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'a' };\n     |                                                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2553:92\n     |\n2553 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: 'z' };\n     |                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:55\n     |\n2552 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'a' };\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:73\n     |\n2552 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'a' };\n     |                                                                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:53\n     |\n2553 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: 'z' };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:71\n     |\n2553 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: 'z' };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(5) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(5) },\n     |                                               ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    // Similar setup but with empty range",
                "    use ast::{ClassSetItem, ClassSetRange, Literal};",
                "",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"test\";",
                "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                "",
                "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };",
                "    let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };",
                "    let range_item = ClassSetItem::Range(ClassSetRange {",
                "        span: Span { start: Position(0), end: Position(5) },",
                "        start: start_literal,",
                "        end: end_literal,",
                "    });",
                "",
                "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                "",
                "    translator_i.visit_class_set_item_post(&range_item).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };",
                  "    let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };",
                  "    let range_item = ClassSetItem::Range(ClassSetRange { span: Span { start: Position(0), end: Position(5) }, start: start_literal, end: end_literal });",
                  "    let cls = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    assert_eq!(cls.ranges().len(), 1);"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };",
                  "    let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };",
                  "    let range_item = ClassSetItem::Range(ClassSetRange { span: Span { start: Position(0), end: Position(5) }, start: start_literal, end: end_literal });",
                  "    let cls = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    assert_eq!(cls.ranges()[0].start(), ' ');"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };",
                  "    let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };",
                  "    let range_item = ClassSetItem::Range(ClassSetRange { span: Span { start: Position(0), end: Position(5) }, start: start_literal, end: end_literal });",
                  "    let cls = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    assert_eq!(cls.ranges()[0].end(), ' ');"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    // Similar setup but with empty range",
                  "    use ast::{ClassSetItem, ClassSetRange, Literal};",
                  "",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };",
                  "    let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };",
                  "    let range_item = ClassSetItem::Range(ClassSetRange {",
                  "        span: Span { start: Position(0), end: Position(5) },",
                  "        start: start_literal,",
                  "        end: end_literal,",
                  "    });",
                  "",
                  "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    translator_i.visit_class_set_item_post(&range_item).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };",
                  "    let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };",
                  "    let range_item = ClassSetItem::Range(ClassSetRange { span: Span { start: Position(0), end: Position(5) }, start: start_literal, end: end_literal });",
                  "    let cls = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    assert_eq!(cls.ranges().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    // Similar setup but with empty range",
                  "    use ast::{ClassSetItem, ClassSetRange, Literal};",
                  "",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };",
                  "    let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };",
                  "    let range_item = ClassSetItem::Range(ClassSetRange {",
                  "        span: Span { start: Position(0), end: Position(5) },",
                  "        start: start_literal,",
                  "        end: end_literal,",
                  "    });",
                  "",
                  "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    translator_i.visit_class_set_item_post(&range_item).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };",
                  "    let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };",
                  "    let range_item = ClassSetItem::Range(ClassSetRange { span: Span { start: Position(0), end: Position(5) }, start: start_literal, end: end_literal });",
                  "    let cls = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    assert_eq!(cls.ranges()[0].start(), ' ');",
                  "}"
                ],
                [
                  "{",
                  "    // Similar setup but with empty range",
                  "    use ast::{ClassSetItem, ClassSetRange, Literal};",
                  "",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };",
                  "    let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };",
                  "    let range_item = ClassSetItem::Range(ClassSetRange {",
                  "        span: Span { start: Position(0), end: Position(5) },",
                  "        start: start_literal,",
                  "        end: end_literal,",
                  "    });",
                  "",
                  "    translator_i.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    translator_i.visit_class_set_item_post(&range_item).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let pattern = \"test\";",
                  "    let mut translator_i = TranslatorI::new(&trans, pattern);",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };",
                  "    let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };",
                  "    let range_item = ClassSetItem::Range(ClassSetRange { span: Span { start: Position(0), end: Position(5) }, start: start_literal, end: end_literal });",
                  "    let cls = translator_i.pop().unwrap().unwrap_class_unicode();",
                  "    assert_eq!(cls.ranges()[0].end(), ' ');",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2551:94\n     |\n2551 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2552:92\n     |\n2552 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2565:94\n     |\n2565 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2566:92\n     |\n2566 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:55\n     |\n2551 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:73\n     |\n2551 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:53\n     |\n2552 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:71\n     |\n2552 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position(0), end: Position(5) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:47\n     |\n2554 |         span: Span { start: Position(0), end: Position(5) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:55\n     |\n2565 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:73\n     |\n2565 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:53\n     |\n2566 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:71\n     |\n2566 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:78\n     |\n2567 |     let range_item = ClassSetItem::Range(ClassSetRange { span: Span { start: Position(0), end: Position(5) }, start: start_literal, end: ...\n     |                                                                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:96\n     |\n2567 |     let range_item = ClassSetItem::Range(ClassSetRange { span: Span { start: Position(0), end: Position(5) }, start: start_literal, end: ...\n     |                                                                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2551:94\n     |\n2551 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2552:92\n     |\n2552 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2565:94\n     |\n2565 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2566:92\n     |\n2566 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:55\n     |\n2551 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:73\n     |\n2551 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:53\n     |\n2552 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:71\n     |\n2552 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position(0), end: Position(5) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:47\n     |\n2554 |         span: Span { start: Position(0), end: Position(5) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:55\n     |\n2565 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:73\n     |\n2565 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:53\n     |\n2566 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:71\n     |\n2566 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:78\n     |\n2567 |     let range_item = ClassSetItem::Range(ClassSetRange { span: Span { start: Position(0), end: Position(5) }, start: start_literal, end: ...\n     |                                                                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:96\n     |\n2567 |     let range_item = ClassSetItem::Range(ClassSetRange { span: Span { start: Position(0), end: Position(5) }, start: start_literal, end: ...\n     |                                                                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2551:94\n     |\n2551 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2552:92\n     |\n2552 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2565:94\n     |\n2565 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2566:92\n     |\n2566 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:55\n     |\n2551 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:73\n     |\n2551 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:53\n     |\n2552 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:71\n     |\n2552 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position(0), end: Position(5) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:47\n     |\n2554 |         span: Span { start: Position(0), end: Position(5) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:55\n     |\n2565 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:73\n     |\n2565 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:53\n     |\n2566 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:71\n     |\n2566 |     let end_literal = Literal { span: Span { start: Position(2), end: Position(3) }, kind: LiteralKind::Character, c: ' ' };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:78\n     |\n2567 |     let range_item = ClassSetItem::Range(ClassSetRange { span: Span { start: Position(0), end: Position(5) }, start: start_literal, end: ...\n     |                                                                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:96\n     |\n2567 |     let range_item = ClassSetItem::Range(ClassSetRange { span: Span { start: Position(0), end: Position(5) }, start: start_literal, end: ...\n     |                                                                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 17 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 16,
      "prompt_conds": [
        "// constraint: *ast matches ast::ClassSetItem::Range(ref x) is true\n",
        "// constraint: *ast matches ast::ClassSetItem::Range(ref x) is true\n",
        "// constraint: self.flags().unicode() is false\n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.class_literal_byte(&x.start)? is Err/None\n"
      ],
      "input_infer": "start: ('a', 'b'), end: ('x', 'y')\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(false),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                "    ",
                "    let start_literal = Literal {",
                "        span: Span { start: Position::new(0), end: Position::new(1) },",
                "        kind: LiteralKind::Character,",
                "        c: 'a',",
                "    };",
                "    ",
                "    let end_literal = Literal {",
                "        span: Span { start: Position::new(2), end: Position::new(3) },",
                "        kind: LiteralKind::Character,",
                "        c: 'x',",
                "    };",
                "    ",
                "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                "        span: Span { start: Position::new(0), end: Position::new(3) },",
                "        start: start_literal,",
                "        end: end_literal,",
                "    });",
                "",
                "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                "",
                "    let result = translator_i.visit_class_set_item_post(&range_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    assert!(translator_i.visit_class_set_item_post(&range_item).is_err());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    assert!(translator_i.pop().is_some());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    assert!(translator_i.pop().unwrap().unwrap_class_bytes().ranges().is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    ",
                  "    let start_literal = Literal {",
                  "        span: Span { start: Position::new(0), end: Position::new(1) },",
                  "        kind: LiteralKind::Character,",
                  "        c: 'a',",
                  "    };",
                  "    ",
                  "    let end_literal = Literal {",
                  "        span: Span { start: Position::new(2), end: Position::new(3) },",
                  "        kind: LiteralKind::Character,",
                  "        c: 'x',",
                  "    };",
                  "    ",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                  "        span: Span { start: Position::new(0), end: Position::new(3) },",
                  "        start: start_literal,",
                  "        end: end_literal,",
                  "    });",
                  "",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let result = translator_i.visit_class_set_item_post(&range_item);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    assert!(translator_i.visit_class_set_item_post(&range_item).is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    ",
                  "    let start_literal = Literal {",
                  "        span: Span { start: Position::new(0), end: Position::new(1) },",
                  "        kind: LiteralKind::Character,",
                  "        c: 'a',",
                  "    };",
                  "    ",
                  "    let end_literal = Literal {",
                  "        span: Span { start: Position::new(2), end: Position::new(3) },",
                  "        kind: LiteralKind::Character,",
                  "        c: 'x',",
                  "    };",
                  "    ",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                  "        span: Span { start: Position::new(0), end: Position::new(3) },",
                  "        start: start_literal,",
                  "        end: end_literal,",
                  "    });",
                  "",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let result = translator_i.visit_class_set_item_post(&range_item);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    assert!(translator_i.pop().is_some());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    ",
                  "    let start_literal = Literal {",
                  "        span: Span { start: Position::new(0), end: Position::new(1) },",
                  "        kind: LiteralKind::Character,",
                  "        c: 'a',",
                  "    };",
                  "    ",
                  "    let end_literal = Literal {",
                  "        span: Span { start: Position::new(2), end: Position::new(3) },",
                  "        kind: LiteralKind::Character,",
                  "        c: 'x',",
                  "    };",
                  "    ",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                  "        span: Span { start: Position::new(0), end: Position::new(3) },",
                  "        start: start_literal,",
                  "        end: end_literal,",
                  "    });",
                  "",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let result = translator_i.visit_class_set_item_post(&range_item);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                  "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    assert!(translator_i.pop().unwrap().unwrap_class_bytes().ranges().is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:25\n     |\n2550 |     let start_literal = Literal {\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n2551 |         span: Span { start: Position::new(0), end: Position::new(1) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2551:52\n     |\n2551 |         span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                                    ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2552:15\n     |\n2552 |         kind: LiteralKind::Character,\n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:23\n     |\n2556 |     let end_literal = Literal {\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:29\n     |\n2557 |         span: Span { start: Position::new(2), end: Position::new(3) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:52\n     |\n2557 |         span: Span { start: Position::new(2), end: Position::new(3) },\n     |                                                    ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2558:15\n     |\n2558 |         kind: LiteralKind::Character,\n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2563:29\n     |\n2563 |         span: Span { start: Position::new(0), end: Position::new(3) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2563:52\n     |\n2563 |         span: Span { start: Position::new(0), end: Position::new(3) },\n     |                                                    ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2568:44\n     |\n2568 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2573:44\n     |\n2573 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:25\n     |\n2550 |     let start_literal = Literal {\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n2551 |         span: Span { start: Position::new(0), end: Position::new(1) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2551:52\n     |\n2551 |         span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                                    ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2552:15\n     |\n2552 |         kind: LiteralKind::Character,\n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:23\n     |\n2556 |     let end_literal = Literal {\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:29\n     |\n2557 |         span: Span { start: Position::new(2), end: Position::new(3) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:52\n     |\n2557 |         span: Span { start: Position::new(2), end: Position::new(3) },\n     |                                                    ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2558:15\n     |\n2558 |         kind: LiteralKind::Character,\n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2563:29\n     |\n2563 |         span: Span { start: Position::new(0), end: Position::new(3) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2563:52\n     |\n2563 |         span: Span { start: Position::new(0), end: Position::new(3) },\n     |                                                    ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2568:44\n     |\n2568 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2573:44\n     |\n2573 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:25\n     |\n2550 |     let start_literal = Literal {\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n2551 |         span: Span { start: Position::new(0), end: Position::new(1) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2551:52\n     |\n2551 |         span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                                    ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2552:15\n     |\n2552 |         kind: LiteralKind::Character,\n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:23\n     |\n2556 |     let end_literal = Literal {\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:29\n     |\n2557 |         span: Span { start: Position::new(2), end: Position::new(3) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:52\n     |\n2557 |         span: Span { start: Position::new(2), end: Position::new(3) },\n     |                                                    ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2558:15\n     |\n2558 |         kind: LiteralKind::Character,\n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2563:29\n     |\n2563 |         span: Span { start: Position::new(0), end: Position::new(3) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2563:52\n     |\n2563 |         span: Span { start: Position::new(0), end: Position::new(3) },\n     |                                                    ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2568:44\n     |\n2568 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2573:44\n     |\n2573 |     translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                            ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(false),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let mut translator_i = TranslatorI::new(&trans, \"test_pattern\");",
                "    ",
                "    let start_literal = Literal {",
                "        span: Span { start: Position::new(0), end: Position::new(1) },",
                "        kind: LiteralKind::Character,",
                "        c: 'a',",
                "    };",
                "    ",
                "    let end_literal = Literal {",
                "        span: Span { start: Position::new(2), end: Position::new(3) },",
                "        kind: LiteralKind::Character,",
                "        c: 'y',",
                "    };",
                "",
                "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                "        span: Span { start: Position::new(0), end: Position::new(3) },",
                "        start: start_literal,",
                "        end: end_literal,",
                "    });",
                "",
                "    translator_i.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                "",
                "    let _result = translator_i.visit_class_set_item_post(&range_item);",
                "}"
              ],
              "oracles": [],
              "codes": [],
              "can_compile": [],
              "repaired": []
            }
          ]
        }
      ]
    },
    {
      "chain_id": 17,
      "prompt_conds": [
        "// constraint: *ast matches ast::ClassSetItem::Range(ref x) is true\n",
        "// constraint: *ast matches ast::ClassSetItem::Range(ref x) is true\n",
        "// constraint: self.flags().unicode() is false\n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.class_literal_byte(&x.start)? is Ok/Some\n",
        "// constraint: self.class_literal_byte(&x.end)? is Err/None\n"
      ],
      "input_infer": "test input ranges: ast::ClassSetItem::Range(ref x) where x.start.c is a valid ASCII character within ('\\x00', '\\x7F') and x.end.c is a valid Unicode character outside of ASCII and self.pop() returns an available HirFrame.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    struct MockTranslator {",
                "        stack: RefCell<Vec<HirFrame>>,",
                "        flags: Cell<Flags>,",
                "        allow_invalid_utf8: bool,",
                "    }",
                "",
                "    impl MockTranslator {",
                "        fn new() -> Self {",
                "            Self {",
                "                stack: RefCell::new(vec![]),",
                "                flags: Cell::new(Flags {",
                "                    unicode: Some(false),",
                "                    ..Flags::default()",
                "                }),",
                "                allow_invalid_utf8: false,",
                "            }",
                "        }",
                "    }",
                "",
                "    let mut trans = MockTranslator::new();",
                "    let pattern = \"test_pattern\";",
                "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                "",
                "    let lit_start = ast::Literal { ",
                "        span: Span { start: Position::default(), end: Position::default() }, ",
                "        kind: LiteralKind::Unicode, ",
                "        c: 'A',",
                "    };",
                "",
                "    let lit_end = ast::Literal { ",
                "        span: Span { start: Position::default(), end: Position::default() }, ",
                "        kind: LiteralKind::Unicode, ",
                "        c: '\\u{2000}', // a valid Unicode character outside of ASCII",
                "    };",
                "",
                "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                "        span: Span { start: Position::default(), end: Position::default() },",
                "        start: lit_start,",
                "        end: lit_end,",
                "    });",
                "",
                "    trans.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                "",
                "    let result = translator_instance.visit_class_set_item_post(&range_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut trans = MockTranslator::new();",
                  "    trans.flags.set(Flags {",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    });",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                  "    span: Span { start: Position::default(), end: Position::default() },",
                  "    start: lit_start,",
                  "    end: lit_end,",
                  "    });",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut trans = MockTranslator::new();",
                  "    trans.flags.set(Flags {",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    });",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                  "    span: Span { start: Position::default(), end: Position::default() },",
                  "    start: lit_start,",
                  "    end: lit_end,",
                  "    });",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::UnicodeNotAllowed);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    struct MockTranslator {",
                  "        stack: RefCell<Vec<HirFrame>>,",
                  "        flags: Cell<Flags>,",
                  "        allow_invalid_utf8: bool,",
                  "    }",
                  "",
                  "    impl MockTranslator {",
                  "        fn new() -> Self {",
                  "            Self {",
                  "                stack: RefCell::new(vec![]),",
                  "                flags: Cell::new(Flags {",
                  "                    unicode: Some(false),",
                  "                    ..Flags::default()",
                  "                }),",
                  "                allow_invalid_utf8: false,",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let mut trans = MockTranslator::new();",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let lit_start = ast::Literal { ",
                  "        span: Span { start: Position::default(), end: Position::default() }, ",
                  "        kind: LiteralKind::Unicode, ",
                  "        c: 'A',",
                  "    };",
                  "",
                  "    let lit_end = ast::Literal { ",
                  "        span: Span { start: Position::default(), end: Position::default() }, ",
                  "        kind: LiteralKind::Unicode, ",
                  "        c: '\\u{2000}', // a valid Unicode character outside of ASCII",
                  "    };",
                  "",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                  "        span: Span { start: Position::default(), end: Position::default() },",
                  "        start: lit_start,",
                  "        end: lit_end,",
                  "    });",
                  "",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let result = translator_instance.visit_class_set_item_post(&range_item);",
                  "    let mut trans = MockTranslator::new();",
                  "    trans.flags.set(Flags {",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    });",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                  "    span: Span { start: Position::default(), end: Position::default() },",
                  "    start: lit_start,",
                  "    end: lit_end,",
                  "    });",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    struct MockTranslator {",
                  "        stack: RefCell<Vec<HirFrame>>,",
                  "        flags: Cell<Flags>,",
                  "        allow_invalid_utf8: bool,",
                  "    }",
                  "",
                  "    impl MockTranslator {",
                  "        fn new() -> Self {",
                  "            Self {",
                  "                stack: RefCell::new(vec![]),",
                  "                flags: Cell::new(Flags {",
                  "                    unicode: Some(false),",
                  "                    ..Flags::default()",
                  "                }),",
                  "                allow_invalid_utf8: false,",
                  "            }",
                  "        }",
                  "    }",
                  "",
                  "    let mut trans = MockTranslator::new();",
                  "    let pattern = \"test_pattern\";",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let lit_start = ast::Literal { ",
                  "        span: Span { start: Position::default(), end: Position::default() }, ",
                  "        kind: LiteralKind::Unicode, ",
                  "        c: 'A',",
                  "    };",
                  "",
                  "    let lit_end = ast::Literal { ",
                  "        span: Span { start: Position::default(), end: Position::default() }, ",
                  "        kind: LiteralKind::Unicode, ",
                  "        c: '\\u{2000}', // a valid Unicode character outside of ASCII",
                  "    };",
                  "",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                  "        span: Span { start: Position::default(), end: Position::default() },",
                  "        start: lit_start,",
                  "        end: lit_end,",
                  "    });",
                  "",
                  "    trans.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "",
                  "    let result = translator_instance.visit_class_set_item_post(&range_item);",
                  "    let mut trans = MockTranslator::new();",
                  "    trans.flags.set(Flags {",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    });",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                  "    span: Span { start: Position::default(), end: Position::default() },",
                  "    start: lit_start,",
                  "    end: lit_end,",
                  "    });",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::UnicodeNotAllowed);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:29\n     |\n2564 |         span: Span { start: Position::default(), end: Position::default() }, \n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:55\n     |\n2564 |         span: Span { start: Position::default(), end: Position::default() }, \n     |                                                       ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2565:15\n     |\n2565 |         kind: LiteralKind::Unicode, \n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2570:29\n     |\n2570 |         span: Span { start: Position::default(), end: Position::default() }, \n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2570:55\n     |\n2570 |         span: Span { start: Position::default(), end: Position::default() }, \n     |                                                       ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2571:15\n     |\n2571 |         kind: LiteralKind::Unicode, \n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2576:29\n     |\n2576 |         span: Span { start: Position::default(), end: Position::default() },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2576:55\n     |\n2576 |         span: Span { start: Position::default(), end: Position::default() },\n     |                                                       ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2581:56\n     |\n2581 |     trans.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                        ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2590:25\n     |\n2590 |     span: Span { start: Position::default(), end: Position::default() },\n     |                         ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2590:51\n     |\n2590 |     span: Span { start: Position::default(), end: Position::default() },\n     |                                                   ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:52\n     |\n2561 |     let mut translator_instance = TranslatorI::new(&trans, pattern);\n     |                                   ---------------- ^^^^^^ expected `&Translator`, found `&MockTranslator`\n     |                                   |\n     |                                   arguments to this function are incorrect\n     |\n     = note: expected reference `&Translator`\n                found reference `&MockTranslator`\nnote: associated function defined here\n    --> regex-syntax/src/hir/translate.rs:567:8\n     |\n567  |     fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> {\n     |        ^^^ ---------------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:29\n     |\n2564 |         span: Span { start: Position::default(), end: Position::default() }, \n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:55\n     |\n2564 |         span: Span { start: Position::default(), end: Position::default() }, \n     |                                                       ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2565:15\n     |\n2565 |         kind: LiteralKind::Unicode, \n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2570:29\n     |\n2570 |         span: Span { start: Position::default(), end: Position::default() }, \n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2570:55\n     |\n2570 |         span: Span { start: Position::default(), end: Position::default() }, \n     |                                                       ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2571:15\n     |\n2571 |         kind: LiteralKind::Unicode, \n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2576:29\n     |\n2576 |         span: Span { start: Position::default(), end: Position::default() },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2576:55\n     |\n2576 |         span: Span { start: Position::default(), end: Position::default() },\n     |                                                       ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2581:56\n     |\n2581 |     trans.stack.borrow_mut().push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                        ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2590:25\n     |\n2590 |     span: Span { start: Position::default(), end: Position::default() },\n     |                         ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2590:51\n     |\n2590 |     span: Span { start: Position::default(), end: Position::default() },\n     |                                                   ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:52\n     |\n2561 |     let mut translator_instance = TranslatorI::new(&trans, pattern);\n     |                                   ---------------- ^^^^^^ expected `&Translator`, found `&MockTranslator`\n     |                                   |\n     |                                   arguments to this function are incorrect\n     |\n     = note: expected reference `&Translator`\n                found reference `&MockTranslator`\nnote: associated function defined here\n    --> regex-syntax/src/hir/translate.rs:567:8\n     |\n567  |     fn new(trans: &'t Translator, pattern: &'p str) -> TranslatorI<'t, 'p> {\n     |        ^^^ ---------------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 18,
      "prompt_conds": [
        "// constraint: *ast matches ast::ClassSetItem::Range(ref x) is true\n",
        "// constraint: *ast matches ast::ClassSetItem::Range(ref x) is true\n",
        "// constraint: self.flags().unicode() is false\n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.class_literal_byte(&x.start)? is Ok/Some\n",
        "// constraint: self.class_literal_byte(&x.end)? is Ok/Some\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "start: (0, 1), end: (255, 255)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator { ",
                "        stack: RefCell::new(vec![]), ",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), ",
                "        allow_invalid_utf8: false ",
                "    };",
                "    ",
                "    let start_literal = Literal { ",
                "        span: Span { start: Position(0), end: Position(1) }, ",
                "        kind: LiteralKind::Character, ",
                "        c: 'A' ",
                "    };",
                "    ",
                "    let end_literal = Literal { ",
                "        span: Span { start: Position(1), end: Position(2) }, ",
                "        kind: LiteralKind::Character, ",
                "        c: 'Z' ",
                "    };",
                "    ",
                "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                "        span: Span { start: Position(0), end: Position(2) }, ",
                "        start: start_literal, ",
                "        end: end_literal ",
                "    });",
                "    ",
                "    let _ = translator.visit_class_set_item_post(&range_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'A' };",
                  "    let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'Z' };",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_literal, end: end_literal });",
                  "    let result = translator.visit_class_set_item_post(&range_item);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'A' };",
                  "    let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'Z' };",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_literal, end: end_literal });",
                  "    let result = translator.visit_class_set_item_post(&range_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    let class_bytes = frame.unwrap_class_bytes();",
                  "    let ranges = class_bytes.ranges();",
                  "    assert_eq!(ranges.len(), 1);"
                ],
                [
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'A' };",
                  "    let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'Z' };",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_literal, end: end_literal });",
                  "    let result = translator.visit_class_set_item_post(&range_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    let class_bytes = frame.unwrap_class_bytes();",
                  "    let ranges = class_bytes.ranges();",
                  "    assert_eq!(ranges[0].start(), b'A');"
                ],
                [
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'A' };",
                  "    let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'Z' };",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_literal, end: end_literal });",
                  "    let result = translator.visit_class_set_item_post(&range_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    let class_bytes = frame.unwrap_class_bytes();",
                  "    let ranges = class_bytes.ranges();",
                  "    assert_eq!(ranges[0].end(), b'Z');"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator { ",
                  "        stack: RefCell::new(vec![]), ",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), ",
                  "        allow_invalid_utf8: false ",
                  "    };",
                  "    ",
                  "    let start_literal = Literal { ",
                  "        span: Span { start: Position(0), end: Position(1) }, ",
                  "        kind: LiteralKind::Character, ",
                  "        c: 'A' ",
                  "    };",
                  "    ",
                  "    let end_literal = Literal { ",
                  "        span: Span { start: Position(1), end: Position(2) }, ",
                  "        kind: LiteralKind::Character, ",
                  "        c: 'Z' ",
                  "    };",
                  "    ",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                  "        span: Span { start: Position(0), end: Position(2) }, ",
                  "        start: start_literal, ",
                  "        end: end_literal ",
                  "    });",
                  "    ",
                  "    let _ = translator.visit_class_set_item_post(&range_item);",
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'A' };",
                  "    let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'Z' };",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_literal, end: end_literal });",
                  "    let result = translator.visit_class_set_item_post(&range_item);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator { ",
                  "        stack: RefCell::new(vec![]), ",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), ",
                  "        allow_invalid_utf8: false ",
                  "    };",
                  "    ",
                  "    let start_literal = Literal { ",
                  "        span: Span { start: Position(0), end: Position(1) }, ",
                  "        kind: LiteralKind::Character, ",
                  "        c: 'A' ",
                  "    };",
                  "    ",
                  "    let end_literal = Literal { ",
                  "        span: Span { start: Position(1), end: Position(2) }, ",
                  "        kind: LiteralKind::Character, ",
                  "        c: 'Z' ",
                  "    };",
                  "    ",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                  "        span: Span { start: Position(0), end: Position(2) }, ",
                  "        start: start_literal, ",
                  "        end: end_literal ",
                  "    });",
                  "    ",
                  "    let _ = translator.visit_class_set_item_post(&range_item);",
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'A' };",
                  "    let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'Z' };",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_literal, end: end_literal });",
                  "    let result = translator.visit_class_set_item_post(&range_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    let class_bytes = frame.unwrap_class_bytes();",
                  "    let ranges = class_bytes.ranges();",
                  "    assert_eq!(ranges.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator { ",
                  "        stack: RefCell::new(vec![]), ",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), ",
                  "        allow_invalid_utf8: false ",
                  "    };",
                  "    ",
                  "    let start_literal = Literal { ",
                  "        span: Span { start: Position(0), end: Position(1) }, ",
                  "        kind: LiteralKind::Character, ",
                  "        c: 'A' ",
                  "    };",
                  "    ",
                  "    let end_literal = Literal { ",
                  "        span: Span { start: Position(1), end: Position(2) }, ",
                  "        kind: LiteralKind::Character, ",
                  "        c: 'Z' ",
                  "    };",
                  "    ",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                  "        span: Span { start: Position(0), end: Position(2) }, ",
                  "        start: start_literal, ",
                  "        end: end_literal ",
                  "    });",
                  "    ",
                  "    let _ = translator.visit_class_set_item_post(&range_item);",
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'A' };",
                  "    let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'Z' };",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_literal, end: end_literal });",
                  "    let result = translator.visit_class_set_item_post(&range_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    let class_bytes = frame.unwrap_class_bytes();",
                  "    let ranges = class_bytes.ranges();",
                  "    assert_eq!(ranges[0].start(), b'A');",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator { ",
                  "        stack: RefCell::new(vec![]), ",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), ",
                  "        allow_invalid_utf8: false ",
                  "    };",
                  "    ",
                  "    let start_literal = Literal { ",
                  "        span: Span { start: Position(0), end: Position(1) }, ",
                  "        kind: LiteralKind::Character, ",
                  "        c: 'A' ",
                  "    };",
                  "    ",
                  "    let end_literal = Literal { ",
                  "        span: Span { start: Position(1), end: Position(2) }, ",
                  "        kind: LiteralKind::Character, ",
                  "        c: 'Z' ",
                  "    };",
                  "    ",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                  "        span: Span { start: Position(0), end: Position(2) }, ",
                  "        start: start_literal, ",
                  "        end: end_literal ",
                  "    });",
                  "    ",
                  "    let _ = translator.visit_class_set_item_post(&range_item);",
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'A' };",
                  "    let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'Z' };",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_literal, end: end_literal });",
                  "    let result = translator.visit_class_set_item_post(&range_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    let class_bytes = frame.unwrap_class_bytes();",
                  "    let ranges = class_bytes.ranges();",
                  "    assert_eq!(ranges[0].end(), b'Z');",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:25\n     |\n2546 |     let start_literal = Literal { \n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |         kind: LiteralKind::Character, \n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:23\n     |\n2552 |     let end_literal = Literal { \n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2554:15\n     |\n2554 |         kind: LiteralKind::Character, \n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'A' };\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2566:94\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:23\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'Z' };\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2567:92\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'Z' };\n     |                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n2547 |         span: Span { start: Position(0), end: Position(1) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:47\n     |\n2547 |         span: Span { start: Position(0), end: Position(1) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: Position(1), end: Position(2) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:47\n     |\n2553 |         span: Span { start: Position(1), end: Position(2) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:29\n     |\n2559 |         span: Span { start: Position(0), end: Position(2) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:47\n     |\n2559 |         span: Span { start: Position(0), end: Position(2) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:24\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2564 |     let _ = translator.visit_class_set_item_post(&range_item);\n     |                        ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:55\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'A' };\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:73\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:53\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'Z' };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:71\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'Z' };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:88\n     |\n2568 |     let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_lite...\n     |                                                                                        ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:106\n     |\n2568 | ...ssSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_literal, end: end_literal });\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2569 |     let result = translator.visit_class_set_item_post(&range_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:25\n     |\n2546 |     let start_literal = Literal { \n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |         kind: LiteralKind::Character, \n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:23\n     |\n2552 |     let end_literal = Literal { \n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2554:15\n     |\n2554 |         kind: LiteralKind::Character, \n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'A' };\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2566:94\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:23\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'Z' };\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2567:92\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'Z' };\n     |                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n2547 |         span: Span { start: Position(0), end: Position(1) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:47\n     |\n2547 |         span: Span { start: Position(0), end: Position(1) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: Position(1), end: Position(2) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:47\n     |\n2553 |         span: Span { start: Position(1), end: Position(2) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:29\n     |\n2559 |         span: Span { start: Position(0), end: Position(2) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:47\n     |\n2559 |         span: Span { start: Position(0), end: Position(2) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:24\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2564 |     let _ = translator.visit_class_set_item_post(&range_item);\n     |                        ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:55\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'A' };\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:73\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:53\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'Z' };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:71\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'Z' };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:88\n     |\n2568 |     let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_lite...\n     |                                                                                        ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:106\n     |\n2568 | ...ssSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_literal, end: end_literal });\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2569 |     let result = translator.visit_class_set_item_post(&range_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:28\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2570 |     let frame = translator.pop().unwrap();\n     |                            ^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:25\n     |\n2546 |     let start_literal = Literal { \n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |         kind: LiteralKind::Character, \n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:23\n     |\n2552 |     let end_literal = Literal { \n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2554:15\n     |\n2554 |         kind: LiteralKind::Character, \n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'A' };\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2566:94\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:23\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'Z' };\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2567:92\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'Z' };\n     |                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n2547 |         span: Span { start: Position(0), end: Position(1) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:47\n     |\n2547 |         span: Span { start: Position(0), end: Position(1) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: Position(1), end: Position(2) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:47\n     |\n2553 |         span: Span { start: Position(1), end: Position(2) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:29\n     |\n2559 |         span: Span { start: Position(0), end: Position(2) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:47\n     |\n2559 |         span: Span { start: Position(0), end: Position(2) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:24\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2564 |     let _ = translator.visit_class_set_item_post(&range_item);\n     |                        ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:55\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'A' };\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:73\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:53\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'Z' };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:71\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'Z' };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:88\n     |\n2568 |     let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_lite...\n     |                                                                                        ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:106\n     |\n2568 | ...ssSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_literal, end: end_literal });\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2569 |     let result = translator.visit_class_set_item_post(&range_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:28\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2570 |     let frame = translator.pop().unwrap();\n     |                            ^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:25\n     |\n2546 |     let start_literal = Literal { \n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |         kind: LiteralKind::Character, \n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:23\n     |\n2552 |     let end_literal = Literal { \n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2554:15\n     |\n2554 |         kind: LiteralKind::Character, \n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'A' };\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2566:94\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:23\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'Z' };\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2567:92\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'Z' };\n     |                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n2547 |         span: Span { start: Position(0), end: Position(1) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:47\n     |\n2547 |         span: Span { start: Position(0), end: Position(1) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: Position(1), end: Position(2) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:47\n     |\n2553 |         span: Span { start: Position(1), end: Position(2) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:29\n     |\n2559 |         span: Span { start: Position(0), end: Position(2) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:47\n     |\n2559 |         span: Span { start: Position(0), end: Position(2) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:24\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2564 |     let _ = translator.visit_class_set_item_post(&range_item);\n     |                        ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:55\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'A' };\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:73\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:53\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'Z' };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:71\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'Z' };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:88\n     |\n2568 |     let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_lite...\n     |                                                                                        ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:106\n     |\n2568 | ...ssSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_literal, end: end_literal });\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2569 |     let result = translator.visit_class_set_item_post(&range_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:28\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2570 |     let frame = translator.pop().unwrap();\n     |                            ^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator { ",
                "        stack: RefCell::new(vec![]), ",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), ",
                "        allow_invalid_utf8: false ",
                "    };",
                "    ",
                "    let start_literal = Literal { ",
                "        span: Span { start: Position(0), end: Position(1) }, ",
                "        kind: LiteralKind::Byte, ",
                "        c: '0' ",
                "    };",
                "    ",
                "    let end_literal = Literal { ",
                "        span: Span { start: Position(1), end: Position(2) }, ",
                "        kind: LiteralKind::Byte, ",
                "        c: '9' ",
                "    };",
                "    ",
                "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                "        span: Span { start: Position(0), end: Position(2) }, ",
                "        start: start_literal, ",
                "        end: end_literal ",
                "    });",
                "    ",
                "    let _ = translator.visit_class_set_item_post(&range_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Byte, c: '0' };",
                  "    let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Byte, c: '9' };",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_literal, end: end_literal });",
                  "    let result = translator.visit_class_set_item_post(&range_item);",
                  "    assert_eq!(result, Ok(()));"
                ],
                [
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Byte, c: '0' };",
                  "    let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Byte, c: '9' };",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_literal, end: end_literal });",
                  "    let result = translator.visit_class_set_item_post(&range_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    assert!(frame.unwrap_class_bytes().ranges().len() == 1);"
                ],
                [
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Byte, c: '0' };",
                  "    let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Byte, c: '9' };",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_literal, end: end_literal });",
                  "    let result = translator.visit_class_set_item_post(&range_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    assert!(frame.unwrap_class_bytes().ranges()[0].start() == b'0');"
                ],
                [
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Byte, c: '0' };",
                  "    let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Byte, c: '9' };",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_literal, end: end_literal });",
                  "    let result = translator.visit_class_set_item_post(&range_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    assert!(frame.unwrap_class_bytes().ranges()[0].end() == b'9');"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator { ",
                  "        stack: RefCell::new(vec![]), ",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), ",
                  "        allow_invalid_utf8: false ",
                  "    };",
                  "    ",
                  "    let start_literal = Literal { ",
                  "        span: Span { start: Position(0), end: Position(1) }, ",
                  "        kind: LiteralKind::Byte, ",
                  "        c: '0' ",
                  "    };",
                  "    ",
                  "    let end_literal = Literal { ",
                  "        span: Span { start: Position(1), end: Position(2) }, ",
                  "        kind: LiteralKind::Byte, ",
                  "        c: '9' ",
                  "    };",
                  "    ",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                  "        span: Span { start: Position(0), end: Position(2) }, ",
                  "        start: start_literal, ",
                  "        end: end_literal ",
                  "    });",
                  "    ",
                  "    let _ = translator.visit_class_set_item_post(&range_item);",
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Byte, c: '0' };",
                  "    let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Byte, c: '9' };",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_literal, end: end_literal });",
                  "    let result = translator.visit_class_set_item_post(&range_item);",
                  "    assert_eq!(result, Ok(()));",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator { ",
                  "        stack: RefCell::new(vec![]), ",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), ",
                  "        allow_invalid_utf8: false ",
                  "    };",
                  "    ",
                  "    let start_literal = Literal { ",
                  "        span: Span { start: Position(0), end: Position(1) }, ",
                  "        kind: LiteralKind::Byte, ",
                  "        c: '0' ",
                  "    };",
                  "    ",
                  "    let end_literal = Literal { ",
                  "        span: Span { start: Position(1), end: Position(2) }, ",
                  "        kind: LiteralKind::Byte, ",
                  "        c: '9' ",
                  "    };",
                  "    ",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                  "        span: Span { start: Position(0), end: Position(2) }, ",
                  "        start: start_literal, ",
                  "        end: end_literal ",
                  "    });",
                  "    ",
                  "    let _ = translator.visit_class_set_item_post(&range_item);",
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Byte, c: '0' };",
                  "    let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Byte, c: '9' };",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_literal, end: end_literal });",
                  "    let result = translator.visit_class_set_item_post(&range_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    assert!(frame.unwrap_class_bytes().ranges().len() == 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator { ",
                  "        stack: RefCell::new(vec![]), ",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), ",
                  "        allow_invalid_utf8: false ",
                  "    };",
                  "    ",
                  "    let start_literal = Literal { ",
                  "        span: Span { start: Position(0), end: Position(1) }, ",
                  "        kind: LiteralKind::Byte, ",
                  "        c: '0' ",
                  "    };",
                  "    ",
                  "    let end_literal = Literal { ",
                  "        span: Span { start: Position(1), end: Position(2) }, ",
                  "        kind: LiteralKind::Byte, ",
                  "        c: '9' ",
                  "    };",
                  "    ",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                  "        span: Span { start: Position(0), end: Position(2) }, ",
                  "        start: start_literal, ",
                  "        end: end_literal ",
                  "    });",
                  "    ",
                  "    let _ = translator.visit_class_set_item_post(&range_item);",
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Byte, c: '0' };",
                  "    let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Byte, c: '9' };",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_literal, end: end_literal });",
                  "    let result = translator.visit_class_set_item_post(&range_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    assert!(frame.unwrap_class_bytes().ranges()[0].start() == b'0');",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator { ",
                  "        stack: RefCell::new(vec![]), ",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), ",
                  "        allow_invalid_utf8: false ",
                  "    };",
                  "    ",
                  "    let start_literal = Literal { ",
                  "        span: Span { start: Position(0), end: Position(1) }, ",
                  "        kind: LiteralKind::Byte, ",
                  "        c: '0' ",
                  "    };",
                  "    ",
                  "    let end_literal = Literal { ",
                  "        span: Span { start: Position(1), end: Position(2) }, ",
                  "        kind: LiteralKind::Byte, ",
                  "        c: '9' ",
                  "    };",
                  "    ",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                  "        span: Span { start: Position(0), end: Position(2) }, ",
                  "        start: start_literal, ",
                  "        end: end_literal ",
                  "    });",
                  "    ",
                  "    let _ = translator.visit_class_set_item_post(&range_item);",
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Byte, c: '0' };",
                  "    let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Byte, c: '9' };",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_literal, end: end_literal });",
                  "    let result = translator.visit_class_set_item_post(&range_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    assert!(frame.unwrap_class_bytes().ranges()[0].end() == b'9');",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:25\n     |\n2546 |     let start_literal = Literal { \n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |         kind: LiteralKind::Byte, \n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:23\n     |\n2552 |     let end_literal = Literal { \n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2554:15\n     |\n2554 |         kind: LiteralKind::Byte, \n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Byte, c: '0' };\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2566:94\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Byte, c: '0' };\n     |                                                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:23\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Byte, c: '9' };\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2567:92\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Byte, c: '9' };\n     |                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n2547 |         span: Span { start: Position(0), end: Position(1) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:47\n     |\n2547 |         span: Span { start: Position(0), end: Position(1) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: Position(1), end: Position(2) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:47\n     |\n2553 |         span: Span { start: Position(1), end: Position(2) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:29\n     |\n2559 |         span: Span { start: Position(0), end: Position(2) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:47\n     |\n2559 |         span: Span { start: Position(0), end: Position(2) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:24\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2564 |     let _ = translator.visit_class_set_item_post(&range_item);\n     |                        ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:55\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Byte, c: '0' };\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:73\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Byte, c: '0' };\n     |                                                                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:53\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Byte, c: '9' };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:71\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Byte, c: '9' };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:88\n     |\n2568 |     let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_lite...\n     |                                                                                        ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:106\n     |\n2568 | ...ssSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_literal, end: end_literal });\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2569 |     let result = translator.visit_class_set_item_post(&range_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:25\n     |\n2546 |     let start_literal = Literal { \n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |         kind: LiteralKind::Byte, \n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:23\n     |\n2552 |     let end_literal = Literal { \n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2554:15\n     |\n2554 |         kind: LiteralKind::Byte, \n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Byte, c: '0' };\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2566:94\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Byte, c: '0' };\n     |                                                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:23\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Byte, c: '9' };\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2567:92\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Byte, c: '9' };\n     |                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n2547 |         span: Span { start: Position(0), end: Position(1) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:47\n     |\n2547 |         span: Span { start: Position(0), end: Position(1) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: Position(1), end: Position(2) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:47\n     |\n2553 |         span: Span { start: Position(1), end: Position(2) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:29\n     |\n2559 |         span: Span { start: Position(0), end: Position(2) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:47\n     |\n2559 |         span: Span { start: Position(0), end: Position(2) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:24\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2564 |     let _ = translator.visit_class_set_item_post(&range_item);\n     |                        ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:55\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Byte, c: '0' };\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:73\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Byte, c: '0' };\n     |                                                                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:53\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Byte, c: '9' };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:71\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Byte, c: '9' };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:88\n     |\n2568 |     let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_lite...\n     |                                                                                        ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:106\n     |\n2568 | ...ssSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_literal, end: end_literal });\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2569 |     let result = translator.visit_class_set_item_post(&range_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:28\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2570 |     let frame = translator.pop().unwrap();\n     |                            ^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:25\n     |\n2546 |     let start_literal = Literal { \n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |         kind: LiteralKind::Byte, \n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:23\n     |\n2552 |     let end_literal = Literal { \n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2554:15\n     |\n2554 |         kind: LiteralKind::Byte, \n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Byte, c: '0' };\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2566:94\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Byte, c: '0' };\n     |                                                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:23\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Byte, c: '9' };\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2567:92\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Byte, c: '9' };\n     |                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n2547 |         span: Span { start: Position(0), end: Position(1) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:47\n     |\n2547 |         span: Span { start: Position(0), end: Position(1) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: Position(1), end: Position(2) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:47\n     |\n2553 |         span: Span { start: Position(1), end: Position(2) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:29\n     |\n2559 |         span: Span { start: Position(0), end: Position(2) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:47\n     |\n2559 |         span: Span { start: Position(0), end: Position(2) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:24\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2564 |     let _ = translator.visit_class_set_item_post(&range_item);\n     |                        ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:55\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Byte, c: '0' };\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:73\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Byte, c: '0' };\n     |                                                                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:53\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Byte, c: '9' };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:71\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Byte, c: '9' };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:88\n     |\n2568 |     let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_lite...\n     |                                                                                        ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:106\n     |\n2568 | ...ssSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_literal, end: end_literal });\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2569 |     let result = translator.visit_class_set_item_post(&range_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:28\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2570 |     let frame = translator.pop().unwrap();\n     |                            ^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2546:25\n     |\n2546 |     let start_literal = Literal { \n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2548:15\n     |\n2548 |         kind: LiteralKind::Byte, \n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:23\n     |\n2552 |     let end_literal = Literal { \n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2554:15\n     |\n2554 |         kind: LiteralKind::Byte, \n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Byte, c: '0' };\n     |                         ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2566:94\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Byte, c: '0' };\n     |                                                                                              ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:23\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Byte, c: '9' };\n     |                       ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2567:92\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Byte, c: '9' };\n     |                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n2547 |         span: Span { start: Position(0), end: Position(1) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:47\n     |\n2547 |         span: Span { start: Position(0), end: Position(1) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: Position(1), end: Position(2) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:47\n     |\n2553 |         span: Span { start: Position(1), end: Position(2) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:29\n     |\n2559 |         span: Span { start: Position(0), end: Position(2) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:47\n     |\n2559 |         span: Span { start: Position(0), end: Position(2) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:24\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2564 |     let _ = translator.visit_class_set_item_post(&range_item);\n     |                        ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:55\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Byte, c: '0' };\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2566:73\n     |\n2566 |     let start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Byte, c: '0' };\n     |                                                                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:53\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Byte, c: '9' };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:71\n     |\n2567 |     let end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Byte, c: '9' };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:88\n     |\n2568 |     let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_lite...\n     |                                                                                        ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:106\n     |\n2568 | ...ssSetRange { span: Span { start: Position(0), end: Position(2) }, start: start_literal, end: end_literal });\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2569:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2569 |     let result = translator.visit_class_set_item_post(&range_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:28\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2570 |     let frame = translator.pop().unwrap();\n     |                            ^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 24 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let mut translator = Translator { ",
                "        stack: RefCell::new(vec![]), ",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), ",
                "        allow_invalid_utf8: false ",
                "    };",
                "    ",
                "    let invalid_start_literal = Literal { ",
                "        span: Span { start: Position(0), end: Position(1) }, ",
                "        kind: LiteralKind::Invalid, ",
                "        c: '\\0' ",
                "    };",
                "    ",
                "    let valid_end_literal = Literal { ",
                "        span: Span { start: Position(1), end: Position(2) }, ",
                "        kind: LiteralKind::Character, ",
                "        c: 'A' ",
                "    };",
                "    ",
                "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                "        span: Span { start: Position(0), end: Position(2) }, ",
                "        start: invalid_start_literal, ",
                "        end: valid_end_literal ",
                "    });",
                "    ",
                "    let _ = translator.visit_class_set_item_post(&range_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let invalid_start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Invalid, c: '\\0' };",
                  "    let valid_end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'A' };",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: invalid_start_literal, end: valid_end_literal });",
                  "    let result = translator.visit_class_set_item_post(&range_item);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let invalid_start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Invalid, c: '\\0' };",
                  "    let valid_end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'A' };",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: invalid_start_literal, end: valid_end_literal });",
                  "    let result = translator.visit_class_set_item_post(&range_item);",
                  "    assert!(matches!(result, Err(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator { ",
                  "        stack: RefCell::new(vec![]), ",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), ",
                  "        allow_invalid_utf8: false ",
                  "    };",
                  "    ",
                  "    let invalid_start_literal = Literal { ",
                  "        span: Span { start: Position(0), end: Position(1) }, ",
                  "        kind: LiteralKind::Invalid, ",
                  "        c: '\\0' ",
                  "    };",
                  "    ",
                  "    let valid_end_literal = Literal { ",
                  "        span: Span { start: Position(1), end: Position(2) }, ",
                  "        kind: LiteralKind::Character, ",
                  "        c: 'A' ",
                  "    };",
                  "    ",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                  "        span: Span { start: Position(0), end: Position(2) }, ",
                  "        start: invalid_start_literal, ",
                  "        end: valid_end_literal ",
                  "    });",
                  "    ",
                  "    let _ = translator.visit_class_set_item_post(&range_item);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let invalid_start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Invalid, c: '\\0' };",
                  "    let valid_end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'A' };",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: invalid_start_literal, end: valid_end_literal });",
                  "    let result = translator.visit_class_set_item_post(&range_item);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator { ",
                  "        stack: RefCell::new(vec![]), ",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), ",
                  "        allow_invalid_utf8: false ",
                  "    };",
                  "    ",
                  "    let invalid_start_literal = Literal { ",
                  "        span: Span { start: Position(0), end: Position(1) }, ",
                  "        kind: LiteralKind::Invalid, ",
                  "        c: '\\0' ",
                  "    };",
                  "    ",
                  "    let valid_end_literal = Literal { ",
                  "        span: Span { start: Position(1), end: Position(2) }, ",
                  "        kind: LiteralKind::Character, ",
                  "        c: 'A' ",
                  "    };",
                  "    ",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange {",
                  "        span: Span { start: Position(0), end: Position(2) }, ",
                  "        start: invalid_start_literal, ",
                  "        end: valid_end_literal ",
                  "    });",
                  "    ",
                  "    let _ = translator.visit_class_set_item_post(&range_item);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let invalid_start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Invalid, c: '\\0' };",
                  "    let valid_end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'A' };",
                  "    let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: invalid_start_literal, end: valid_end_literal });",
                  "    let result = translator.visit_class_set_item_post(&range_item);",
                  "    assert!(matches!(result, Err(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:33\n     |\n2547 |     let invalid_start_literal = Literal { \n     |                                 ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:15\n     |\n2549 |         kind: LiteralKind::Invalid, \n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |     let valid_end_literal = Literal { \n     |                             ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2555:15\n     |\n2555 |         kind: LiteralKind::Character, \n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:33\n     |\n2567 |     let invalid_start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Invalid, c: '\\0' };\n     |                                 ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2567:102\n     |\n2567 |     let invalid_start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Invalid, c: '\\0' };\n     |                                                                                                      ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:29\n     |\n2568 |     let valid_end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'A' };\n     |                             ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2568:98\n     |\n2568 |     let valid_end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                                                  ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(1) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(1) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position(1), end: Position(2) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:47\n     |\n2554 |         span: Span { start: Position(1), end: Position(2) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:29\n     |\n2560 |         span: Span { start: Position(0), end: Position(2) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:47\n     |\n2560 |         span: Span { start: Position(0), end: Position(2) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:24\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2565 |     let _ = translator.visit_class_set_item_post(&range_item);\n     |                        ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:63\n     |\n2567 |     let invalid_start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Invalid, c: '\\0' };\n     |                                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:81\n     |\n2567 |     let invalid_start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Invalid, c: '\\0' };\n     |                                                                                 ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:59\n     |\n2568 |     let valid_end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'A' };\n     |                                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:77\n     |\n2568 |     let valid_end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:88\n     |\n2569 |     let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: invalid_st...\n     |                                                                                        ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:106\n     |\n2569 | ...ssSetRange { span: Span { start: Position(0), end: Position(2) }, start: invalid_start_literal, end: valid_end_literal });\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2570 |     let result = translator.visit_class_set_item_post(&range_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:33\n     |\n2547 |     let invalid_start_literal = Literal { \n     |                                 ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:15\n     |\n2549 |         kind: LiteralKind::Invalid, \n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |     let valid_end_literal = Literal { \n     |                             ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2555:15\n     |\n2555 |         kind: LiteralKind::Character, \n     |               ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:33\n     |\n2567 |     let invalid_start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Invalid, c: '\\0' };\n     |                                 ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2567:102\n     |\n2567 |     let invalid_start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Invalid, c: '\\0' };\n     |                                                                                                      ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:29\n     |\n2568 |     let valid_end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'A' };\n     |                             ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2568:98\n     |\n2568 |     let valid_end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                                                  ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(1) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(1) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position(1), end: Position(2) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2554:47\n     |\n2554 |         span: Span { start: Position(1), end: Position(2) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:29\n     |\n2560 |         span: Span { start: Position(0), end: Position(2) }, \n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:47\n     |\n2560 |         span: Span { start: Position(0), end: Position(2) }, \n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2565:24\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2565 |     let _ = translator.visit_class_set_item_post(&range_item);\n     |                        ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:63\n     |\n2567 |     let invalid_start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Invalid, c: '\\0' };\n     |                                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:81\n     |\n2567 |     let invalid_start_literal = Literal { span: Span { start: Position(0), end: Position(1) }, kind: LiteralKind::Invalid, c: '\\0' };\n     |                                                                                 ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:59\n     |\n2568 |     let valid_end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'A' };\n     |                                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:77\n     |\n2568 |     let valid_end_literal = Literal { span: Span { start: Position(1), end: Position(2) }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:88\n     |\n2569 |     let range_item = ast::ClassSetItem::Range(ast::ClassSetRange { span: Span { start: Position(0), end: Position(2) }, start: invalid_st...\n     |                                                                                        ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:106\n     |\n2569 | ...ssSetRange { span: Span { start: Position(0), end: Position(2) }, start: invalid_start_literal, end: valid_end_literal });\n     |                                                       ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2570:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2570 |     let result = translator.visit_class_set_item_post(&range_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 23 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 19,
      "prompt_conds": [
        "// constraint: *ast matches ast::ClassSetItem::Literal(ref x) is true\n",
        "// constraint: *ast matches ast::ClassSetItem::Literal(ref x) is true\n",
        "// constraint: self.flags().unicode() is true\n",
        "// constraint: self.pop().unwrap() is \n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "ast::ClassSetItem::Literal(ref x) where x.c in ['\\u{0000}', '\\u{007F}'] and self.flags().unicode() is true and self.pop().unwrap() is valid\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    // Arrange",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    ",
                "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                "    let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };",
                "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                "    ",
                "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                "",
                "    // Act",
                "    let result = translator.visit_class_set_item_post(&class_set_item);",
                "",
                "    // Assert",
                "    // The assertion is omitted as per request",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    assert_eq!(translator.stack.borrow().len(), 2);  // 1 push + 1 pop"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    let frame = translator.stack.borrow().last().unwrap();",
                  "    let cls = frame.unwrap_class_unicode();",
                  "    assert_eq!(cls.ranges().len(), 1);"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    let frame = translator.stack.borrow().last().unwrap();",
                  "    let cls = frame.unwrap_class_unicode();",
                  "    assert_eq!(cls.ranges()[0].start(), '\\u{0041}');"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    let frame = translator.stack.borrow().last().unwrap();",
                  "    let cls = frame.unwrap_class_unicode();",
                  "    assert_eq!(cls.ranges()[0].end(), '\\u{0041}');"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    // Arrange",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    ",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    // Act",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "",
                  "    // Assert",
                  "    // The assertion is omitted as per request",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    // Arrange",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    ",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    // Act",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "",
                  "    // Assert",
                  "    // The assertion is omitted as per request",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    assert_eq!(translator.stack.borrow().len(), 2);  // 1 push + 1 pop",
                  "}"
                ],
                [
                  "{",
                  "    // Arrange",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    ",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    // Act",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "",
                  "    // Assert",
                  "    // The assertion is omitted as per request",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    let frame = translator.stack.borrow().last().unwrap();",
                  "    let cls = frame.unwrap_class_unicode();",
                  "    assert_eq!(cls.ranges().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    // Arrange",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    ",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    // Act",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "",
                  "    // Assert",
                  "    // The assertion is omitted as per request",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    let frame = translator.stack.borrow().last().unwrap();",
                  "    let cls = frame.unwrap_class_unicode();",
                  "    assert_eq!(cls.ranges()[0].start(), '\\u{0041}');",
                  "}"
                ],
                [
                  "{",
                  "    // Arrange",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    ",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    // Act",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "",
                  "    // Assert",
                  "    // The assertion is omitted as per request",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    let frame = translator.stack.borrow().last().unwrap();",
                  "    let cls = frame.unwrap_class_unicode();",
                  "    assert_eq!(cls.ranges()[0].end(), '\\u{0041}');",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:70\n     |\n2547 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                                                                      ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:19\n     |\n2548 |     let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:30\n     |\n2563 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:70\n     |\n2563 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                                                                      ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:19\n     |\n2564 |     let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2551 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2554 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2566 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2567 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:70\n     |\n2547 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                                                                      ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:19\n     |\n2548 |     let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:30\n     |\n2563 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:70\n     |\n2563 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                                                                      ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:19\n     |\n2564 |     let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2551 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2554 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2566 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2567 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:70\n     |\n2547 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                                                                      ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:19\n     |\n2548 |     let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:30\n     |\n2563 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:70\n     |\n2563 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                                                                      ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:19\n     |\n2564 |     let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2551 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2554 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2566 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2567 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:70\n     |\n2547 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                                                                      ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:19\n     |\n2548 |     let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:30\n     |\n2563 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:70\n     |\n2563 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                                                                      ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:19\n     |\n2564 |     let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2551 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2554 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2566 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2567 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:70\n     |\n2547 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                                                                      ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:19\n     |\n2548 |     let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:30\n     |\n2563 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:70\n     |\n2563 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                                                                      ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:19\n     |\n2564 |     let literal = Literal { span, kind: Default::default(), c: '\\u{0041}' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2551 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2554 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2566 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2567 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    // Arrange",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    ",
                "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                "    let literal = Literal { span, kind: Default::default(), c: '\\u{007F}' };",
                "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                "    ",
                "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                "",
                "    // Act",
                "    let result = translator.visit_class_set_item_post(&class_set_item);",
                "",
                "    // Assert",
                "    // The assertion is omitted as per request",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{007F}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{007F}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    let cls = frame.unwrap_class_unicode();",
                  "    let ranges = cls.ranges();",
                  "    assert_eq!(ranges.len(), 1);"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{007F}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    let cls = frame.unwrap_class_unicode();",
                  "    let ranges = cls.ranges();",
                  "    assert_eq!(ranges[0].start(), '\\u{007F}');"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{007F}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    let cls = frame.unwrap_class_unicode();",
                  "    let ranges = cls.ranges();",
                  "    assert_eq!(ranges[0].end(), '\\u{007F}');"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    // Arrange",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{007F}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    ",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    // Act",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "",
                  "    // Assert",
                  "    // The assertion is omitted as per request",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{007F}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    // Arrange",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{007F}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    ",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    // Act",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "",
                  "    // Assert",
                  "    // The assertion is omitted as per request",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{007F}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    let cls = frame.unwrap_class_unicode();",
                  "    let ranges = cls.ranges();",
                  "    assert_eq!(ranges.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    // Arrange",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{007F}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    ",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    // Act",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "",
                  "    // Assert",
                  "    // The assertion is omitted as per request",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{007F}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    let cls = frame.unwrap_class_unicode();",
                  "    let ranges = cls.ranges();",
                  "    assert_eq!(ranges[0].start(), '\\u{007F}');",
                  "}"
                ],
                [
                  "{",
                  "    // Arrange",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    ",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{007F}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    ",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "",
                  "    // Act",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "",
                  "    // Assert",
                  "    // The assertion is omitted as per request",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };",
                  "    let literal = Literal { span, kind: Default::default(), c: '\\u{007F}' };",
                  "    let class_set_item = ast::ClassSetItem::Literal(literal);",
                  "    translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));",
                  "    let result = translator.visit_class_set_item_post(&class_set_item);",
                  "    let frame = translator.pop().unwrap();",
                  "    let cls = frame.unwrap_class_unicode();",
                  "    let ranges = cls.ranges();",
                  "    assert_eq!(ranges[0].end(), '\\u{007F}');",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:70\n     |\n2547 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                                                                      ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:19\n     |\n2548 |     let literal = Literal { span, kind: Default::default(), c: '\\u{007F}' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:30\n     |\n2563 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:70\n     |\n2563 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                                                                      ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:19\n     |\n2564 |     let literal = Literal { span, kind: Default::default(), c: '\\u{007F}' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2551 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2554 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2566 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2567 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:70\n     |\n2547 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                                                                      ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:19\n     |\n2548 |     let literal = Literal { span, kind: Default::default(), c: '\\u{007F}' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:30\n     |\n2563 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:70\n     |\n2563 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                                                                      ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:19\n     |\n2564 |     let literal = Literal { span, kind: Default::default(), c: '\\u{007F}' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2551 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2554 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2566 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2567 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:28\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2568 |     let frame = translator.pop().unwrap();\n     |                            ^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:70\n     |\n2547 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                                                                      ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:19\n     |\n2548 |     let literal = Literal { span, kind: Default::default(), c: '\\u{007F}' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:30\n     |\n2563 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:70\n     |\n2563 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                                                                      ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:19\n     |\n2564 |     let literal = Literal { span, kind: Default::default(), c: '\\u{007F}' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2551 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2554 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2566 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2567 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:28\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2568 |     let frame = translator.pop().unwrap();\n     |                            ^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:30\n     |\n2547 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:70\n     |\n2547 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                                                                      ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:19\n     |\n2548 |     let literal = Literal { span, kind: Default::default(), c: '\\u{007F}' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:30\n     |\n2563 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:70\n     |\n2563 |     let span = Span { start: Position { ..Default::default() }, end: Position { ..Default::default() } };\n     |                                                                      ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:19\n     |\n2564 |     let literal = Literal { span, kind: Default::default(), c: '\\u{007F}' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2551 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2554 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `push` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:16\n     |\n118  | pub struct Translator {\n     | --------------------- method `push` not found for this struct\n...\n2566 |     translator.push(HirFrame::ClassUnicode(hir::ClassUnicode::empty()));\n     |                ^^^^ method not found in `Translator`\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2567:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2567 |     let result = translator.visit_class_set_item_post(&class_set_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `pop` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2568:28\n     |\n118  | pub struct Translator {\n     | --------------------- method `pop` not found for this struct\n...\n2568 |     let frame = translator.pop().unwrap();\n     |                            ^^^ method not found in `Translator`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 20,
      "prompt_conds": [
        "// constraint: *ast matches ast::ClassSetItem::Literal(ref x) is true\n",
        "// constraint: *ast matches ast::ClassSetItem::Literal(ref x) is true\n",
        "// constraint: self.flags().unicode() is false\n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.class_literal_byte(x)? is Err/None\n"
      ],
      "input_infer": "class_set_item_literal_test_input: Literal | flags_unicode: false | pop: Some(ClassBytes) | class_literal_byte: Err; \nclass_set_item_literal_test_input: Literal | flags_unicode: false | pop: None | class_literal_byte: Err; \nclass_set_item_literal_test_input: Literal | flags_unicode: false | pop: Some(ClassUnicode) | class_literal_byte: Err; \nclass_set_item_literal_test_input: Literal | flags_unicode: false | pop: Some(ClassBytes) | class_literal_byte: None; \nclass_set_item_literal_test_input: Literal | flags_unicode: false | pop: None | class_literal_byte: None; \n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]),",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                "    let ast_item = ast::ClassSetItem::Literal(literal);",
                "    let result = translator.visit_class_set_item_post(&ast_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator = Translator { stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut translator = Translator { stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::InvalidUtf8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    let mut translator = Translator { stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    let mut translator = Translator { stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::InvalidUtf8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2541:55\n     |\n2541 |         stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]),\n     |                                                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:19\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:49\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:77\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2545:108\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2548:85\n     |\n2548 |     let mut translator = Translator { stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]), flags: Cell::new(Flags { unic...\n     |                                                                                     ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:19\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:49\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:77\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:108\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2547 |     let result = translator.visit_class_set_item_post(&ast_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2551 |     let result = translator.visit_class_set_item_post(&ast_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2541:55\n     |\n2541 |         stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]),\n     |                                                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:19\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:49\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:77\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2545:108\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2548:85\n     |\n2548 |     let mut translator = Translator { stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]), flags: Cell::new(Flags { unic...\n     |                                                                                     ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:19\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:49\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:77\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:108\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2547 |     let result = translator.visit_class_set_item_post(&ast_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2551 |     let result = translator.visit_class_set_item_post(&ast_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                "    let ast_item = ast::ClassSetItem::Literal(literal);",
                "    let result = translator.visit_class_set_item_post(&ast_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(result.unwrap_err().kind, ErrorKind::UnicodeNotAllowed);"
                ],
                [
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(translator.stack.borrow().len(), 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(result.unwrap_err().kind, ErrorKind::UnicodeNotAllowed);",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(translator.stack.borrow().len(), 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:19\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:49\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:77\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2545:108\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:19\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:49\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:77\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:108\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2547 |     let result = translator.visit_class_set_item_post(&ast_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2551 |     let result = translator.visit_class_set_item_post(&ast_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:19\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:49\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:77\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2545:108\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:19\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:49\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:77\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:108\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2547 |     let result = translator.visit_class_set_item_post(&ast_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2551 |     let result = translator.visit_class_set_item_post(&ast_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:19\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:49\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:77\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2545:108\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:19\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:49\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:77\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:108\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2547 |     let result = translator.visit_class_set_item_post(&ast_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2551 |     let result = translator.visit_class_set_item_post(&ast_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                "    let ast_item = ast::ClassSetItem::Literal(literal);",
                "    let result = translator.visit_class_set_item_post(&ast_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    assert_eq!(translator.stack.borrow().len(), 1);"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    let stack = translator.stack.borrow();",
                  "    assert_eq!(stack.len(), 1);"
                ],
                [
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    let stack = translator.stack.borrow();",
                  "    let frame = &stack[0];",
                  "    assert!(matches!(frame, HirFrame::ClassUnicode(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    assert_eq!(translator.stack.borrow().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    let stack = translator.stack.borrow();",
                  "    assert_eq!(stack.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    let mut translator = Translator {",
                  "    stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    let stack = translator.stack.borrow();",
                  "    let frame = &stack[0];",
                  "    assert!(matches!(frame, HirFrame::ClassUnicode(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2541:57\n     |\n2541 |         stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),\n     |                                                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:19\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:49\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:77\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2545:108\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2549:53\n     |\n2549 |     stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),\n     |                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:19\n     |\n2553 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:49\n     |\n2553 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:77\n     |\n2553 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2553:108\n     |\n2553 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2547 |     let result = translator.visit_class_set_item_post(&ast_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2541:57\n     |\n2541 |         stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),\n     |                                                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:19\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:49\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:77\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2545:108\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2549:53\n     |\n2549 |     stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),\n     |                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:19\n     |\n2553 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:49\n     |\n2553 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:77\n     |\n2553 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2553:108\n     |\n2553 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2547 |     let result = translator.visit_class_set_item_post(&ast_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2555 |     let result = translator.visit_class_set_item_post(&ast_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2541:57\n     |\n2541 |         stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),\n     |                                                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:19\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:49\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:77\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2545:108\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2549:53\n     |\n2549 |     stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),\n     |                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:19\n     |\n2553 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:49\n     |\n2553 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:77\n     |\n2553 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2553:108\n     |\n2553 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2547 |     let result = translator.visit_class_set_item_post(&ast_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2555 |     let result = translator.visit_class_set_item_post(&ast_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2541:57\n     |\n2541 |         stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),\n     |                                                         ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:19\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:49\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:77\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2545:108\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassUnicode`\n    --> regex-syntax/src/hir/translate.rs:2549:53\n     |\n2549 |     stack: RefCell::new(vec![HirFrame::ClassUnicode(ClassUnicode::empty())]),\n     |                                                     ^^^^^^^^^^^^ use of undeclared type `ClassUnicode`\n     |\nhelp: consider importing one of these structs\n     |\n2535 +    use ast::ClassUnicode;\n     |\n2535 +    use hir::ClassUnicode;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:19\n     |\n2553 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:49\n     |\n2553 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:77\n     |\n2553 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2553:108\n     |\n2553 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'A' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2547 |     let result = translator.visit_class_set_item_post(&ast_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2555 |     let result = translator.visit_class_set_item_post(&ast_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]),",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };",
                "    let ast_item = ast::ClassSetItem::Literal(literal);",
                "    let result = translator.visit_class_set_item_post(&ast_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator = Translator { stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut translator = Translator { stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(result.unwrap_err().kind, ErrorKind::UnicodeNotAllowed);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    let mut translator = Translator { stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    let mut translator = Translator { stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(result.unwrap_err().kind, ErrorKind::UnicodeNotAllowed);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2541:55\n     |\n2541 |         stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]),\n     |                                                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:19\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:49\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:77\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2545:108\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2548:85\n     |\n2548 |     let mut translator = Translator { stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]), flags: Cell::new(Flags { unic...\n     |                                                                                     ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:19\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:49\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:77\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:108\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2547 |     let result = translator.visit_class_set_item_post(&ast_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2551 |     let result = translator.visit_class_set_item_post(&ast_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2541:55\n     |\n2541 |         stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]),\n     |                                                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:19\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:49\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:77\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2545:108\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2548:85\n     |\n2548 |     let mut translator = Translator { stack: RefCell::new(vec![HirFrame::ClassBytes(ClassBytes::empty())]), flags: Cell::new(Flags { unic...\n     |                                                                                     ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:19\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:49\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:77\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:108\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2547 |     let result = translator.visit_class_set_item_post(&ast_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2551 |     let result = translator.visit_class_set_item_post(&ast_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };",
                "    let ast_item = ast::ClassSetItem::Literal(literal);",
                "    let result = translator.visit_class_set_item_post(&ast_item);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::UnicodeNotAllowed);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    let mut translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };",
                  "    let ast_item = ast::ClassSetItem::Literal(literal);",
                  "    let result = translator.visit_class_set_item_post(&ast_item);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::UnicodeNotAllowed);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:19\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:49\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:77\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2545:108\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:19\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:49\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:77\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:108\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2547 |     let result = translator.visit_class_set_item_post(&ast_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2551 |     let result = translator.visit_class_set_item_post(&ast_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:19\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:49\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2545:77\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2545:108\n     |\n2545 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Literal` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:19\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                   ^^^^^^^ not found in this scope\n     |\nhelp: consider importing one of these items\n     |\n2535 +    use ast::ClassSetItem::Literal;\n     |\n2535 +    use ast::Literal;\n     |\n2535 +    use hir::HirKind::Literal;\n     |\n2535 +    use hir::literal::Literal;\n     |\n       and 1 other candidate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:49\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                                                 ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2549:77\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                                                                             ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `LiteralKind`\n    --> regex-syntax/src/hir/translate.rs:2549:108\n     |\n2549 |     let literal = Literal { span: Span { start: Position { value: 0 }, end: Position { value: 1 } }, kind: LiteralKind::Character, c: 'B' };\n     |                                                                                                            ^^^^^^^^^^^ use of undeclared type `LiteralKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use ast::LiteralKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2547:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2547 |     let result = translator.visit_class_set_item_post(&ast_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `visit_class_set_item_post` found for struct `translate::Translator` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2551:29\n     |\n118  | pub struct Translator {\n     | --------------------- method `visit_class_set_item_post` not found for this struct\n...\n2551 |     let result = translator.visit_class_set_item_post(&ast_item);\n     |                             ^^^^^^^^^^^^^^^^^^^^^^^^^ method not found in `Translator`\n     |\n     = help: items from traits can only be used if the trait is implemented and in scope\nnote: `ast::visitor::Visitor` defines an item `visit_class_set_item_post`, perhaps you need to implement it\n    --> regex-syntax/src/ast/visitor.rs:33:1\n     |\n33   | pub trait Visitor {\n     | ^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 21,
      "prompt_conds": [
        "// constraint: *ast matches ast::ClassSetItem::Literal(ref x) is true\n",
        "// constraint: *ast matches ast::ClassSetItem::Literal(ref x) is true\n",
        "// constraint: self.flags().unicode() is false\n",
        "// constraint: self.pop().unwrap() is \n",
        "// constraint: self.class_literal_byte(x)? is Ok/Some\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "x.c: (0..=255) for valid byte characters, self.pop() != None, and self.flags.unicode() = false\n",
      "answers": [
        {
          "uses": [
            "use std::collections::HashMap;",
            "use std::cell::RefCell;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use std::cell::RefCell;",
                "    use std::collections::HashMap;",
                "",
                "    let mut stack: Vec<HirFrame> = Vec::new();",
                "    let flags = Flags {",
                "        unicode: Some(false),",
                "        ..Flags::default()",
                "    };",
                "    let trans = Translator {",
                "        stack: RefCell::new(stack),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"a\";",
                "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                "",
                "    let x = ast::Literal {",
                "        span: Span { start: Position::new(0), end: Position::new(1) },",
                "        kind: ast::LiteralKind::Character,",
                "        c: 'a',  // valid byte character within 0..=255",
                "    };",
                "",
                "    let ast = ast::ClassSetItem::Literal(Box::new(x));",
                "",
                "    translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                "    translator_instance.visit_class_set_item_post(&ast).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let flags = translator_instance.flags();",
                  "    assert_eq!(flags.unicode(), false);"
                ],
                [
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let flags = translator_instance.flags();",
                  "    assert_eq!(translator_instance.pop().unwrap().unwrap_class_bytes().ranges().len(), 1);"
                ],
                [
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let flags = translator_instance.flags();",
                  "    assert_eq!(translator_instance.pop().unwrap().unwrap_class_bytes().ranges()[0].start, 'a' as u8);"
                ],
                [
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let flags = translator_instance.flags();",
                  "    assert_eq!(translator_instance.pop().unwrap().unwrap_class_bytes().ranges()[0].end, 'a' as u8);"
                ],
                [
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let flags = translator_instance.flags();",
                  "    assert_eq!(translator_instance.visit_class_set_item_post(&ast).unwrap(), Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use std::cell::RefCell;",
                  "    use std::collections::HashMap;",
                  "",
                  "    let mut stack: Vec<HirFrame> = Vec::new();",
                  "    let flags = Flags {",
                  "        unicode: Some(false),",
                  "        ..Flags::default()",
                  "    };",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(stack),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"a\";",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let x = ast::Literal {",
                  "        span: Span { start: Position::new(0), end: Position::new(1) },",
                  "        kind: ast::LiteralKind::Character,",
                  "        c: 'a',  // valid byte character within 0..=255",
                  "    };",
                  "",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(x));",
                  "",
                  "    translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_instance.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let flags = translator_instance.flags();",
                  "    assert_eq!(flags.unicode(), false);",
                  "}"
                ],
                [
                  "{",
                  "    use std::cell::RefCell;",
                  "    use std::collections::HashMap;",
                  "",
                  "    let mut stack: Vec<HirFrame> = Vec::new();",
                  "    let flags = Flags {",
                  "        unicode: Some(false),",
                  "        ..Flags::default()",
                  "    };",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(stack),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"a\";",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let x = ast::Literal {",
                  "        span: Span { start: Position::new(0), end: Position::new(1) },",
                  "        kind: ast::LiteralKind::Character,",
                  "        c: 'a',  // valid byte character within 0..=255",
                  "    };",
                  "",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(x));",
                  "",
                  "    translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_instance.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let flags = translator_instance.flags();",
                  "    assert_eq!(translator_instance.pop().unwrap().unwrap_class_bytes().ranges().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    use std::cell::RefCell;",
                  "    use std::collections::HashMap;",
                  "",
                  "    let mut stack: Vec<HirFrame> = Vec::new();",
                  "    let flags = Flags {",
                  "        unicode: Some(false),",
                  "        ..Flags::default()",
                  "    };",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(stack),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"a\";",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let x = ast::Literal {",
                  "        span: Span { start: Position::new(0), end: Position::new(1) },",
                  "        kind: ast::LiteralKind::Character,",
                  "        c: 'a',  // valid byte character within 0..=255",
                  "    };",
                  "",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(x));",
                  "",
                  "    translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_instance.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let flags = translator_instance.flags();",
                  "    assert_eq!(translator_instance.pop().unwrap().unwrap_class_bytes().ranges()[0].start, 'a' as u8);",
                  "}"
                ],
                [
                  "{",
                  "    use std::cell::RefCell;",
                  "    use std::collections::HashMap;",
                  "",
                  "    let mut stack: Vec<HirFrame> = Vec::new();",
                  "    let flags = Flags {",
                  "        unicode: Some(false),",
                  "        ..Flags::default()",
                  "    };",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(stack),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"a\";",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let x = ast::Literal {",
                  "        span: Span { start: Position::new(0), end: Position::new(1) },",
                  "        kind: ast::LiteralKind::Character,",
                  "        c: 'a',  // valid byte character within 0..=255",
                  "    };",
                  "",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(x));",
                  "",
                  "    translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_instance.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let flags = translator_instance.flags();",
                  "    assert_eq!(translator_instance.pop().unwrap().unwrap_class_bytes().ranges()[0].end, 'a' as u8);",
                  "}"
                ],
                [
                  "{",
                  "    use std::cell::RefCell;",
                  "    use std::collections::HashMap;",
                  "",
                  "    let mut stack: Vec<HirFrame> = Vec::new();",
                  "    let flags = Flags {",
                  "        unicode: Some(false),",
                  "        ..Flags::default()",
                  "    };",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(stack),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"a\";",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    let x = ast::Literal {",
                  "        span: Span { start: Position::new(0), end: Position::new(1) },",
                  "        kind: ast::LiteralKind::Character,",
                  "        c: 'a',  // valid byte character within 0..=255",
                  "    };",
                  "",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(x));",
                  "",
                  "    translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "    translator_instance.visit_class_set_item_post(&ast).unwrap();",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let flags = translator_instance.flags();",
                  "    assert_eq!(translator_instance.visit_class_set_item_post(&ast).unwrap(), Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:29\n     |\n2557 |         span: Span { start: Position::new(0), end: Position::new(1) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:52\n     |\n2557 |         span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                                    ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2564:51\n     |\n2564 |     translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                   ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `std::collections::HashMap`\n    --> regex-syntax/src/hir/translate.rs:2541:9\n     |\n2541 |     use std::collections::HashMap;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Character` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:33\n     |\n2558 |         kind: ast::LiteralKind::Character,\n     |                                 ^^^^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Character` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:42\n     |\n2562 |     let ast = ast::ClassSetItem::Literal(Box::new(x));\n     |               -------------------------- ^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2562 |     let ast = ast::ClassSetItem::Literal(*Box::new(x));\n     |                                          +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:29\n     |\n2557 |         span: Span { start: Position::new(0), end: Position::new(1) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:52\n     |\n2557 |         span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                                    ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2564:51\n     |\n2564 |     translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                   ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `std::collections::HashMap`\n    --> regex-syntax/src/hir/translate.rs:2541:9\n     |\n2541 |     use std::collections::HashMap;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Character` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:33\n     |\n2558 |         kind: ast::LiteralKind::Character,\n     |                                 ^^^^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Character` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:42\n     |\n2562 |     let ast = ast::ClassSetItem::Literal(Box::new(x));\n     |               -------------------------- ^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2562 |     let ast = ast::ClassSetItem::Literal(*Box::new(x));\n     |                                          +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:29\n     |\n2557 |         span: Span { start: Position::new(0), end: Position::new(1) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:52\n     |\n2557 |         span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                                    ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2564:51\n     |\n2564 |     translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                   ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `std::collections::HashMap`\n    --> regex-syntax/src/hir/translate.rs:2541:9\n     |\n2541 |     use std::collections::HashMap;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Character` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:33\n     |\n2558 |         kind: ast::LiteralKind::Character,\n     |                                 ^^^^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Character` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:42\n     |\n2562 |     let ast = ast::ClassSetItem::Literal(Box::new(x));\n     |               -------------------------- ^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2562 |     let ast = ast::ClassSetItem::Literal(*Box::new(x));\n     |                                          +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:29\n     |\n2557 |         span: Span { start: Position::new(0), end: Position::new(1) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:52\n     |\n2557 |         span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                                    ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2564:51\n     |\n2564 |     translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                   ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `std::collections::HashMap`\n    --> regex-syntax/src/hir/translate.rs:2541:9\n     |\n2541 |     use std::collections::HashMap;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Character` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:33\n     |\n2558 |         kind: ast::LiteralKind::Character,\n     |                                 ^^^^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Character` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:42\n     |\n2562 |     let ast = ast::ClassSetItem::Literal(Box::new(x));\n     |               -------------------------- ^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2562 |     let ast = ast::ClassSetItem::Literal(*Box::new(x));\n     |                                          +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:29\n     |\n2557 |         span: Span { start: Position::new(0), end: Position::new(1) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2557:52\n     |\n2557 |         span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                                    ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2564:51\n     |\n2564 |     translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                   ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `std::collections::HashMap`\n    --> regex-syntax/src/hir/translate.rs:2541:9\n     |\n2541 |     use std::collections::HashMap;\n     |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Character` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2558:33\n     |\n2558 |         kind: ast::LiteralKind::Character,\n     |                                 ^^^^^^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Character` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:42\n     |\n2562 |     let ast = ast::ClassSetItem::Literal(Box::new(x));\n     |               -------------------------- ^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |               |\n     |               arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2562 |     let ast = ast::ClassSetItem::Literal(*Box::new(x));\n     |                                          +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2568:78\n     |\n2568 |     assert_eq!(translator_instance.visit_class_set_item_post(&ast).unwrap(), Ok(()));\n     |                                                                              ^^^^^^ expected `()`, found `Result<(), _>`\n     |\n     = note: expected unit type `()`\n                     found enum `std::result::Result<(), _>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut stack: Vec<HirFrame> = Vec::new();",
                "    let flags = Flags {",
                "        unicode: Some(false),",
                "        ..Flags::default()",
                "    };",
                "    let trans = Translator {",
                "        stack: RefCell::new(stack),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"boundary\";",
                "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                "",
                "    for &c in &[0u8, 255u8] {",
                "        let x = ast::Literal {",
                "            span: Span { start: Position::new(0), end: Position::new(1) },",
                "            kind: ast::LiteralKind::Byte,",
                "            c: c as char,  // testing boundary characters",
                "        };",
                "",
                "        let ast = ast::ClassSetItem::Literal(Box::new(x));",
                "        translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                "        translator_instance.visit_class_set_item_post(&ast).unwrap();",
                "    }",
                "}"
              ],
              "oracles": [
                [
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges().len(), 1);"
                ],
                [
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges()[0].start(), 0);"
                ],
                [
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges()[0].end(), 0);"
                ],
                [
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges().len(), 1);"
                ],
                [
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges()[0].start(), 255);"
                ],
                [
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges()[0].end(), 255);"
                ],
                [
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let frame = translator_instance.pop().unwrap();",
                  "    assert!(matches!(frame, HirFrame::ClassBytes(_)));"
                ],
                [
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let frame = translator_instance.pop().unwrap();",
                  "    let frame = translator_instance.pop().unwrap();",
                  "    assert!(matches!(frame, HirFrame::ClassBytes(_)));"
                ],
                [
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let frame = translator_instance.pop().unwrap();",
                  "    let frame = translator_instance.pop().unwrap();",
                  "    assert_eq!(translator_instance.flags().unicode(), false);"
                ],
                [
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let frame = translator_instance.pop().unwrap();",
                  "    let frame = translator_instance.pop().unwrap();",
                  "    assert!(translator_instance.class_literal_byte(&x).is_ok());"
                ],
                [
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let frame = translator_instance.pop().unwrap();",
                  "    let frame = translator_instance.pop().unwrap();",
                  "    assert_eq!(translator_instance.visit_class_set_item_post(&ast).unwrap(), Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut stack: Vec<HirFrame> = Vec::new();",
                  "    let flags = Flags {",
                  "        unicode: Some(false),",
                  "        ..Flags::default()",
                  "    };",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(stack),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"boundary\";",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    for &c in &[0u8, 255u8] {",
                  "        let x = ast::Literal {",
                  "            span: Span { start: Position::new(0), end: Position::new(1) },",
                  "            kind: ast::LiteralKind::Byte,",
                  "            c: c as char,  // testing boundary characters",
                  "        };",
                  "",
                  "        let ast = ast::ClassSetItem::Literal(Box::new(x));",
                  "        translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "        translator_instance.visit_class_set_item_post(&ast).unwrap();",
                  "    }",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut stack: Vec<HirFrame> = Vec::new();",
                  "    let flags = Flags {",
                  "        unicode: Some(false),",
                  "        ..Flags::default()",
                  "    };",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(stack),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"boundary\";",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    for &c in &[0u8, 255u8] {",
                  "        let x = ast::Literal {",
                  "            span: Span { start: Position::new(0), end: Position::new(1) },",
                  "            kind: ast::LiteralKind::Byte,",
                  "            c: c as char,  // testing boundary characters",
                  "        };",
                  "",
                  "        let ast = ast::ClassSetItem::Literal(Box::new(x));",
                  "        translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "        translator_instance.visit_class_set_item_post(&ast).unwrap();",
                  "    }",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges()[0].start(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut stack: Vec<HirFrame> = Vec::new();",
                  "    let flags = Flags {",
                  "        unicode: Some(false),",
                  "        ..Flags::default()",
                  "    };",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(stack),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"boundary\";",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    for &c in &[0u8, 255u8] {",
                  "        let x = ast::Literal {",
                  "            span: Span { start: Position::new(0), end: Position::new(1) },",
                  "            kind: ast::LiteralKind::Byte,",
                  "            c: c as char,  // testing boundary characters",
                  "        };",
                  "",
                  "        let ast = ast::ClassSetItem::Literal(Box::new(x));",
                  "        translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "        translator_instance.visit_class_set_item_post(&ast).unwrap();",
                  "    }",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges()[0].end(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let mut stack: Vec<HirFrame> = Vec::new();",
                  "    let flags = Flags {",
                  "        unicode: Some(false),",
                  "        ..Flags::default()",
                  "    };",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(stack),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"boundary\";",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    for &c in &[0u8, 255u8] {",
                  "        let x = ast::Literal {",
                  "            span: Span { start: Position::new(0), end: Position::new(1) },",
                  "            kind: ast::LiteralKind::Byte,",
                  "            c: c as char,  // testing boundary characters",
                  "        };",
                  "",
                  "        let ast = ast::ClassSetItem::Literal(Box::new(x));",
                  "        translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "        translator_instance.visit_class_set_item_post(&ast).unwrap();",
                  "    }",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut stack: Vec<HirFrame> = Vec::new();",
                  "    let flags = Flags {",
                  "        unicode: Some(false),",
                  "        ..Flags::default()",
                  "    };",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(stack),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"boundary\";",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    for &c in &[0u8, 255u8] {",
                  "        let x = ast::Literal {",
                  "            span: Span { start: Position::new(0), end: Position::new(1) },",
                  "            kind: ast::LiteralKind::Byte,",
                  "            c: c as char,  // testing boundary characters",
                  "        };",
                  "",
                  "        let ast = ast::ClassSetItem::Literal(Box::new(x));",
                  "        translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "        translator_instance.visit_class_set_item_post(&ast).unwrap();",
                  "    }",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges()[0].start(), 255);",
                  "}"
                ],
                [
                  "{",
                  "    let mut stack: Vec<HirFrame> = Vec::new();",
                  "    let flags = Flags {",
                  "        unicode: Some(false),",
                  "        ..Flags::default()",
                  "    };",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(stack),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"boundary\";",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    for &c in &[0u8, 255u8] {",
                  "        let x = ast::Literal {",
                  "            span: Span { start: Position::new(0), end: Position::new(1) },",
                  "            kind: ast::LiteralKind::Byte,",
                  "            c: c as char,  // testing boundary characters",
                  "        };",
                  "",
                  "        let ast = ast::ClassSetItem::Literal(Box::new(x));",
                  "        translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "        translator_instance.visit_class_set_item_post(&ast).unwrap();",
                  "    }",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    assert_eq!(cls.ranges()[0].end(), 255);",
                  "}"
                ],
                [
                  "{",
                  "    let mut stack: Vec<HirFrame> = Vec::new();",
                  "    let flags = Flags {",
                  "        unicode: Some(false),",
                  "        ..Flags::default()",
                  "    };",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(stack),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"boundary\";",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    for &c in &[0u8, 255u8] {",
                  "        let x = ast::Literal {",
                  "            span: Span { start: Position::new(0), end: Position::new(1) },",
                  "            kind: ast::LiteralKind::Byte,",
                  "            c: c as char,  // testing boundary characters",
                  "        };",
                  "",
                  "        let ast = ast::ClassSetItem::Literal(Box::new(x));",
                  "        translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "        translator_instance.visit_class_set_item_post(&ast).unwrap();",
                  "    }",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let frame = translator_instance.pop().unwrap();",
                  "    assert!(matches!(frame, HirFrame::ClassBytes(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let mut stack: Vec<HirFrame> = Vec::new();",
                  "    let flags = Flags {",
                  "        unicode: Some(false),",
                  "        ..Flags::default()",
                  "    };",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(stack),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"boundary\";",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    for &c in &[0u8, 255u8] {",
                  "        let x = ast::Literal {",
                  "            span: Span { start: Position::new(0), end: Position::new(1) },",
                  "            kind: ast::LiteralKind::Byte,",
                  "            c: c as char,  // testing boundary characters",
                  "        };",
                  "",
                  "        let ast = ast::ClassSetItem::Literal(Box::new(x));",
                  "        translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "        translator_instance.visit_class_set_item_post(&ast).unwrap();",
                  "    }",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let frame = translator_instance.pop().unwrap();",
                  "    let frame = translator_instance.pop().unwrap();",
                  "    assert!(matches!(frame, HirFrame::ClassBytes(_)));",
                  "}"
                ],
                [
                  "{",
                  "    let mut stack: Vec<HirFrame> = Vec::new();",
                  "    let flags = Flags {",
                  "        unicode: Some(false),",
                  "        ..Flags::default()",
                  "    };",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(stack),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"boundary\";",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    for &c in &[0u8, 255u8] {",
                  "        let x = ast::Literal {",
                  "            span: Span { start: Position::new(0), end: Position::new(1) },",
                  "            kind: ast::LiteralKind::Byte,",
                  "            c: c as char,  // testing boundary characters",
                  "        };",
                  "",
                  "        let ast = ast::ClassSetItem::Literal(Box::new(x));",
                  "        translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "        translator_instance.visit_class_set_item_post(&ast).unwrap();",
                  "    }",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let frame = translator_instance.pop().unwrap();",
                  "    let frame = translator_instance.pop().unwrap();",
                  "    assert_eq!(translator_instance.flags().unicode(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let mut stack: Vec<HirFrame> = Vec::new();",
                  "    let flags = Flags {",
                  "        unicode: Some(false),",
                  "        ..Flags::default()",
                  "    };",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(stack),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"boundary\";",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    for &c in &[0u8, 255u8] {",
                  "        let x = ast::Literal {",
                  "            span: Span { start: Position::new(0), end: Position::new(1) },",
                  "            kind: ast::LiteralKind::Byte,",
                  "            c: c as char,  // testing boundary characters",
                  "        };",
                  "",
                  "        let ast = ast::ClassSetItem::Literal(Box::new(x));",
                  "        translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "        translator_instance.visit_class_set_item_post(&ast).unwrap();",
                  "    }",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let frame = translator_instance.pop().unwrap();",
                  "    let frame = translator_instance.pop().unwrap();",
                  "    assert!(translator_instance.class_literal_byte(&x).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let mut stack: Vec<HirFrame> = Vec::new();",
                  "    let flags = Flags {",
                  "        unicode: Some(false),",
                  "        ..Flags::default()",
                  "    };",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(stack),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"boundary\";",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    for &c in &[0u8, 255u8] {",
                  "        let x = ast::Literal {",
                  "            span: Span { start: Position::new(0), end: Position::new(1) },",
                  "            kind: ast::LiteralKind::Byte,",
                  "            c: c as char,  // testing boundary characters",
                  "        };",
                  "",
                  "        let ast = ast::ClassSetItem::Literal(Box::new(x));",
                  "        translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "        translator_instance.visit_class_set_item_post(&ast).unwrap();",
                  "    }",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let frame = translator_instance.pop().unwrap();",
                  "    let frame = translator_instance.pop().unwrap();",
                  "    assert_eq!(translator_instance.visit_class_set_item_post(&ast).unwrap(), Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:33\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                 ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:56\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2561:55\n     |\n2561 |         translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:86\n     |\n2564 |     let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast...\n     |                                                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:109\n     |\n2564 | ... { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                                  ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:37\n     |\n2556 |             kind: ast::LiteralKind::Byte,\n     |                                     ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:46\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(Box::new(x));\n     |                   -------------------------- ^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(*Box::new(x));\n     |                                              +\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:153\n     |\n2564 | ...on::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:42\n     |\n2564 | ... = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2564 |     let ast = ast::ClassSetItem::Literal(*Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                          +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:33\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                 ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:56\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2561:55\n     |\n2561 |         translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:86\n     |\n2564 |     let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast...\n     |                                                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:109\n     |\n2564 | ... { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                                  ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:37\n     |\n2556 |             kind: ast::LiteralKind::Byte,\n     |                                     ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:46\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(Box::new(x));\n     |                   -------------------------- ^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(*Box::new(x));\n     |                                              +\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:153\n     |\n2564 | ...on::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:42\n     |\n2564 | ... = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2564 |     let ast = ast::ClassSetItem::Literal(*Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                          +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:33\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                 ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:56\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2561:55\n     |\n2561 |         translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:86\n     |\n2564 |     let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast...\n     |                                                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:109\n     |\n2564 | ... { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                                  ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:37\n     |\n2556 |             kind: ast::LiteralKind::Byte,\n     |                                     ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:46\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(Box::new(x));\n     |                   -------------------------- ^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(*Box::new(x));\n     |                                              +\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:153\n     |\n2564 | ...on::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:42\n     |\n2564 | ... = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2564 |     let ast = ast::ClassSetItem::Literal(*Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                          +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: out of range hex escape\n    --> regex-syntax/src/hir/translate.rs:2566:163\n     |\n2566 | ...w(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                              ^^^^ must be a character in the range [\\x00-\\x7f]\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:33\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                 ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:56\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2561:55\n     |\n2561 |         translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:86\n     |\n2564 |     let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast...\n     |                                                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:109\n     |\n2564 | ... { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                                  ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2566:86\n     |\n2566 |     let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast...\n     |                                                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2566:109\n     |\n2566 | ... { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                                  ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:37\n     |\n2556 |             kind: ast::LiteralKind::Byte,\n     |                                     ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:46\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(Box::new(x));\n     |                   -------------------------- ^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(*Box::new(x));\n     |                                              +\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:153\n     |\n2564 | ...on::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:42\n     |\n2564 | ... = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2564 |     let ast = ast::ClassSetItem::Literal(*Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                          +\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:153\n     |\n2566 | ...on::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:42\n     |\n2566 | ... = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2566 |     let ast = ast::ClassSetItem::Literal(*Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                          +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: out of range hex escape\n    --> regex-syntax/src/hir/translate.rs:2566:163\n     |\n2566 | ...w(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                              ^^^^ must be a character in the range [\\x00-\\x7f]\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:33\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                 ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:56\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2561:55\n     |\n2561 |         translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:86\n     |\n2564 |     let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast...\n     |                                                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:109\n     |\n2564 | ... { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                                  ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2566:86\n     |\n2566 |     let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast...\n     |                                                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2566:109\n     |\n2566 | ... { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                                  ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:37\n     |\n2556 |             kind: ast::LiteralKind::Byte,\n     |                                     ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:46\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(Box::new(x));\n     |                   -------------------------- ^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(*Box::new(x));\n     |                                              +\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:153\n     |\n2564 | ...on::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:42\n     |\n2564 | ... = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2564 |     let ast = ast::ClassSetItem::Literal(*Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                          +\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:153\n     |\n2566 | ...on::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:42\n     |\n2566 | ... = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2566 |     let ast = ast::ClassSetItem::Literal(*Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                          +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: out of range hex escape\n    --> regex-syntax/src/hir/translate.rs:2566:163\n     |\n2566 | ...w(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                              ^^^^ must be a character in the range [\\x00-\\x7f]\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:33\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                 ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:56\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2561:55\n     |\n2561 |         translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:86\n     |\n2564 |     let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast...\n     |                                                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:109\n     |\n2564 | ... { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                                  ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2566:86\n     |\n2566 |     let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast...\n     |                                                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2566:109\n     |\n2566 | ... { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                                  ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:37\n     |\n2556 |             kind: ast::LiteralKind::Byte,\n     |                                     ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:46\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(Box::new(x));\n     |                   -------------------------- ^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(*Box::new(x));\n     |                                              +\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:153\n     |\n2564 | ...on::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:42\n     |\n2564 | ... = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2564 |     let ast = ast::ClassSetItem::Literal(*Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                          +\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:153\n     |\n2566 | ...on::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:42\n     |\n2566 | ... = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2566 |     let ast = ast::ClassSetItem::Literal(*Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                          +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: out of range hex escape\n    --> regex-syntax/src/hir/translate.rs:2566:163\n     |\n2566 | ...w(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                              ^^^^ must be a character in the range [\\x00-\\x7f]\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:33\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                 ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:56\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2561:55\n     |\n2561 |         translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:86\n     |\n2564 |     let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast...\n     |                                                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:109\n     |\n2564 | ... { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                                  ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2566:86\n     |\n2566 |     let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast...\n     |                                                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2566:109\n     |\n2566 | ... { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                                  ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:37\n     |\n2556 |             kind: ast::LiteralKind::Byte,\n     |                                     ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:46\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(Box::new(x));\n     |                   -------------------------- ^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(*Box::new(x));\n     |                                              +\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:153\n     |\n2564 | ...on::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:42\n     |\n2564 | ... = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2564 |     let ast = ast::ClassSetItem::Literal(*Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                          +\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:153\n     |\n2566 | ...on::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:42\n     |\n2566 | ... = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2566 |     let ast = ast::ClassSetItem::Literal(*Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                          +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: out of range hex escape\n    --> regex-syntax/src/hir/translate.rs:2566:163\n     |\n2566 | ...w(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                              ^^^^ must be a character in the range [\\x00-\\x7f]\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:33\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                 ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:56\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2561:55\n     |\n2561 |         translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:86\n     |\n2564 |     let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast...\n     |                                                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:109\n     |\n2564 | ... { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                                  ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2566:86\n     |\n2566 |     let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast...\n     |                                                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2566:109\n     |\n2566 | ... { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                                  ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:37\n     |\n2556 |             kind: ast::LiteralKind::Byte,\n     |                                     ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:46\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(Box::new(x));\n     |                   -------------------------- ^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(*Box::new(x));\n     |                                              +\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:153\n     |\n2564 | ...on::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:42\n     |\n2564 | ... = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2564 |     let ast = ast::ClassSetItem::Literal(*Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                          +\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:153\n     |\n2566 | ...on::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:42\n     |\n2566 | ... = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2566 |     let ast = ast::ClassSetItem::Literal(*Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                          +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: out of range hex escape\n    --> regex-syntax/src/hir/translate.rs:2566:163\n     |\n2566 | ...w(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                              ^^^^ must be a character in the range [\\x00-\\x7f]\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:33\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                 ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:56\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2561:55\n     |\n2561 |         translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:86\n     |\n2564 |     let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast...\n     |                                                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:109\n     |\n2564 | ... { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                                  ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2566:86\n     |\n2566 |     let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast...\n     |                                                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2566:109\n     |\n2566 | ... { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                                  ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:37\n     |\n2556 |             kind: ast::LiteralKind::Byte,\n     |                                     ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:46\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(Box::new(x));\n     |                   -------------------------- ^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(*Box::new(x));\n     |                                              +\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:153\n     |\n2564 | ...on::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:42\n     |\n2564 | ... = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2564 |     let ast = ast::ClassSetItem::Literal(*Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                          +\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:153\n     |\n2566 | ...on::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:42\n     |\n2566 | ... = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2566 |     let ast = ast::ClassSetItem::Literal(*Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                          +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: out of range hex escape\n    --> regex-syntax/src/hir/translate.rs:2566:163\n     |\n2566 | ...w(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                              ^^^^ must be a character in the range [\\x00-\\x7f]\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:33\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                 ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:56\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2561:55\n     |\n2561 |         translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:86\n     |\n2564 |     let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast...\n     |                                                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:109\n     |\n2564 | ... { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                                  ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2566:86\n     |\n2566 |     let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast...\n     |                                                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2566:109\n     |\n2566 | ... { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                                  ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0425]: cannot find value `x` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:53\n     |\n2570 |     assert!(translator_instance.class_literal_byte(&x).is_ok());\n     |                                                     ^\n     |\nhelp: the binding `x` is available in a different scope in the same function\n    --> regex-syntax/src/hir/translate.rs:2554:13\n     |\n2554 |         let x = ast::Literal {\n     |             ^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:37\n     |\n2556 |             kind: ast::LiteralKind::Byte,\n     |                                     ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:46\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(Box::new(x));\n     |                   -------------------------- ^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(*Box::new(x));\n     |                                              +\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:153\n     |\n2564 | ...on::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:42\n     |\n2564 | ... = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2564 |     let ast = ast::ClassSetItem::Literal(*Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                          +\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:153\n     |\n2566 | ...on::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:42\n     |\n2566 | ... = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2566 |     let ast = ast::ClassSetItem::Literal(*Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                          +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: out of range hex escape\n    --> regex-syntax/src/hir/translate.rs:2566:163\n     |\n2566 | ...w(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                              ^^^^ must be a character in the range [\\x00-\\x7f]\n\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:33\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                 ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:56\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2561:55\n     |\n2561 |         translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:86\n     |\n2564 |     let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast...\n     |                                                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2564:109\n     |\n2564 | ... { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                                  ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2566:86\n     |\n2566 |     let ast = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast...\n     |                                                                                      ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2566:109\n     |\n2566 | ... { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                                  ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:37\n     |\n2556 |             kind: ast::LiteralKind::Byte,\n     |                                     ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:46\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(Box::new(x));\n     |                   -------------------------- ^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(*Box::new(x));\n     |                                              +\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2564:153\n     |\n2564 | ...on::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:42\n     |\n2564 | ... = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2564 |     let ast = ast::ClassSetItem::Literal(*Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\0' }));\n     |                                          +\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2566:153\n     |\n2566 | ...on::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                          ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2566:42\n     |\n2566 | ... = ast::ClassSetItem::Literal(Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }...\n     |       -------------------------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |       |\n     |       arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2566 |     let ast = ast::ClassSetItem::Literal(*Box::new(ast::Literal { span: Span { start: Position::new(0), end: Position::new(1) }, kind: ast::LiteralKind::Byte, c: '\\xFF' }));\n     |                                          +\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2570:78\n     |\n2570 |     assert_eq!(translator_instance.visit_class_set_item_post(&ast).unwrap(), Ok(()));\n     |                                                                              ^^^^^^ expected `()`, found `Result<(), _>`\n     |\n     = note: expected unit type `()`\n                     found enum `std::result::Result<(), _>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut stack: Vec<HirFrame> = Vec::new();",
                "    let flags = Flags {",
                "        unicode: Some(false),",
                "        ..Flags::default()",
                "    };",
                "    let trans = Translator {",
                "        stack: RefCell::new(stack),",
                "        flags: Cell::new(flags),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \"valid\";",
                "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                "",
                "    for c in b'a'..=b'z' {",
                "        let x = ast::Literal {",
                "            span: Span { start: Position::new(0), end: Position::new(1) },",
                "            kind: ast::LiteralKind::Byte,",
                "            c: c as char,  // valid byte character from a to z",
                "        };",
                "",
                "        let ast = ast::ClassSetItem::Literal(Box::new(x));",
                "        translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                "        translator_instance.visit_class_set_item_post(&ast).unwrap();",
                "    }",
                "}"
              ],
              "oracles": [
                [
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let byte = translator_instance.class_literal_byte(&x).unwrap();",
                  "    assert_eq!(cls.ranges().len(), 1);"
                ],
                [
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let byte = translator_instance.class_literal_byte(&x).unwrap();",
                  "    assert_eq!(cls.ranges()[0].start(), byte);"
                ],
                [
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let byte = translator_instance.class_literal_byte(&x).unwrap();",
                  "    assert_eq!(cls.ranges()[0].end(), byte);"
                ],
                [
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let byte = translator_instance.class_literal_byte(&x).unwrap();",
                  "    assert!(matches!(translator_instance.pop().unwrap(), HirFrame::ClassBytes(_)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let mut stack: Vec<HirFrame> = Vec::new();",
                  "    let flags = Flags {",
                  "        unicode: Some(false),",
                  "        ..Flags::default()",
                  "    };",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(stack),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"valid\";",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    for c in b'a'..=b'z' {",
                  "        let x = ast::Literal {",
                  "            span: Span { start: Position::new(0), end: Position::new(1) },",
                  "            kind: ast::LiteralKind::Byte,",
                  "            c: c as char,  // valid byte character from a to z",
                  "        };",
                  "",
                  "        let ast = ast::ClassSetItem::Literal(Box::new(x));",
                  "        translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "        translator_instance.visit_class_set_item_post(&ast).unwrap();",
                  "    }",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let byte = translator_instance.class_literal_byte(&x).unwrap();",
                  "    assert_eq!(cls.ranges().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let mut stack: Vec<HirFrame> = Vec::new();",
                  "    let flags = Flags {",
                  "        unicode: Some(false),",
                  "        ..Flags::default()",
                  "    };",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(stack),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"valid\";",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    for c in b'a'..=b'z' {",
                  "        let x = ast::Literal {",
                  "            span: Span { start: Position::new(0), end: Position::new(1) },",
                  "            kind: ast::LiteralKind::Byte,",
                  "            c: c as char,  // valid byte character from a to z",
                  "        };",
                  "",
                  "        let ast = ast::ClassSetItem::Literal(Box::new(x));",
                  "        translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "        translator_instance.visit_class_set_item_post(&ast).unwrap();",
                  "    }",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let byte = translator_instance.class_literal_byte(&x).unwrap();",
                  "    assert_eq!(cls.ranges()[0].start(), byte);",
                  "}"
                ],
                [
                  "{",
                  "    let mut stack: Vec<HirFrame> = Vec::new();",
                  "    let flags = Flags {",
                  "        unicode: Some(false),",
                  "        ..Flags::default()",
                  "    };",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(stack),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"valid\";",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    for c in b'a'..=b'z' {",
                  "        let x = ast::Literal {",
                  "            span: Span { start: Position::new(0), end: Position::new(1) },",
                  "            kind: ast::LiteralKind::Byte,",
                  "            c: c as char,  // valid byte character from a to z",
                  "        };",
                  "",
                  "        let ast = ast::ClassSetItem::Literal(Box::new(x));",
                  "        translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "        translator_instance.visit_class_set_item_post(&ast).unwrap();",
                  "    }",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let byte = translator_instance.class_literal_byte(&x).unwrap();",
                  "    assert_eq!(cls.ranges()[0].end(), byte);",
                  "}"
                ],
                [
                  "{",
                  "    let mut stack: Vec<HirFrame> = Vec::new();",
                  "    let flags = Flags {",
                  "        unicode: Some(false),",
                  "        ..Flags::default()",
                  "    };",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(stack),",
                  "        flags: Cell::new(flags),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \"valid\";",
                  "    let mut translator_instance = TranslatorI::new(&trans, pattern);",
                  "",
                  "    for c in b'a'..=b'z' {",
                  "        let x = ast::Literal {",
                  "            span: Span { start: Position::new(0), end: Position::new(1) },",
                  "            kind: ast::LiteralKind::Byte,",
                  "            c: c as char,  // valid byte character from a to z",
                  "        };",
                  "",
                  "        let ast = ast::ClassSetItem::Literal(Box::new(x));",
                  "        translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));",
                  "        translator_instance.visit_class_set_item_post(&ast).unwrap();",
                  "    }",
                  "    let mut cls = translator_instance.pop().unwrap().unwrap_class_bytes();",
                  "    let byte = translator_instance.class_literal_byte(&x).unwrap();",
                  "    assert!(matches!(translator_instance.pop().unwrap(), HirFrame::ClassBytes(_)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:33\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                 ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:56\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2561:55\n     |\n2561 |         translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0425]: cannot find value `x` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:56\n     |\n2565 |     let byte = translator_instance.class_literal_byte(&x).unwrap();\n     |                                                        ^\n     |\nhelp: the binding `x` is available in a different scope in the same function\n    --> regex-syntax/src/hir/translate.rs:2554:13\n     |\n2554 |         let x = ast::Literal {\n     |             ^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:37\n     |\n2556 |             kind: ast::LiteralKind::Byte,\n     |                                     ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:46\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(Box::new(x));\n     |                   -------------------------- ^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(*Box::new(x));\n     |                                              +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:33\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                 ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:56\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2561:55\n     |\n2561 |         translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0425]: cannot find value `x` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:56\n     |\n2565 |     let byte = translator_instance.class_literal_byte(&x).unwrap();\n     |                                                        ^\n     |\nhelp: the binding `x` is available in a different scope in the same function\n    --> regex-syntax/src/hir/translate.rs:2554:13\n     |\n2554 |         let x = ast::Literal {\n     |             ^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:37\n     |\n2556 |             kind: ast::LiteralKind::Byte,\n     |                                     ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:46\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(Box::new(x));\n     |                   -------------------------- ^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(*Box::new(x));\n     |                                              +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:33\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                 ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:56\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2561:55\n     |\n2561 |         translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0425]: cannot find value `x` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:56\n     |\n2565 |     let byte = translator_instance.class_literal_byte(&x).unwrap();\n     |                                                        ^\n     |\nhelp: the binding `x` is available in a different scope in the same function\n    --> regex-syntax/src/hir/translate.rs:2554:13\n     |\n2554 |         let x = ast::Literal {\n     |             ^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:37\n     |\n2556 |             kind: ast::LiteralKind::Byte,\n     |                                     ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:46\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(Box::new(x));\n     |                   -------------------------- ^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(*Box::new(x));\n     |                                              +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:33\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                 ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:56\n     |\n2555 |             span: Span { start: Position::new(0), end: Position::new(1) },\n     |                                                        ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `ClassBytes`\n    --> regex-syntax/src/hir/translate.rs:2561:55\n     |\n2561 |         translator_instance.push(HirFrame::ClassBytes(ClassBytes::empty()));\n     |                                                       ^^^^^^^^^^ use of undeclared type `ClassBytes`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use hir::ClassBytes;\n     |\n\nerror[E0425]: cannot find value `x` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:56\n     |\n2565 |     let byte = translator_instance.class_literal_byte(&x).unwrap();\n     |                                                        ^\n     |\nhelp: the binding `x` is available in a different scope in the same function\n    --> regex-syntax/src/hir/translate.rs:2554:13\n     |\n2554 |         let x = ast::Literal {\n     |             ^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `Byte` found for enum `LiteralKind` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2556:37\n     |\n2556 |             kind: ast::LiteralKind::Byte,\n     |                                     ^^^^ variant or associated item not found in `LiteralKind`\n     |\n    ::: regex-syntax/src/ast/mod.rs:638:1\n     |\n638  | pub enum LiteralKind {\n     | -------------------- variant or associated item `Byte` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:46\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(Box::new(x));\n     |                   -------------------------- ^^^^^^^^^^^ expected `Literal`, found `Box<Literal>`\n     |                   |\n     |                   arguments to this enum variant are incorrect\n     |\n     = note: expected struct `ast::Literal`\n                found struct `Box<ast::Literal>`\nnote: tuple variant defined here\n    --> regex-syntax/src/ast/mod.rs:971:5\n     |\n971  |     Literal(Literal),\n     |     ^^^^^^^\nhelp: consider unboxing the value\n     |\n2560 |         let ast = ast::ClassSetItem::Literal(*Box::new(x));\n     |                                              +\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 22,
      "prompt_conds": [
        "// constraint: *ast matches ast::ClassSetItem::Empty(_) is true\n",
        "// constraint: *ast matches ast::ClassSetItem::Empty(_) is true\n",
        "// expected return value/type: Ok(())\n"
      ],
      "input_infer": "test_input_ranges: ast::ClassSetItem::Empty(_)\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let mut translator_i = TranslatorI::new(&trans, \"\");",
                "",
                "    let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });",
                "    translator_i.visit_class_set_item_post(&empty_class_item).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"\");",
                  "    let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });",
                  "    assert_eq!(translator_i.visit_class_set_item_post(&empty_class_item), Ok(()));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"\");",
                  "",
                  "    let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });",
                  "    translator_i.visit_class_set_item_post(&empty_class_item).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: false };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"\");",
                  "    let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });",
                  "    assert_eq!(translator_i.visit_class_set_item_post(&empty_class_item), Ok(()));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:67\n     |\n2547 |     let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });\n     |                                                                   ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:94\n     |\n2547 |     let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });\n     |                                                                                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:67\n     |\n2551 |     let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });\n     |                                                                   ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2551:94\n     |\n2551 |     let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });\n     |                                                                                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let mut translator_i = TranslatorI::new(&trans, \"\");",
                "",
                "    let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });",
                "    translator_i.visit_class_set_item_post(&empty_class_item).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"\");",
                  "    let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });",
                  "    translator_i.visit_class_set_item_post(&empty_class_item).unwrap();",
                  "    assert!(translator_i.pop().is_none());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"\");",
                  "",
                  "    let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });",
                  "    translator_i.visit_class_set_item_post(&empty_class_item).unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"\");",
                  "    let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });",
                  "    translator_i.visit_class_set_item_post(&empty_class_item).unwrap();",
                  "    assert!(translator_i.pop().is_none());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:67\n     |\n2547 |     let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });\n     |                                                                   ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:94\n     |\n2547 |     let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });\n     |                                                                                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:67\n     |\n2555 |     let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });\n     |                                                                   ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:94\n     |\n2555 |     let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });\n     |                                                                                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let mut translator_i = TranslatorI::new(&trans, \"\");",
                "",
                "    let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });",
                "    translator_i.visit_class_set_item_post(&empty_class_item).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"\");",
                  "    let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });",
                  "    assert!(translator_i.trans().stack.borrow().is_empty());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"\");",
                  "    let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });",
                  "    translator_i.visit_class_set_item_post(&empty_class_item).unwrap();",
                  "    assert!(translator_i.trans().stack.borrow().is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"\");",
                  "",
                  "    let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });",
                  "    translator_i.visit_class_set_item_post(&empty_class_item).unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"\");",
                  "    let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });",
                  "    assert!(translator_i.trans().stack.borrow().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"\");",
                  "",
                  "    let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });",
                  "    translator_i.visit_class_set_item_post(&empty_class_item).unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let mut translator_i = TranslatorI::new(&trans, \"\");",
                  "    let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });",
                  "    translator_i.visit_class_set_item_post(&empty_class_item).unwrap();",
                  "    assert!(translator_i.trans().stack.borrow().is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:67\n     |\n2547 |     let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });\n     |                                                                   ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:94\n     |\n2547 |     let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });\n     |                                                                                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:67\n     |\n2555 |     let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });\n     |                                                                   ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:94\n     |\n2555 |     let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });\n     |                                                                                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:67\n     |\n2547 |     let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });\n     |                                                                   ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2547:94\n     |\n2547 |     let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });\n     |                                                                                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:67\n     |\n2555 |     let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });\n     |                                                                   ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0422]: cannot find struct, variant or union type `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:94\n     |\n2555 |     let empty_class_item = ast::ClassSetItem::Empty(Span { start: Position { byte: 0 }, end: Position { byte: 0 } });\n     |                                                                                              ^^^^^^^^ not found in this scope\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0422, E0432.\nFor more information about an error, try `rustc --explain E0422`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}