{
  "name": "regex_syntax::hir::interval::hir::interval::IntervalSet<I>::canonicalize",
  "name_with_impl": "regex_syntax::hir::interval::{impl#0}::canonicalize",
  "mod_info": {
    "name": "hir::interval",
    "loc": "regex-syntax/src/hir/mod.rs:26:1:26:14"
  },
  "visible": false,
  "loc": "regex-syntax/src/hir/interval.rs:273:5:298:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: self.is_canonical() is true\n"
      ],
      "input_infer": "Test input ranges: [1, 1], [2, 2], [3, 3], ..., [n-1, n-1], [n, n], where n is a small integer; [1, 10], [11, 20], [21, 30], where intervals are non-overlapping.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                "    struct SimpleInterval {",
                "        lower: u32,",
                "        upper: u32,",
                "    }",
                "    ",
                "    impl Interval for SimpleInterval {",
                "        type Bound = u32;",
                "",
                "        fn lower(&self) -> Self::Bound { self.lower }",
                "        fn upper(&self) -> Self::Bound { self.upper }",
                "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                "    }",
                "",
                "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 1 }]);",
                "",
                "    set.canonicalize();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 1 }]);",
                  "    assert!(set.intervals().len() == 1);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 1 }]);",
                  "    assert!(set.intervals()[0].lower() == 1);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 1 }]);",
                  "    assert!(set.intervals()[0].upper() == 1);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 1 }]);",
                  "    assert!(set.is_canonical());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "    struct SimpleInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "    ",
                  "    impl Interval for SimpleInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 1 }]);",
                  "",
                  "    set.canonicalize();",
                  "    let set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 1 }]);  ",
                  "    assert!(set.intervals().len() == 1);",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "    struct SimpleInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "    ",
                  "    impl Interval for SimpleInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 1 }]);",
                  "",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 1 }]);",
                  "    assert!(set.intervals()[0].lower() == 1);",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "    struct SimpleInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "    ",
                  "    impl Interval for SimpleInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 1 }]);",
                  "",
                  "    set.canonicalize();",
                  "    let set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 1 }]);  ",
                  "    assert!(set.intervals()[0].upper() == 1);",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "    struct SimpleInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "    ",
                  "    impl Interval for SimpleInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 1 }]);",
                  "",
                  "    set.canonicalize();",
                  "    let set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 1 }]);  ",
                  "    assert!(set.is_canonical());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:22\n    |\n508 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:22\n    |\n508 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:523:9\n    |\n523 |     let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 1 }]);\n    |         ----^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:22\n    |\n508 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:22\n    |\n508 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                "    struct SimpleInterval {",
                "        lower: u32,",
                "        upper: u32,",
                "    }",
                "    ",
                "    impl Interval for SimpleInterval {",
                "        type Bound = u32;",
                "",
                "        fn lower(&self) -> Self::Bound { self.lower }",
                "        fn upper(&self) -> Self::Bound { self.upper }",
                "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                "    }",
                "",
                "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 1 }, ",
                "                                         SimpleInterval { lower: 2, upper: 2 },",
                "                                         SimpleInterval { lower: 3, upper: 3 }]);",
                "",
                "    set.canonicalize();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 1 }, SimpleInterval { lower: 2, upper: 2 }, SimpleInterval { lower: 3, upper: 3 }]);",
                  "    assert_eq!(set.intervals(), &[SimpleInterval { lower: 1, upper: 1 }, SimpleInterval { lower: 2, upper: 2 }, SimpleInterval { lower: 3, upper: 3 }]);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 1 }, SimpleInterval { lower: 2, upper: 2 }, SimpleInterval { lower: 3, upper: 3 }]);",
                  "    assert!(set.is_canonical());"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 1 }, SimpleInterval { lower: 2, upper: 2 }, SimpleInterval { lower: 3, upper: 3 }]);",
                  "    set.push(SimpleInterval { lower: 4, upper: 4 });",
                  "    set.canonicalize();",
                  "    assert_eq!(set.intervals(), &[SimpleInterval { lower: 1, upper: 1 }, SimpleInterval { lower: 2, upper: 2 }, SimpleInterval { lower: 3, upper: 3 }, SimpleInterval { lower: 4, upper: 4 }]);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "    struct SimpleInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "    ",
                  "    impl Interval for SimpleInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 1 }, ",
                  "                                         SimpleInterval { lower: 2, upper: 2 },",
                  "                                         SimpleInterval { lower: 3, upper: 3 }]);",
                  "",
                  "    set.canonicalize();",
                  "    let set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 1 }, SimpleInterval { lower: 2, upper: 2 }, SimpleInterval { lower: 3, upper: 3 }]);  ",
                  "    assert_eq!(set.intervals(), &[SimpleInterval { lower: 1, upper: 1 }, SimpleInterval { lower: 2, upper: 2 }, SimpleInterval { lower: 3, upper: 3 }]);",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "    struct SimpleInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "    ",
                  "    impl Interval for SimpleInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 1 }, ",
                  "                                         SimpleInterval { lower: 2, upper: 2 },",
                  "                                         SimpleInterval { lower: 3, upper: 3 }]);",
                  "",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 1 }, SimpleInterval { lower: 2, upper: 2 }, SimpleInterval { lower: 3, upper: 3 }]);",
                  "    assert!(set.is_canonical());",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "    struct SimpleInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "    ",
                  "    impl Interval for SimpleInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 1 }, ",
                  "                                         SimpleInterval { lower: 2, upper: 2 },",
                  "                                         SimpleInterval { lower: 3, upper: 3 }]);",
                  "",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 1 }, SimpleInterval { lower: 2, upper: 2 }, SimpleInterval { lower: 3, upper: 3 }]);",
                  "    set.push(SimpleInterval { lower: 4, upper: 4 });",
                  "    set.canonicalize();",
                  "    assert_eq!(set.intervals(), &[SimpleInterval { lower: 1, upper: 1 }, SimpleInterval { lower: 2, upper: 2 }, SimpleInterval { lower: 3, upper: 3 }, SimpleInterval { lower: 4, upper: 4 }]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:22\n    |\n508 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:22\n    |\n508 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:525:9\n    |\n525 |     let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 1 }, SimpleInterval { lower: 2, upper: 2 }, SimpleInterval { lo...\n    |         ----^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:22\n    |\n508 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                "    struct SimpleInterval {",
                "        lower: u32,",
                "        upper: u32,",
                "    }",
                "    ",
                "    impl Interval for SimpleInterval {",
                "        type Bound = u32;",
                "",
                "        fn lower(&self) -> Self::Bound { self.lower }",
                "        fn upper(&self) -> Self::Bound { self.upper }",
                "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                "    }",
                "",
                "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 2 }, ",
                "                                         SimpleInterval { lower: 2, upper: 3 },",
                "                                         SimpleInterval { lower: 3, upper: 4 }]);",
                "",
                "    set.canonicalize();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 2 }, SimpleInterval { lower: 2, upper: 3 }, SimpleInterval { lower: 3, upper: 4 }]);",
                  "    assert!(set.is_canonical());"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 2 }, SimpleInterval { lower: 2, upper: 3 }, SimpleInterval { lower: 3, upper: 4 }]);",
                  "    assert_eq!(set.intervals().len(), 1);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 2 }, SimpleInterval { lower: 2, upper: 3 }, SimpleInterval { lower: 3, upper: 4 }]);",
                  "    assert_eq!(set.intervals()[0].lower(), 1);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 2 }, SimpleInterval { lower: 2, upper: 3 }, SimpleInterval { lower: 3, upper: 4 }]);",
                  "    assert_eq!(set.intervals()[0].upper(), 4);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "    struct SimpleInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "    ",
                  "    impl Interval for SimpleInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 2 }, ",
                  "                                         SimpleInterval { lower: 2, upper: 3 },",
                  "                                         SimpleInterval { lower: 3, upper: 4 }]);",
                  "",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 2 }, SimpleInterval { lower: 2, upper: 3 }, SimpleInterval { lower: 3, upper: 4 }]);",
                  "    assert!(set.is_canonical());",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "    struct SimpleInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "    ",
                  "    impl Interval for SimpleInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 2 }, ",
                  "                                         SimpleInterval { lower: 2, upper: 3 },",
                  "                                         SimpleInterval { lower: 3, upper: 4 }]);",
                  "",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 2 }, SimpleInterval { lower: 2, upper: 3 }, SimpleInterval { lower: 3, upper: 4 }]);",
                  "    assert_eq!(set.intervals().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "    struct SimpleInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "    ",
                  "    impl Interval for SimpleInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 2 }, ",
                  "                                         SimpleInterval { lower: 2, upper: 3 },",
                  "                                         SimpleInterval { lower: 3, upper: 4 }]);",
                  "",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 2 }, SimpleInterval { lower: 2, upper: 3 }, SimpleInterval { lower: 3, upper: 4 }]);",
                  "    assert_eq!(set.intervals()[0].lower(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "    struct SimpleInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "    ",
                  "    impl Interval for SimpleInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 2 }, ",
                  "                                         SimpleInterval { lower: 2, upper: 3 },",
                  "                                         SimpleInterval { lower: 3, upper: 4 }]);",
                  "",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 2 }, SimpleInterval { lower: 2, upper: 3 }, SimpleInterval { lower: 3, upper: 4 }]);",
                  "    assert_eq!(set.intervals()[0].upper(), 4);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:22\n    |\n508 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:525:9\n    |\n525 |     let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 2 }, SimpleInterval { lower: 2, upper: 3 }, SimpleInterval { lo...\n    |         ----^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:22\n    |\n508 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:525:9\n    |\n525 |     let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 2 }, SimpleInterval { lower: 2, upper: 3 }, SimpleInterval { lo...\n    |         ----^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:22\n    |\n508 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:525:9\n    |\n525 |     let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 2 }, SimpleInterval { lower: 2, upper: 3 }, SimpleInterval { lo...\n    |         ----^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:22\n    |\n508 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:525:9\n    |\n525 |     let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 2 }, SimpleInterval { lower: 2, upper: 3 }, SimpleInterval { lo...\n    |         ----^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                "    struct SimpleInterval {",
                "        lower: u32,",
                "        upper: u32,",
                "    }",
                "",
                "    impl Interval for SimpleInterval {",
                "        type Bound = u32;",
                "",
                "        fn lower(&self) -> Self::Bound { self.lower }",
                "        fn upper(&self) -> Self::Bound { self.upper }",
                "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                "    }",
                "",
                "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 },",
                "                                         SimpleInterval { lower: 11, upper: 20 },",
                "                                         SimpleInterval { lower: 21, upper: 30 }]);",
                "",
                "    set.canonicalize();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval { lower: 21, upper: 30 }]);",
                  "    assert_eq!(set.intervals().len(), 3);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval { lower: 21, upper: 30 }]);",
                  "    assert!(set.is_canonical());"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval { lower: 21, upper: 30 }]);",
                  "    set.canonicalize();",
                  "    assert_eq!(set.intervals().len(), 3);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval { lower: 21, upper: 30 }]);",
                  "    set.canonicalize();",
                  "    assert!(set.is_canonical());"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval { lower: 21, upper: 30 }]);",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 5, upper: 15 });",
                  "    set.canonicalize();",
                  "    assert_eq!(set.intervals().len(), 2);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval { lower: 21, upper: 30 }]);",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 5, upper: 15 });",
                  "    set.canonicalize();",
                  "    assert!(set.is_canonical());"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval { lower: 21, upper: 30 }]);",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 5, upper: 15 });",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 16, upper: 25 });",
                  "    set.canonicalize();",
                  "    assert_eq!(set.intervals().len(), 3);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval { lower: 21, upper: 30 }]);",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 5, upper: 15 });",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 16, upper: 25 });",
                  "    set.canonicalize();",
                  "    assert!(set.is_canonical());"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval { lower: 21, upper: 30 }]);",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 5, upper: 15 });",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 16, upper: 25 });",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 0, upper: 1 });",
                  "    set.canonicalize();",
                  "    assert_eq!(set.intervals().len(), 4);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval { lower: 21, upper: 30 }]);",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 5, upper: 15 });",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 16, upper: 25 });",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 0, upper: 1 });",
                  "    set.canonicalize();",
                  "    assert!(set.is_canonical());"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval { lower: 21, upper: 30 }]);",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 5, upper: 15 });",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 16, upper: 25 });",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 0, upper: 1 });",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 30, upper: 40 });",
                  "    set.canonicalize();",
                  "    assert_eq!(set.intervals().len(), 5);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval { lower: 21, upper: 30 }]);",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 5, upper: 15 });",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 16, upper: 25 });",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 0, upper: 1 });",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 30, upper: 40 });",
                  "    set.canonicalize();",
                  "    assert!(set.is_canonical());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "    struct SimpleInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "",
                  "    impl Interval for SimpleInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 },",
                  "                                         SimpleInterval { lower: 11, upper: 20 },",
                  "                                         SimpleInterval { lower: 21, upper: 30 }]);",
                  "",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval { lower: 21, upper: 30 }]);",
                  "    assert_eq!(set.intervals().len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "    struct SimpleInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "",
                  "    impl Interval for SimpleInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 },",
                  "                                         SimpleInterval { lower: 11, upper: 20 },",
                  "                                         SimpleInterval { lower: 21, upper: 30 }]);",
                  "",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval { lower: 21, upper: 30 }]);",
                  "    assert!(set.is_canonical());",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "    struct SimpleInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "",
                  "    impl Interval for SimpleInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 },",
                  "                                         SimpleInterval { lower: 11, upper: 20 },",
                  "                                         SimpleInterval { lower: 21, upper: 30 }]);",
                  "",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval { lower: 21, upper: 30 }]);",
                  "    set.canonicalize();",
                  "    assert_eq!(set.intervals().len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "    struct SimpleInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "",
                  "    impl Interval for SimpleInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 },",
                  "                                         SimpleInterval { lower: 11, upper: 20 },",
                  "                                         SimpleInterval { lower: 21, upper: 30 }]);",
                  "",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval { lower: 21, upper: 30 }]);",
                  "    set.canonicalize();",
                  "    assert!(set.is_canonical());",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "    struct SimpleInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "",
                  "    impl Interval for SimpleInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 },",
                  "                                         SimpleInterval { lower: 11, upper: 20 },",
                  "                                         SimpleInterval { lower: 21, upper: 30 }]);",
                  "",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval { lower: 21, upper: 30 }]);",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 5, upper: 15 });",
                  "    set.canonicalize();",
                  "    assert_eq!(set.intervals().len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "    struct SimpleInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "",
                  "    impl Interval for SimpleInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 },",
                  "                                         SimpleInterval { lower: 11, upper: 20 },",
                  "                                         SimpleInterval { lower: 21, upper: 30 }]);",
                  "",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval { lower: 21, upper: 30 }]);",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 5, upper: 15 });",
                  "    set.canonicalize();",
                  "    assert!(set.is_canonical());",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "    struct SimpleInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "",
                  "    impl Interval for SimpleInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 },",
                  "                                         SimpleInterval { lower: 11, upper: 20 },",
                  "                                         SimpleInterval { lower: 21, upper: 30 }]);",
                  "",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval { lower: 21, upper: 30 }]);",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 5, upper: 15 });",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 16, upper: 25 });",
                  "    set.canonicalize();",
                  "    assert_eq!(set.intervals().len(), 3);",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "    struct SimpleInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "",
                  "    impl Interval for SimpleInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 },",
                  "                                         SimpleInterval { lower: 11, upper: 20 },",
                  "                                         SimpleInterval { lower: 21, upper: 30 }]);",
                  "",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval { lower: 21, upper: 30 }]);",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 5, upper: 15 });",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 16, upper: 25 });",
                  "    set.canonicalize();",
                  "    assert!(set.is_canonical());",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "    struct SimpleInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "",
                  "    impl Interval for SimpleInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 },",
                  "                                         SimpleInterval { lower: 11, upper: 20 },",
                  "                                         SimpleInterval { lower: 21, upper: 30 }]);",
                  "",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval { lower: 21, upper: 30 }]);",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 5, upper: 15 });",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 16, upper: 25 });",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 0, upper: 1 });",
                  "    set.canonicalize();",
                  "    assert_eq!(set.intervals().len(), 4);",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "    struct SimpleInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "",
                  "    impl Interval for SimpleInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 },",
                  "                                         SimpleInterval { lower: 11, upper: 20 },",
                  "                                         SimpleInterval { lower: 21, upper: 30 }]);",
                  "",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval { lower: 21, upper: 30 }]);",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 5, upper: 15 });",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 16, upper: 25 });",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 0, upper: 1 });",
                  "    set.canonicalize();",
                  "    assert!(set.is_canonical());",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "    struct SimpleInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "",
                  "    impl Interval for SimpleInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 },",
                  "                                         SimpleInterval { lower: 11, upper: 20 },",
                  "                                         SimpleInterval { lower: 21, upper: 30 }]);",
                  "",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval { lower: 21, upper: 30 }]);",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 5, upper: 15 });",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 16, upper: 25 });",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 0, upper: 1 });",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 30, upper: 40 });",
                  "    set.canonicalize();",
                  "    assert_eq!(set.intervals().len(), 5);",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Clone, Copy, Debug, Default, PartialEq, Eq, PartialOrd, Ord)]",
                  "    struct SimpleInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "",
                  "    impl Interval for SimpleInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 == other.lower || other.upper + 1 == self.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 },",
                  "                                         SimpleInterval { lower: 11, upper: 20 },",
                  "                                         SimpleInterval { lower: 21, upper: 30 }]);",
                  "",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval { lower: 21, upper: 30 }]);",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 5, upper: 15 });",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 16, upper: 25 });",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 0, upper: 1 });",
                  "    set.canonicalize();",
                  "    set.push(SimpleInterval { lower: 30, upper: 40 });",
                  "    set.canonicalize();",
                  "    assert!(set.is_canonical());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:22\n    |\n508 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:525:9\n    |\n525 |     let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval {...\n    |         ----^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:22\n    |\n508 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:525:9\n    |\n525 |     let mut set = IntervalSet::new(vec![SimpleInterval { lower: 1, upper: 10 }, SimpleInterval { lower: 11, upper: 20 }, SimpleInterval {...\n    |         ----^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:22\n    |\n508 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:22\n    |\n508 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:22\n    |\n508 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:22\n    |\n508 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:22\n    |\n508 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:22\n    |\n508 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:22\n    |\n508 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:22\n    |\n508 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:22\n    |\n508 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:22\n    |\n508 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: self.is_canonical() is false\n",
        "// constraint: self.ranges.is_empty() is true\n"
      ],
      "input_infer": "self.is_canonical() = false, self.ranges.len() = 0; test input ranges: 1 to 1\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    #[derive(Clone, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                "    struct TestInterval {",
                "        lower: u32,",
                "        upper: u32,",
                "    }",
                "",
                "    impl Debug for TestInterval {",
                "        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                "            write!(f, \"TestInterval({}, {})\", self.lower, self.upper)",
                "        }",
                "    }",
                "",
                "    impl Interval for TestInterval {",
                "        type Bound = u32;",
                "",
                "        fn lower(&self) -> Self::Bound { self.lower }",
                "        fn upper(&self) -> Self::Bound { self.upper }",
                "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                "        fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 >= other.lower }",
                "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                "    }",
                "",
                "    let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                "    interval_set.canonicalize();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    assert!(interval_set.ranges.is_empty());"
                ],
                [
                  "    let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    assert!(!interval_set.is_canonical());"
                ],
                [
                  "    let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    assert!(interval_set.ranges.len() == 0);"
                ],
                [
                  "    let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    interval_set.canonicalize();",
                  "    assert!(interval_set.ranges.is_empty());"
                ],
                [
                  "    let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    interval_set.canonicalize();",
                  "    assert!(interval_set.is_canonical());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    #[derive(Clone, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "    struct TestInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "",
                  "    impl Debug for TestInterval {",
                  "        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "            write!(f, \"TestInterval({}, {})\", self.lower, self.upper)",
                  "        }",
                  "    }",
                  "",
                  "    impl Interval for TestInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 >= other.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    assert!(interval_set.ranges.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Clone, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "    struct TestInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "",
                  "    impl Debug for TestInterval {",
                  "        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "            write!(f, \"TestInterval({}, {})\", self.lower, self.upper)",
                  "        }",
                  "    }",
                  "",
                  "    impl Interval for TestInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 >= other.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    assert!(!interval_set.is_canonical());",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Clone, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "    struct TestInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "",
                  "    impl Debug for TestInterval {",
                  "        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "            write!(f, \"TestInterval({}, {})\", self.lower, self.upper)",
                  "        }",
                  "    }",
                  "",
                  "    impl Interval for TestInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 >= other.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    assert!(interval_set.ranges.len() == 0);",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Clone, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "    struct TestInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "",
                  "    impl Debug for TestInterval {",
                  "        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "            write!(f, \"TestInterval({}, {})\", self.lower, self.upper)",
                  "        }",
                  "    }",
                  "",
                  "    impl Interval for TestInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 >= other.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    interval_set.canonicalize();",
                  "    assert!(interval_set.ranges.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Clone, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "    struct TestInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "",
                  "    impl Debug for TestInterval {",
                  "        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "            write!(f, \"TestInterval({}, {})\", self.lower, self.upper)",
                  "        }",
                  "    }",
                  "",
                  "    impl Interval for TestInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 >= other.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    interval_set.canonicalize();",
                  "    assert!(interval_set.is_canonical());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0119]: conflicting implementations of trait `std::fmt::Debug` for type `TestInterval`\n   --> regex-syntax/src/hir/interval.rs:501:21\n    |\n501 |     #[derive(Clone, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]\n    |                     ^^^^^ conflicting implementation for `TestInterval`\n...\n507 |     impl Debug for TestInterval {\n    |     --------------------------- first implementation here\n    |\n    = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:513:23\n    |\n513 |     impl Interval for TestInterval {\n    |                       ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n502 +     #[derive(Copy)]\n503 |     struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:514:22\n    |\n514 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:528:9\n    |\n528 |     let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);\n    |         ----^^^^^^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nSome errors have detailed explanations: E0119, E0277.\nFor more information about an error, try `rustc --explain E0119`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0119]: conflicting implementations of trait `std::fmt::Debug` for type `TestInterval`\n   --> regex-syntax/src/hir/interval.rs:501:21\n    |\n501 |     #[derive(Clone, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]\n    |                     ^^^^^ conflicting implementation for `TestInterval`\n...\n507 |     impl Debug for TestInterval {\n    |     --------------------------- first implementation here\n    |\n    = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:513:23\n    |\n513 |     impl Interval for TestInterval {\n    |                       ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n502 +     #[derive(Copy)]\n503 |     struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:514:22\n    |\n514 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:528:9\n    |\n528 |     let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);\n    |         ----^^^^^^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nSome errors have detailed explanations: E0119, E0277.\nFor more information about an error, try `rustc --explain E0119`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0119]: conflicting implementations of trait `std::fmt::Debug` for type `TestInterval`\n   --> regex-syntax/src/hir/interval.rs:501:21\n    |\n501 |     #[derive(Clone, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]\n    |                     ^^^^^ conflicting implementation for `TestInterval`\n...\n507 |     impl Debug for TestInterval {\n    |     --------------------------- first implementation here\n    |\n    = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:513:23\n    |\n513 |     impl Interval for TestInterval {\n    |                       ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n502 +     #[derive(Copy)]\n503 |     struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:514:22\n    |\n514 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:528:9\n    |\n528 |     let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);\n    |         ----^^^^^^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nSome errors have detailed explanations: E0119, E0277.\nFor more information about an error, try `rustc --explain E0119`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0119]: conflicting implementations of trait `std::fmt::Debug` for type `TestInterval`\n   --> regex-syntax/src/hir/interval.rs:501:21\n    |\n501 |     #[derive(Clone, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]\n    |                     ^^^^^ conflicting implementation for `TestInterval`\n...\n507 |     impl Debug for TestInterval {\n    |     --------------------------- first implementation here\n    |\n    = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:513:23\n    |\n513 |     impl Interval for TestInterval {\n    |                       ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n502 +     #[derive(Copy)]\n503 |     struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:514:22\n    |\n514 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0119, E0277.\nFor more information about an error, try `rustc --explain E0119`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0119]: conflicting implementations of trait `std::fmt::Debug` for type `TestInterval`\n   --> regex-syntax/src/hir/interval.rs:501:21\n    |\n501 |     #[derive(Clone, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]\n    |                     ^^^^^ conflicting implementation for `TestInterval`\n...\n507 |     impl Debug for TestInterval {\n    |     --------------------------- first implementation here\n    |\n    = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:513:23\n    |\n513 |     impl Interval for TestInterval {\n    |                       ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n502 +     #[derive(Copy)]\n503 |     struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:514:22\n    |\n514 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0119, E0277.\nFor more information about an error, try `rustc --explain E0119`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    #[derive(Clone, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                "    struct TestInterval {",
                "        lower: u32,",
                "        upper: u32,",
                "    }",
                "",
                "    impl Debug for TestInterval {",
                "        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                "            write!(f, \"TestInterval({}, {})\", self.lower, self.upper)",
                "        }",
                "    }",
                "",
                "    impl Interval for TestInterval {",
                "        type Bound = u32;",
                "",
                "        fn lower(&self) -> Self::Bound { self.lower }",
                "        fn upper(&self) -> Self::Bound { self.upper }",
                "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                "        fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 >= other.lower }",
                "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                "    }",
                "",
                "    let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
                "        TestInterval { lower: 3, upper: 5 },",
                "        TestInterval { lower: 1, upper: 2 },",
                "    ]);",
                "    interval_set.canonicalize();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    assert!(interval_set.is_canonical() == false);"
                ],
                [
                  "    let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    assert!(interval_set.intervals().is_empty());"
                ],
                [
                  "    let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    assert!(std::panic::catch_unwind(|| interval_set.canonicalize()).is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    #[derive(Clone, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "    struct TestInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "",
                  "    impl Debug for TestInterval {",
                  "        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "            write!(f, \"TestInterval({}, {})\", self.lower, self.upper)",
                  "        }",
                  "    }",
                  "",
                  "    impl Interval for TestInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 >= other.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
                  "        TestInterval { lower: 3, upper: 5 },",
                  "        TestInterval { lower: 1, upper: 2 },",
                  "    ]);",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    assert!(interval_set.is_canonical() == false);",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Clone, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "    struct TestInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "",
                  "    impl Debug for TestInterval {",
                  "        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "            write!(f, \"TestInterval({}, {})\", self.lower, self.upper)",
                  "        }",
                  "    }",
                  "",
                  "    impl Interval for TestInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 >= other.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
                  "        TestInterval { lower: 3, upper: 5 },",
                  "        TestInterval { lower: 1, upper: 2 },",
                  "    ]);",
                  "    interval_set.canonicalize();",
                  "    let interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);  ",
                  "    assert!(interval_set.intervals().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    #[derive(Clone, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "    struct TestInterval {",
                  "        lower: u32,",
                  "        upper: u32,",
                  "    }",
                  "",
                  "    impl Debug for TestInterval {",
                  "        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "            write!(f, \"TestInterval({}, {})\", self.lower, self.upper)",
                  "        }",
                  "    }",
                  "",
                  "    impl Interval for TestInterval {",
                  "        type Bound = u32;",
                  "",
                  "        fn lower(&self) -> Self::Bound { self.lower }",
                  "        fn upper(&self) -> Self::Bound { self.upper }",
                  "        fn set_lower(&mut self, bound: Self::Bound) { self.lower = bound; }",
                  "        fn set_upper(&mut self, bound: Self::Bound) { self.upper = bound; }",
                  "        fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "        fn is_contiguous(&self, other: &Self) -> bool { self.upper + 1 >= other.lower }",
                  "        fn is_intersection_empty(&self, other: &Self) -> bool { self.upper < other.lower || self.lower > other.upper }",
                  "        fn is_subset(&self, other: &Self) -> bool { self.lower >= other.lower && self.upper <= other.upper }",
                  "    }",
                  "",
                  "    let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![",
                  "        TestInterval { lower: 3, upper: 5 },",
                  "        TestInterval { lower: 1, upper: 2 },",
                  "    ]);",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);",
                  "    assert!(std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| interval_set.canonicalize())).is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0119]: conflicting implementations of trait `std::fmt::Debug` for type `TestInterval`\n   --> regex-syntax/src/hir/interval.rs:502:21\n    |\n502 |     #[derive(Clone, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]\n    |                     ^^^^^ conflicting implementation for `TestInterval`\n...\n508 |     impl Debug for TestInterval {\n    |     --------------------------- first implementation here\n    |\n    = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:514:23\n    |\n514 |     impl Interval for TestInterval {\n    |                       ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n503 +     #[derive(Copy)]\n504 |     struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:515:22\n    |\n515 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:532:9\n    |\n532 |     let mut interval_set: IntervalSet<TestInterval> = IntervalSet::new(vec![]);\n    |         ----^^^^^^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nSome errors have detailed explanations: E0119, E0277.\nFor more information about an error, try `rustc --explain E0119`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0119]: conflicting implementations of trait `std::fmt::Debug` for type `TestInterval`\n   --> regex-syntax/src/hir/interval.rs:502:21\n    |\n502 |     #[derive(Clone, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]\n    |                     ^^^^^ conflicting implementation for `TestInterval`\n...\n508 |     impl Debug for TestInterval {\n    |     --------------------------- first implementation here\n    |\n    = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:514:23\n    |\n514 |     impl Interval for TestInterval {\n    |                       ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n503 +     #[derive(Copy)]\n504 |     struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:515:22\n    |\n515 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0119, E0277.\nFor more information about an error, try `rustc --explain E0119`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0119]: conflicting implementations of trait `std::fmt::Debug` for type `TestInterval`\n   --> regex-syntax/src/hir/interval.rs:502:21\n    |\n502 |     #[derive(Clone, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]\n    |                     ^^^^^ conflicting implementation for `TestInterval`\n...\n508 |     impl Debug for TestInterval {\n    |     --------------------------- first implementation here\n    |\n    = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:514:23\n    |\n514 |     impl Interval for TestInterval {\n    |                       ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n503 +     #[derive(Copy)]\n504 |     struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:515:22\n    |\n515 |         type Bound = u32;\n    |                      ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0119, E0277.\nFor more information about an error, try `rustc --explain E0119`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: self.is_canonical() is false\n",
        "// constraint: self.ranges.is_empty() is false\n",
        "// constraint: oldi in 0..drain_end is true\n",
        "// constraint: self.ranges.len() > drain_end is true\n",
        "// constraint: self.ranges.split_last_mut().unwrap() is \n",
        "// constraint: let Some(union) = last.union(&rest[oldi]) is true\n",
        "// constraint: self.ranges[oldi] is \n",
        "// constraint: oldi in 0..drain_end is false\n",
        "// constraint: self.ranges.drain(..drain_end) is \n"
      ],
      "input_infer": "self.ranges.len() > 0 && self.ranges.len() <= 10 && self.is_canonical() == false && oldi < self.ranges.len() && self.ranges.len() > self.ranges.len() - 1 && let Some(union) is true;\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4), SimpleBound(6)]);",
                "    set.ranges.push(SimpleBound(5)); // Adding an overlapping range",
                "    set.canonicalize();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut ranges = vec![SimpleBound(1), SimpleBound(2), SimpleBound(4), SimpleBound(6)];",
                  "    assert!(set.ranges == ranges);"
                ],
                [
                  "    let mut ranges = vec![SimpleBound(1), SimpleBound(2), SimpleBound(4), SimpleBound(6)];",
                  "    assert!(set.ranges.len() == 4);"
                ],
                [
                  "    let mut ranges = vec![SimpleBound(1), SimpleBound(2), SimpleBound(4), SimpleBound(6)];",
                  "    assert!(set.is_canonical() == true);"
                ],
                [
                  "    let mut ranges = vec![SimpleBound(1), SimpleBound(2), SimpleBound(4), SimpleBound(6)];",
                  "    assert!(set.ranges.contains(&SimpleBound(5)) == false);"
                ],
                [
                  "    let mut ranges = vec![SimpleBound(1), SimpleBound(2), SimpleBound(4), SimpleBound(6)];",
                  "    assert!(set.ranges.iter().all(|x| x.lower().0 < x.upper().0));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new(intervals: Vec<SimpleBound>) -> Self {",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4), SimpleBound(6)]);",
                  "    set.ranges.push(SimpleBound(5)); // Adding an overlapping range",
                  "    set.canonicalize();",
                  "    let mut ranges = vec![SimpleBound(1), SimpleBound(2), SimpleBound(4), SimpleBound(6)];",
                  "    assert!(set.ranges == ranges);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new_from_vec(intervals: Vec<SimpleBound>) -> Self {",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4), SimpleBound(6)]);",
                  "    set.ranges.push(SimpleBound(5)); // Adding an overlapping range",
                  "    set.canonicalize();",
                  "    let mut ranges = vec![SimpleBound(1), SimpleBound(2), SimpleBound(4), SimpleBound(6)];",
                  "    assert!(set.ranges.len() == 4);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new(intervals: Vec<SimpleBound>) -> Self {",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4), SimpleBound(6)]);",
                  "    set.ranges.push(SimpleBound(5)); // Adding an overlapping range",
                  "    set.canonicalize();",
                  "    let mut ranges = vec![SimpleBound(1), SimpleBound(2), SimpleBound(4), SimpleBound(6)];",
                  "    assert!(set.is_canonical() == true);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new(intervals: Vec<SimpleBound>) -> Self {  ",
                  "        IntervalSet::<SimpleBound>::new(intervals)  ",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4), SimpleBound(6)]);",
                  "    set.ranges.push(SimpleBound(5)); // Adding an overlapping range",
                  "    set.canonicalize();",
                  "    let mut ranges = vec![SimpleBound(1), SimpleBound(2), SimpleBound(4), SimpleBound(6)];",
                  "    assert!(set.ranges.contains(&SimpleBound(5)) == false);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new_from_bounds(intervals: Vec<SimpleBound>) -> Self {  ",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4), SimpleBound(6)]);",
                  "    set.ranges.push(SimpleBound(5)); // Adding an overlapping range",
                  "    set.canonicalize();",
                  "    let mut _ranges = vec![SimpleBound(1), SimpleBound(2), SimpleBound(4), SimpleBound(6)];  ",
                  "    assert!(set.ranges.iter().all(|x| x.lower().0 < x.upper().0));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:521:18\n    |\n521 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nerror[E0592]: duplicate definitions with name `new`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `new`\n...\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ----------------------------------------------- other definition for `new`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:564:32\n    |\n564 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4), SimpleBound(6)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:732:42\n    |\n732 |         ClassUnicode { set: IntervalSet::new(ranges) }\n    |                                          ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:925:40\n    |\n925 |         ClassBytes { set: IntervalSet::new(ranges) }\n    |                                        ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0034, E0277, E0592.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:521:18\n    |\n521 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: unused variable: `ranges`\n   --> regex-syntax/src/hir/interval.rs:567:13\n    |\n567 |     let mut ranges = vec![SimpleBound(1), SimpleBound(2), SimpleBound(4), SimpleBound(6)];\n    |             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_ranges`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:567:9\n    |\n567 |     let mut ranges = vec![SimpleBound(1), SimpleBound(2), SimpleBound(4), SimpleBound(6)];\n    |         ----^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 19 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 19 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:521:18\n    |\n521 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nerror[E0592]: duplicate definitions with name `new`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `new`\n...\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ----------------------------------------------- other definition for `new`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:564:32\n    |\n564 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4), SimpleBound(6)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:732:42\n    |\n732 |         ClassUnicode { set: IntervalSet::new(ranges) }\n    |                                          ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:925:40\n    |\n925 |         ClassBytes { set: IntervalSet::new(ranges) }\n    |                                        ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0034, E0277, E0592.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: expected `;`, found `IntervalSet`\n   --> regex-syntax/src/hir/interval.rs:561:51\n    |\n561 |         IntervalSet::<SimpleBound>::new(intervals)  \n    |                                                   ^ help: add `;` here\n562 |         IntervalSet { ranges: intervals }\n    |         ----------- unexpected token\n\nerror: unexpected token\n   --> regex-syntax/src/hir/interval.rs:562:9\n    |\n562 |         IntervalSet { ranges: intervals }\n    |         ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/hir/interval.rs:493:8\n    |\n493 |    use super::*;\n    |        ^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0425]: cannot find function `test_canonicalize_17` in this scope\n   --> regex-syntax/src/hir/interval.rs:499:1\n    |\n499 | / fn test_canonicalize_17()\n500 | | {\n501 | | #[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]\n502 | | struct SimpleBound(i32);\n...   |\n569 | |     assert!(set.ranges.contains(&SimpleBound(5)) == false);\n570 | | }\n    | |_^ not found in this scope\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:521:18\n    |\n521 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                "    set.ranges.push(SimpleBound(2)); // This creates the need for canonicalization",
                "    set.canonicalize();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    assert!(!set.is_canonical());"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    assert!(!set.ranges.is_empty());"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    let drain_end = set.ranges.len();",
                  "    assert!(set.ranges.len() > drain_end);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    let drain_end = set.ranges.len();",
                  "    assert!(set.ranges.split_last_mut().is_ok());"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    let drain_end = set.ranges.len();",
                  "    assert!(set.ranges[0].union(&set.ranges[1]).is_some());"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    let drain_end = set.ranges.len();",
                  "    assert!(drain_end > 0);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    let drain_end = set.ranges.len();",
                  "    set.canonicalize();",
                  "    assert!(set.is_canonical());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new(intervals: Vec<SimpleBound>) -> Self {",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    set.ranges.push(SimpleBound(2)); // This creates the need for canonicalization",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    assert!(!set.is_canonical());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new(intervals: Vec<SimpleBound>) -> Self {",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    set.ranges.push(SimpleBound(2)); // This creates the need for canonicalization",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    assert!(!set.ranges.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new(intervals: Vec<SimpleBound>) -> Self {",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    set.ranges.push(SimpleBound(2)); // This creates the need for canonicalization",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    let drain_end = set.ranges.len();",
                  "    assert!(set.ranges.len() > drain_end);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new_from_bounds(intervals: Vec<SimpleBound>) -> Self {  ",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    set.ranges.push(SimpleBound(2)); // This creates the need for canonicalization",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    let drain_end = set.ranges.len();",
                  "    assert!(set.ranges.split_last_mut().is_ok());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new(intervals: Vec<SimpleBound>) -> Self {",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    set.ranges.push(SimpleBound(2)); // This creates the need for canonicalization",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    let drain_end = set.ranges.len();",
                  "    assert!(set.ranges[0].union(&set.ranges[1]).is_some());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new(intervals: Vec<SimpleBound>) -> Self {",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    set.ranges.push(SimpleBound(2)); // This creates the need for canonicalization",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    let drain_end = set.ranges.len();",
                  "    assert!(drain_end > 0);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new(intervals: Vec<SimpleBound>) -> Self {",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    set.ranges.push(SimpleBound(2)); // This creates the need for canonicalization",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    let drain_end = set.ranges.len();",
                  "    set.canonicalize();",
                  "    assert!(set.is_canonical());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:521:18\n    |\n521 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nerror[E0592]: duplicate definitions with name `new`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `new`\n...\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ----------------------------------------------- other definition for `new`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:564:32\n    |\n564 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:567:32\n    |\n567 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:732:42\n    |\n732 |         ClassUnicode { set: IntervalSet::new(ranges) }\n    |                                          ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:925:40\n    |\n925 |         ClassBytes { set: IntervalSet::new(ranges) }\n    |                                        ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0034, E0277, E0592.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:521:18\n    |\n521 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nerror[E0592]: duplicate definitions with name `new`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `new`\n...\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ----------------------------------------------- other definition for `new`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:564:32\n    |\n564 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:567:32\n    |\n567 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:732:42\n    |\n732 |         ClassUnicode { set: IntervalSet::new(ranges) }\n    |                                          ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:925:40\n    |\n925 |         ClassBytes { set: IntervalSet::new(ranges) }\n    |                                        ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0034, E0277, E0592.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:521:18\n    |\n521 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nerror[E0592]: duplicate definitions with name `new`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `new`\n...\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ----------------------------------------------- other definition for `new`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:564:32\n    |\n564 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:567:32\n    |\n567 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:732:42\n    |\n732 |         ClassUnicode { set: IntervalSet::new(ranges) }\n    |                                          ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:925:40\n    |\n925 |         ClassBytes { set: IntervalSet::new(ranges) }\n    |                                        ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0034, E0277, E0592.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:521:18\n    |\n521 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no method named `is_ok` found for enum `Option` in the current scope\n   --> regex-syntax/src/hir/interval.rs:569:41\n    |\n569 |     assert!(set.ranges.split_last_mut().is_ok());\n    |                                         ^^^^^ method not found in `Option<(&mut SimpleBound, &mut [SimpleBound])>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:521:18\n    |\n521 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nerror[E0592]: duplicate definitions with name `new`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `new`\n...\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ----------------------------------------------- other definition for `new`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:564:32\n    |\n564 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:567:32\n    |\n567 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:732:42\n    |\n732 |         ClassUnicode { set: IntervalSet::new(ranges) }\n    |                                          ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:925:40\n    |\n925 |         ClassBytes { set: IntervalSet::new(ranges) }\n    |                                        ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0034, E0277, E0592.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:521:18\n    |\n521 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nerror[E0592]: duplicate definitions with name `new`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `new`\n...\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ----------------------------------------------- other definition for `new`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:564:32\n    |\n564 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:567:32\n    |\n567 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:732:42\n    |\n732 |         ClassUnicode { set: IntervalSet::new(ranges) }\n    |                                          ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:925:40\n    |\n925 |         ClassBytes { set: IntervalSet::new(ranges) }\n    |                                        ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0034, E0277, E0592.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:521:18\n    |\n521 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nerror[E0592]: duplicate definitions with name `new`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `new`\n...\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ----------------------------------------------- other definition for `new`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:564:32\n    |\n564 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:567:32\n    |\n567 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:732:42\n    |\n732 |         ClassUnicode { set: IntervalSet::new(ranges) }\n    |                                          ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:925:40\n    |\n925 |         ClassBytes { set: IntervalSet::new(ranges) }\n    |                                        ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0034, E0277, E0592.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                "    set.ranges.push(SimpleBound(2)); // Should merge into 1..5",
                "    set.canonicalize();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    assert_eq!(set.ranges.len(), 4);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    assert_eq!(set.ranges, vec![SimpleBound(1), SimpleBound(2), SimpleBound(4), SimpleBound(5)]);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    let mut set2 = IntervalSet::new(vec![SimpleBound(3)]);",
                  "    set2.canonicalize();",
                  "    assert_eq!(set2.ranges.len(), 1);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    let mut set2 = IntervalSet::new(vec![SimpleBound(3)]);",
                  "    set2.canonicalize();",
                  "    assert_eq!(set2.ranges, vec![SimpleBound(3)]);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    let mut set2 = IntervalSet::new(vec![SimpleBound(3)]);",
                  "    set2.canonicalize();",
                  "    let mut set3 = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4)]);",
                  "    set3.canonicalize();",
                  "    assert_eq!(set3.ranges.len(), 2);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    let mut set2 = IntervalSet::new(vec![SimpleBound(3)]);",
                  "    set2.canonicalize();",
                  "    let mut set3 = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4)]);",
                  "    set3.canonicalize();",
                  "    assert_eq!(set3.ranges, vec![SimpleBound(1), SimpleBound(4)]);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    let mut set2 = IntervalSet::new(vec![SimpleBound(3)]);",
                  "    set2.canonicalize();",
                  "    let mut set3 = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4)]);",
                  "    set3.canonicalize();",
                  "    let mut set4 = IntervalSet::new(vec![SimpleBound(1)]);",
                  "    set4.ranges.push(SimpleBound(1));",
                  "    set4.canonicalize();",
                  "    assert_eq!(set4.ranges.len(), 1);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    let mut set2 = IntervalSet::new(vec![SimpleBound(3)]);",
                  "    set2.canonicalize();",
                  "    let mut set3 = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4)]);",
                  "    set3.canonicalize();",
                  "    let mut set4 = IntervalSet::new(vec![SimpleBound(1)]);",
                  "    set4.ranges.push(SimpleBound(1));",
                  "    set4.canonicalize();",
                  "    assert_eq!(set4.ranges, vec![SimpleBound(1)]);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    let mut set2 = IntervalSet::new(vec![SimpleBound(3)]);",
                  "    set2.canonicalize();",
                  "    let mut set3 = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4)]);",
                  "    set3.canonicalize();",
                  "    let mut set4 = IntervalSet::new(vec![SimpleBound(1)]);",
                  "    set4.ranges.push(SimpleBound(1));",
                  "    set4.canonicalize();",
                  "    let mut set5 = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(3)]);",
                  "    set5.canonicalize();",
                  "    assert_eq!(set5.ranges.len(), 1);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    let mut set2 = IntervalSet::new(vec![SimpleBound(3)]);",
                  "    set2.canonicalize();",
                  "    let mut set3 = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4)]);",
                  "    set3.canonicalize();",
                  "    let mut set4 = IntervalSet::new(vec![SimpleBound(1)]);",
                  "    set4.ranges.push(SimpleBound(1));",
                  "    set4.canonicalize();",
                  "    let mut set5 = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(3)]);",
                  "    set5.canonicalize();",
                  "    assert_eq!(set5.ranges, vec![SimpleBound(1), SimpleBound(3)]);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new(intervals: Vec<SimpleBound>) -> Self {",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    set.ranges.push(SimpleBound(2)); // Should merge into 1..5",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    assert_eq!(set.ranges.len(), 4);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new_from_vec(intervals: Vec<SimpleBound>) -> Self {  ",
                  "        // Implementation detail unchanged  ",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    set.ranges.push(SimpleBound(2)); // Should merge into 1..5",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    assert_eq!(set.ranges, vec![SimpleBound(1), SimpleBound(2), SimpleBound(4), SimpleBound(5)]);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new(intervals: Vec<SimpleBound>) -> Self {",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    set.ranges.push(SimpleBound(2)); // Should merge into 1..5",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    let mut set2 = IntervalSet::new(vec![SimpleBound(3)]);",
                  "    set2.canonicalize();",
                  "    assert_eq!(set2.ranges.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new(intervals: Vec<SimpleBound>) -> Self {",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    set.ranges.push(SimpleBound(2)); // Should merge into 1..5",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    let mut set2 = IntervalSet::new(vec![SimpleBound(3)]);",
                  "    set2.canonicalize();",
                  "    assert_eq!(set2.ranges, vec![SimpleBound(3)]);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new(intervals: Vec<SimpleBound>) -> Self {",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    set.ranges.push(SimpleBound(2)); // Should merge into 1..5",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    let mut set2 = IntervalSet::new(vec![SimpleBound(3)]);",
                  "    set2.canonicalize();",
                  "    let mut set3 = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4)]);",
                  "    set3.canonicalize();",
                  "    assert_eq!(set3.ranges.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new(intervals: Vec<SimpleBound>) -> Self {",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    set.ranges.push(SimpleBound(2)); // Should merge into 1..5",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    let mut set2 = IntervalSet::new(vec![SimpleBound(3)]);",
                  "    set2.canonicalize();",
                  "    let mut set3 = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4)]);",
                  "    set3.canonicalize();",
                  "    assert_eq!(set3.ranges, vec![SimpleBound(1), SimpleBound(4)]);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new(intervals: Vec<SimpleBound>) -> Self {",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    set.ranges.push(SimpleBound(2)); // Should merge into 1..5",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    let mut set2 = IntervalSet::new(vec![SimpleBound(3)]);",
                  "    set2.canonicalize();",
                  "    let mut set3 = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4)]);",
                  "    set3.canonicalize();",
                  "    let mut set4 = IntervalSet::new(vec![SimpleBound(1)]);",
                  "    set4.ranges.push(SimpleBound(1));",
                  "    set4.canonicalize();",
                  "    assert_eq!(set4.ranges.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new(intervals: Vec<SimpleBound>) -> Self {",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    set.ranges.push(SimpleBound(2)); // Should merge into 1..5",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    let mut set2 = IntervalSet::new(vec![SimpleBound(3)]);",
                  "    set2.canonicalize();",
                  "    let mut set3 = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4)]);",
                  "    set3.canonicalize();",
                  "    let mut set4 = IntervalSet::new(vec![SimpleBound(1)]);",
                  "    set4.ranges.push(SimpleBound(1));",
                  "    set4.canonicalize();",
                  "    assert_eq!(set4.ranges, vec![SimpleBound(1)]);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new(intervals: Vec<SimpleBound>) -> Self {",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    set.ranges.push(SimpleBound(2)); // Should merge into 1..5",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    let mut set2 = IntervalSet::new(vec![SimpleBound(3)]);",
                  "    set2.canonicalize();",
                  "    let mut set3 = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4)]);",
                  "    set3.canonicalize();",
                  "    let mut set4 = IntervalSet::new(vec![SimpleBound(1)]);",
                  "    set4.ranges.push(SimpleBound(1));",
                  "    set4.canonicalize();",
                  "    let mut set5 = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(3)]);",
                  "    set5.canonicalize();",
                  "    assert_eq!(set5.ranges.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new(intervals: Vec<SimpleBound>) -> Self {",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    set.ranges.push(SimpleBound(2)); // Should merge into 1..5",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);",
                  "    let mut set2 = IntervalSet::new(vec![SimpleBound(3)]);",
                  "    set2.canonicalize();",
                  "    let mut set3 = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4)]);",
                  "    set3.canonicalize();",
                  "    let mut set4 = IntervalSet::new(vec![SimpleBound(1)]);",
                  "    set4.ranges.push(SimpleBound(1));",
                  "    set4.canonicalize();",
                  "    let mut set5 = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(3)]);",
                  "    set5.canonicalize();",
                  "    assert_eq!(set5.ranges, vec![SimpleBound(1), SimpleBound(3)]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:521:18\n    |\n521 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nerror[E0592]: duplicate definitions with name `new`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `new`\n...\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ----------------------------------------------- other definition for `new`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:564:32\n    |\n564 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:567:32\n    |\n567 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:732:42\n    |\n732 |         ClassUnicode { set: IntervalSet::new(ranges) }\n    |                                          ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:925:40\n    |\n925 |         ClassBytes { set: IntervalSet::new(ranges) }\n    |                                        ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0034, E0277, E0592.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:521:18\n    |\n521 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:568:9\n    |\n568 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);\n    |         ----^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nFor more information about this error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:521:18\n    |\n521 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nerror[E0592]: duplicate definitions with name `new`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `new`\n...\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ----------------------------------------------- other definition for `new`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:564:32\n    |\n564 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:567:32\n    |\n567 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:568:33\n    |\n568 |     let mut set2 = IntervalSet::new(vec![SimpleBound(3)]);\n    |                                 ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:732:42\n    |\n732 |         ClassUnicode { set: IntervalSet::new(ranges) }\n    |                                          ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:925:40\n    |\n925 |         ClassBytes { set: IntervalSet::new(ranges) }\n    |                                        ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0034, E0277, E0592.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:521:18\n    |\n521 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nerror[E0592]: duplicate definitions with name `new`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `new`\n...\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ----------------------------------------------- other definition for `new`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:564:32\n    |\n564 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:567:32\n    |\n567 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:568:33\n    |\n568 |     let mut set2 = IntervalSet::new(vec![SimpleBound(3)]);\n    |                                 ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:732:42\n    |\n732 |         ClassUnicode { set: IntervalSet::new(ranges) }\n    |                                          ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:925:40\n    |\n925 |         ClassBytes { set: IntervalSet::new(ranges) }\n    |                                        ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0034, E0277, E0592.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:521:18\n    |\n521 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nerror[E0592]: duplicate definitions with name `new`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `new`\n...\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ----------------------------------------------- other definition for `new`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:564:32\n    |\n564 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:567:32\n    |\n567 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:568:33\n    |\n568 |     let mut set2 = IntervalSet::new(vec![SimpleBound(3)]);\n    |                                 ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:570:33\n    |\n570 |     let mut set3 = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4)]);\n    |                                 ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:732:42\n    |\n732 |         ClassUnicode { set: IntervalSet::new(ranges) }\n    |                                          ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:925:40\n    |\n925 |         ClassBytes { set: IntervalSet::new(ranges) }\n    |                                        ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:560:5\n    |\n560 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0034, E0277, E0592.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:515:18\n    |\n515 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nerror[E0592]: duplicate definitions with name `new`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `new`\n...\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ----------------------------------------------- other definition for `new`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:562:32\n    |\n562 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:565:32\n    |\n565 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:566:33\n    |\n566 |     let mut set2 = IntervalSet::new(vec![SimpleBound(3)]);\n    |                                 ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:568:33\n    |\n568 |     let mut set3 = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4)]);\n    |                                 ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:732:42\n    |\n732 |         ClassUnicode { set: IntervalSet::new(ranges) }\n    |                                          ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:925:40\n    |\n925 |         ClassBytes { set: IntervalSet::new(ranges) }\n    |                                        ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0034, E0277, E0432, E0592.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:515:18\n    |\n515 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nerror[E0592]: duplicate definitions with name `new`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `new`\n...\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ----------------------------------------------- other definition for `new`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:562:32\n    |\n562 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:565:32\n    |\n565 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:566:33\n    |\n566 |     let mut set2 = IntervalSet::new(vec![SimpleBound(3)]);\n    |                                 ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:568:33\n    |\n568 |     let mut set3 = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4)]);\n    |                                 ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:570:33\n    |\n570 |     let mut set4 = IntervalSet::new(vec![SimpleBound(1)]);\n    |                                 ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:732:42\n    |\n732 |         ClassUnicode { set: IntervalSet::new(ranges) }\n    |                                          ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:925:40\n    |\n925 |         ClassBytes { set: IntervalSet::new(ranges) }\n    |                                        ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0034, E0277, E0432, E0592.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:515:18\n    |\n515 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nerror[E0592]: duplicate definitions with name `new`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `new`\n...\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ----------------------------------------------- other definition for `new`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:562:32\n    |\n562 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:565:32\n    |\n565 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:566:33\n    |\n566 |     let mut set2 = IntervalSet::new(vec![SimpleBound(3)]);\n    |                                 ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:568:33\n    |\n568 |     let mut set3 = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4)]);\n    |                                 ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:570:33\n    |\n570 |     let mut set4 = IntervalSet::new(vec![SimpleBound(1)]);\n    |                                 ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:732:42\n    |\n732 |         ClassUnicode { set: IntervalSet::new(ranges) }\n    |                                          ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:925:40\n    |\n925 |         ClassBytes { set: IntervalSet::new(ranges) }\n    |                                        ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0034, E0277, E0432, E0592.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:515:18\n    |\n515 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nerror[E0592]: duplicate definitions with name `new`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `new`\n...\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ----------------------------------------------- other definition for `new`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:562:32\n    |\n562 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:565:32\n    |\n565 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:566:33\n    |\n566 |     let mut set2 = IntervalSet::new(vec![SimpleBound(3)]);\n    |                                 ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:568:33\n    |\n568 |     let mut set3 = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4)]);\n    |                                 ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:570:33\n    |\n570 |     let mut set4 = IntervalSet::new(vec![SimpleBound(1)]);\n    |                                 ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:573:33\n    |\n573 |     let mut set5 = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(3)]);\n    |                                 ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:732:42\n    |\n732 |         ClassUnicode { set: IntervalSet::new(ranges) }\n    |                                          ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:925:40\n    |\n925 |         ClassBytes { set: IntervalSet::new(ranges) }\n    |                                        ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0034, E0277, E0432, E0592.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:515:18\n    |\n515 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nerror[E0592]: duplicate definitions with name `new`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `new`\n...\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ----------------------------------------------- other definition for `new`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:562:32\n    |\n562 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:565:32\n    |\n565 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(4), SimpleBound(5)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:566:33\n    |\n566 |     let mut set2 = IntervalSet::new(vec![SimpleBound(3)]);\n    |                                 ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:568:33\n    |\n568 |     let mut set3 = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(4)]);\n    |                                 ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:570:33\n    |\n570 |     let mut set4 = IntervalSet::new(vec![SimpleBound(1)]);\n    |                                 ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:573:33\n    |\n573 |     let mut set5 = IntervalSet::new(vec![SimpleBound(1), SimpleBound(2), SimpleBound(3)]);\n    |                                 ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:732:42\n    |\n732 |         ClassUnicode { set: IntervalSet::new(ranges) }\n    |                                          ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:925:40\n    |\n925 |         ClassBytes { set: IntervalSet::new(ranges) }\n    |                                        ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0034, E0277, E0432, E0592.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                "    set.ranges.push(SimpleBound(6)); // Separate range; no merging should happen",
                "    set.canonicalize();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    let ranges_before = set.ranges.clone();",
                  "    set.canonicalize();",
                  "    assert_eq!(ranges_before, set.ranges);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    let ranges_before = set.ranges.clone();",
                  "    set.canonicalize();",
                  "    let expected_ranges = vec![SimpleBound(1), SimpleBound(3), SimpleBound(6)];",
                  "    assert_eq!(set.ranges, expected_ranges);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    let ranges_before = set.ranges.clone();",
                  "    set.canonicalize();",
                  "    let expected_ranges = vec![SimpleBound(1), SimpleBound(3), SimpleBound(6)];",
                  "    assert!(!set.is_canonical());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new(intervals: Vec<SimpleBound>) -> Self {",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    set.ranges.push(SimpleBound(6)); // Separate range; no merging should happen",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    let ranges_before = set.ranges.clone();",
                  "    set.canonicalize();",
                  "    assert_eq!(ranges_before, set.ranges);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new(intervals: Vec<SimpleBound>) -> Self {",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    set.ranges.push(SimpleBound(6)); // Separate range; no merging should happen",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    let ranges_before = set.ranges.clone();",
                  "    set.canonicalize();",
                  "    let expected_ranges = vec![SimpleBound(1), SimpleBound(3), SimpleBound(6)];",
                  "    assert_eq!(set.ranges, expected_ranges);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new(intervals: Vec<SimpleBound>) -> Self {",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    set.ranges.push(SimpleBound(6)); // Separate range; no merging should happen",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);",
                  "    let ranges_before = set.ranges.clone();",
                  "    set.canonicalize();",
                  "    let expected_ranges = vec![SimpleBound(1), SimpleBound(3), SimpleBound(6)];",
                  "    assert!(!set.is_canonical());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:515:18\n    |\n515 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nerror[E0592]: duplicate definitions with name `new`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `new`\n...\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ----------------------------------------------- other definition for `new`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:562:32\n    |\n562 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:565:32\n    |\n565 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:732:42\n    |\n732 |         ClassUnicode { set: IntervalSet::new(ranges) }\n    |                                          ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:925:40\n    |\n925 |         ClassBytes { set: IntervalSet::new(ranges) }\n    |                                        ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0034, E0277, E0432, E0592.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:515:18\n    |\n515 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nerror[E0592]: duplicate definitions with name `new`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `new`\n...\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ----------------------------------------------- other definition for `new`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:562:32\n    |\n562 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:565:32\n    |\n565 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:732:42\n    |\n732 |         ClassUnicode { set: IntervalSet::new(ranges) }\n    |                                          ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:925:40\n    |\n925 |         ClassBytes { set: IntervalSet::new(ranges) }\n    |                                        ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0034, E0277, E0432, E0592.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:515:18\n    |\n515 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nerror[E0592]: duplicate definitions with name `new`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `new`\n...\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ----------------------------------------------- other definition for `new`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:562:32\n    |\n562 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:565:32\n    |\n565 |     let mut set = IntervalSet::new(vec![SimpleBound(1), SimpleBound(3)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:732:42\n    |\n732 |         ClassUnicode { set: IntervalSet::new(ranges) }\n    |                                          ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:925:40\n    |\n925 |         ClassBytes { set: IntervalSet::new(ranges) }\n    |                                        ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0034, E0277, E0432, E0592.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut set = IntervalSet::new(vec![SimpleBound(3)]);",
                "    set.ranges.push(SimpleBound(2)); // Should create a merge: 2..3",
                "    set.canonicalize();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut set = IntervalSet::new(vec![SimpleBound(3)]);",
                  "    set.ranges.push(SimpleBound(2));",
                  "    set.canonicalize();",
                  "    assert_eq!(set.ranges.len(), 1);"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleBound(3)]);",
                  "    set.ranges.push(SimpleBound(2));",
                  "    set.canonicalize();",
                  "    assert_eq!(set.ranges[0], SimpleBound(2));"
                ],
                [
                  "    let mut set = IntervalSet::new(vec![SimpleBound(3)]);",
                  "    set.ranges.push(SimpleBound(2));",
                  "    set.canonicalize();",
                  "    assert_eq!(set.ranges[0].upper(), SimpleBound(3));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new(intervals: Vec<SimpleBound>) -> Self {",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(3)]);",
                  "    set.ranges.push(SimpleBound(2)); // Should create a merge: 2..3",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(3)]);",
                  "    set.ranges.push(SimpleBound(2));",
                  "    set.canonicalize();",
                  "    assert_eq!(set.ranges.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new(intervals: Vec<SimpleBound>) -> Self {",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(3)]);",
                  "    set.ranges.push(SimpleBound(2)); // Should create a merge: 2..3",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(3)]);",
                  "    set.ranges.push(SimpleBound(2));",
                  "    set.canonicalize();",
                  "    assert_eq!(set.ranges[0], SimpleBound(2));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct SimpleBound(i32);",
                  "",
                  "impl std::fmt::Display for SimpleBound {",
                  "    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {",
                  "        write!(f, \"{}\", self.0)",
                  "    }",
                  "}",
                  "",
                  "impl SimpleBound {",
                  "    fn decrement(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 - 1)",
                  "    }",
                  "",
                  "    fn increment(&self) -> SimpleBound {",
                  "        SimpleBound(self.0 + 1)",
                  "    }",
                  "}",
                  "",
                  "impl Interval for SimpleBound {",
                  "    type Bound = Self;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        *self",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.0 = bound.0;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        (self.0 + 1) == other.0 || (self.0 - 1) == other.0",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper().0 < other.lower().0 || self.lower().0 > other.upper().0",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower().0 >= other.lower().0 && self.upper().0 <= other.upper().0",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct IntervalSetTest {",
                  "    ranges: Vec<SimpleBound>,",
                  "}",
                  "",
                  "impl IntervalSet<SimpleBound> {",
                  "    pub fn new(intervals: Vec<SimpleBound>) -> Self {",
                  "        IntervalSet { ranges: intervals }",
                  "    }",
                  "}",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(3)]);",
                  "    set.ranges.push(SimpleBound(2)); // Should create a merge: 2..3",
                  "    set.canonicalize();",
                  "    let mut set = IntervalSet::new(vec![SimpleBound(3)]);",
                  "    set.ranges.push(SimpleBound(2));",
                  "    set.canonicalize();",
                  "    assert_eq!(set.ranges[0].upper(), SimpleBound(3));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:515:18\n    |\n515 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nerror[E0592]: duplicate definitions with name `new`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `new`\n...\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ----------------------------------------------- other definition for `new`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:562:32\n    |\n562 |     let mut set = IntervalSet::new(vec![SimpleBound(3)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:565:32\n    |\n565 |     let mut set = IntervalSet::new(vec![SimpleBound(3)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:732:42\n    |\n732 |         ClassUnicode { set: IntervalSet::new(ranges) }\n    |                                          ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:925:40\n    |\n925 |         ClassBytes { set: IntervalSet::new(ranges) }\n    |                                        ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0034, E0277, E0432, E0592.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:515:18\n    |\n515 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nerror[E0592]: duplicate definitions with name `new`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `new`\n...\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ----------------------------------------------- other definition for `new`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:562:32\n    |\n562 |     let mut set = IntervalSet::new(vec![SimpleBound(3)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:565:32\n    |\n565 |     let mut set = IntervalSet::new(vec![SimpleBound(3)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:732:42\n    |\n732 |         ClassUnicode { set: IntervalSet::new(ranges) }\n    |                                          ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:925:40\n    |\n925 |         ClassBytes { set: IntervalSet::new(ranges) }\n    |                                        ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0034, E0277, E0432, E0592.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `SimpleBound: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:515:18\n    |\n515 |     type Bound = Self;\n    |                  ^^^^ the trait `interval::Bound` is not implemented for `SimpleBound`\n    |\n    = help: the following other types implement trait `interval::Bound`:\n              char\n              u8\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nerror[E0592]: duplicate definitions with name `new`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `new`\n...\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ----------------------------------------------- other definition for `new`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:562:32\n    |\n562 |     let mut set = IntervalSet::new(vec![SimpleBound(3)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/interval.rs:565:32\n    |\n565 |     let mut set = IntervalSet::new(vec![SimpleBound(3)]);\n    |                                ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:732:42\n    |\n732 |         ClassUnicode { set: IntervalSet::new(ranges) }\n    |                                          ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0034]: multiple applicable items in scope\n   --> regex-syntax/src/hir/mod.rs:925:40\n    |\n925 |         ClassBytes { set: IntervalSet::new(ranges) }\n    |                                        ^^^ multiple `new` found\n    |\nnote: candidate #1 is defined in an impl for the type `interval::IntervalSet<I>`\n   --> regex-syntax/src/hir/interval.rs:43:5\n    |\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nnote: candidate #2 is defined in an impl for the type `interval::IntervalSet<SimpleBound>`\n   --> regex-syntax/src/hir/interval.rs:554:5\n    |\n554 |     pub fn new(intervals: Vec<SimpleBound>) -> Self {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0034, E0277, E0432, E0592.\nFor more information about an error, try `rustc --explain E0034`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: self.is_canonical() is false\n",
        "// constraint: self.ranges.is_empty() is false\n",
        "// constraint: oldi in 0..drain_end is true\n",
        "// constraint: self.ranges.len() > drain_end is false, with bound self.ranges.len() == drain_end\n",
        "// constraint: self.ranges[oldi] is \n",
        "// constraint: oldi in 0..drain_end is false\n",
        "// constraint: self.ranges.drain(..drain_end) is \n"
      ],
      "input_infer": "self.ranges.len() == 1, self.ranges[0] overlapping with itself, 1 <= oldi < drain_end, oldi == drain_end, self.ranges.drain(..drain_end) yields no elements\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                "    interval_set.canonicalize();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                  "    assert!(!interval_set.is_canonical());"
                ],
                [
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                  "    assert_eq!(interval_set.intervals().len(), 1);"
                ],
                [
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                  "    assert_eq!(interval_set.intervals()[0].lower(), TestBound(1));"
                ],
                [
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                  "    assert_eq!(interval_set.intervals()[0].upper(), TestBound(3));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct TestBound(i32);",
                  "",
                  "impl TestBound {",
                  "    fn increment(self) -> Self {",
                  "        TestBound(self.0 + 1)",
                  "    }",
                  "    ",
                  "    fn decrement(self) -> Self {",
                  "        TestBound(self.0 - 1)",
                  "    }",
                  "}",
                  "",
                  "impl Bound for TestBound {}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower_bound: TestBound,",
                  "    upper_bound: TestBound,",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = TestBound;",
                  "    ",
                  "    fn lower(&self) -> Self::Bound { self.lower_bound }",
                  "    fn upper(&self) -> Self::Bound { self.upper_bound }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower_bound = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper_bound = bound; }",
                  "    ",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    ",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper() >= other.lower() && self.lower() <= other.upper()",
                  "    }",
                  "    ",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper() < other.lower() || self.lower() > other.upper()",
                  "    }",
                  "    ",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower() >= other.lower() && self.upper() <= other.upper()",
                  "    }",
                  "}",
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                  "    assert!(!interval_set.is_canonical());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct TestBound(i32);",
                  "",
                  "impl TestBound {",
                  "    fn increment(self) -> Self {",
                  "        TestBound(self.0 + 1)",
                  "    }",
                  "    ",
                  "    fn decrement(self) -> Self {",
                  "        TestBound(self.0 - 1)",
                  "    }",
                  "}",
                  "",
                  "impl Bound for TestBound {}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower_bound: TestBound,",
                  "    upper_bound: TestBound,",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = TestBound;",
                  "    ",
                  "    fn lower(&self) -> Self::Bound { self.lower_bound }",
                  "    fn upper(&self) -> Self::Bound { self.upper_bound }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower_bound = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper_bound = bound; }",
                  "    ",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    ",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper() >= other.lower() && self.lower() <= other.upper()",
                  "    }",
                  "    ",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper() < other.lower() || self.lower() > other.upper()",
                  "    }",
                  "    ",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower() >= other.lower() && self.upper() <= other.upper()",
                  "    }",
                  "}",
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                  "    assert_eq!(interval_set.intervals().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct TestBound(i32);",
                  "",
                  "impl TestBound {",
                  "    fn increment(self) -> Self {",
                  "        TestBound(self.0 + 1)",
                  "    }",
                  "    ",
                  "    fn decrement(self) -> Self {",
                  "        TestBound(self.0 - 1)",
                  "    }",
                  "}",
                  "",
                  "impl Bound for TestBound {}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower_bound: TestBound,",
                  "    upper_bound: TestBound,",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = TestBound;",
                  "    ",
                  "    fn lower(&self) -> Self::Bound { self.lower_bound }",
                  "    fn upper(&self) -> Self::Bound { self.upper_bound }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower_bound = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper_bound = bound; }",
                  "    ",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    ",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper() >= other.lower() && self.lower() <= other.upper()",
                  "    }",
                  "    ",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper() < other.lower() || self.lower() > other.upper()",
                  "    }",
                  "    ",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower() >= other.lower() && self.upper() <= other.upper()",
                  "    }",
                  "}",
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                  "    assert_eq!(interval_set.intervals()[0].lower(), TestBound(1));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct TestBound(i32);",
                  "",
                  "impl TestBound {",
                  "    fn increment(self) -> Self {",
                  "        TestBound(self.0 + 1)",
                  "    }",
                  "    ",
                  "    fn decrement(self) -> Self {",
                  "        TestBound(self.0 - 1)",
                  "    }",
                  "}",
                  "",
                  "impl Bound for TestBound {}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower_bound: TestBound,",
                  "    upper_bound: TestBound,",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = TestBound;",
                  "    ",
                  "    fn lower(&self) -> Self::Bound { self.lower_bound }",
                  "    fn upper(&self) -> Self::Bound { self.upper_bound }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower_bound = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper_bound = bound; }",
                  "    ",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    ",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper() >= other.lower() && self.lower() <= other.upper()",
                  "    }",
                  "    ",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper() < other.lower() || self.lower() > other.upper()",
                  "    }",
                  "    ",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower() >= other.lower() && self.upper() <= other.upper()",
                  "    }",
                  "}",
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                  "    assert_eq!(interval_set.intervals()[0].upper(), TestBound(3));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `min_value`, `max_value`, `as_u32`, `increment`, `decrement`\n   --> regex-syntax/src/hir/interval.rs:508:1\n    |\n455 |     fn min_value() -> Self;\n    |     ----------------------- `min_value` from trait\n456 |     fn max_value() -> Self;\n    |     ----------------------- `max_value` from trait\n457 |     fn as_u32(self) -> u32;\n    |     ----------------------- `as_u32` from trait\n458 |     fn increment(self) -> Self;\n    |     --------------------------- `increment` from trait\n459 |     fn decrement(self) -> Self;\n    |     --------------------------- `decrement` from trait\n...\n508 | impl Bound for TestBound {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ missing `min_value`, `max_value`, `as_u32`, `increment`, `decrement` in implementation\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nwarning: unused variable: `intervals`\n   --> regex-syntax/src/hir/interval.rs:524:32\n    |\n524 |     fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}\n    |                                ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_intervals`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:544:9\n    |\n544 |     let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);\n    |         ----^^^^^^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nSome errors have detailed explanations: E0046, E0277, E0432.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 19 warnings\nerror: could not compile `regex-syntax` (lib test) due to 41 previous errors; 19 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `min_value`, `max_value`, `as_u32`, `increment`, `decrement`\n   --> regex-syntax/src/hir/interval.rs:508:1\n    |\n455 |     fn min_value() -> Self;\n    |     ----------------------- `min_value` from trait\n456 |     fn max_value() -> Self;\n    |     ----------------------- `max_value` from trait\n457 |     fn as_u32(self) -> u32;\n    |     ----------------------- `as_u32` from trait\n458 |     fn increment(self) -> Self;\n    |     --------------------------- `increment` from trait\n459 |     fn decrement(self) -> Self;\n    |     --------------------------- `decrement` from trait\n...\n508 | impl Bound for TestBound {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ missing `min_value`, `max_value`, `as_u32`, `increment`, `decrement` in implementation\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nwarning: unused variable: `intervals`\n   --> regex-syntax/src/hir/interval.rs:524:32\n    |\n524 |     fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}\n    |                                ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_intervals`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:544:9\n    |\n544 |     let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);\n    |         ----^^^^^^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nSome errors have detailed explanations: E0046, E0277, E0432.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 19 warnings\nerror: could not compile `regex-syntax` (lib test) due to 41 previous errors; 19 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `min_value`, `max_value`, `as_u32`, `increment`, `decrement`\n   --> regex-syntax/src/hir/interval.rs:508:1\n    |\n455 |     fn min_value() -> Self;\n    |     ----------------------- `min_value` from trait\n456 |     fn max_value() -> Self;\n    |     ----------------------- `max_value` from trait\n457 |     fn as_u32(self) -> u32;\n    |     ----------------------- `as_u32` from trait\n458 |     fn increment(self) -> Self;\n    |     --------------------------- `increment` from trait\n459 |     fn decrement(self) -> Self;\n    |     --------------------------- `decrement` from trait\n...\n508 | impl Bound for TestBound {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ missing `min_value`, `max_value`, `as_u32`, `increment`, `decrement` in implementation\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:545:44\n    |\n545 |     assert_eq!(interval_set.intervals()[0].lower(), TestBound(1));\n    |                                            ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:545:44\n    |\n545 |     assert_eq!(interval_set.intervals()[0].lower(), TestBound(1));\n    |                                            ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:545:44\n    |\n545 |     assert_eq!(interval_set.intervals()[0].lower(), TestBound(1));\n    |                                            ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nwarning: unused variable: `intervals`\n   --> regex-syntax/src/hir/interval.rs:524:32\n    |\n524 |     fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}\n    |                                ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_intervals`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0277, E0432.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 44 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `min_value`, `max_value`, `as_u32`, `increment`, `decrement`\n   --> regex-syntax/src/hir/interval.rs:508:1\n    |\n455 |     fn min_value() -> Self;\n    |     ----------------------- `min_value` from trait\n456 |     fn max_value() -> Self;\n    |     ----------------------- `max_value` from trait\n457 |     fn as_u32(self) -> u32;\n    |     ----------------------- `as_u32` from trait\n458 |     fn increment(self) -> Self;\n    |     --------------------------- `increment` from trait\n459 |     fn decrement(self) -> Self;\n    |     --------------------------- `decrement` from trait\n...\n508 | impl Bound for TestBound {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ missing `min_value`, `max_value`, `as_u32`, `increment`, `decrement` in implementation\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:545:44\n    |\n545 |     assert_eq!(interval_set.intervals()[0].upper(), TestBound(3));\n    |                                            ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:545:44\n    |\n545 |     assert_eq!(interval_set.intervals()[0].upper(), TestBound(3));\n    |                                            ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:545:44\n    |\n545 |     assert_eq!(interval_set.intervals()[0].upper(), TestBound(3));\n    |                                            ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nwarning: unused variable: `intervals`\n   --> regex-syntax/src/hir/interval.rs:524:32\n    |\n524 |     fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}\n    |                                ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_intervals`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0277, E0432.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 44 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut interval_set = IntervalSet::new(vec![",
                "        TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(4) },",
                "        TestInterval { lower_bound: TestBound(2), upper_bound: TestBound(5) }",
                "    ]);",
                "    interval_set.canonicalize();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut interval_set = IntervalSet::new(vec![",
                  "    TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(4) },",
                  "    TestInterval { lower_bound: TestBound(2), upper_bound: TestBound(5) }",
                  "    ]);",
                  "    assert_eq!(interval_set.intervals(), &["
                ],
                [
                  "    let mut interval_set = IntervalSet::new(vec![",
                  "    TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(4) },",
                  "    TestInterval { lower_bound: TestBound(2), upper_bound: TestBound(5) }",
                  "    ]);",
                  "    TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(5) }",
                  "    ]);",
                  "    assert!(interval_set.is_canonical());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct TestBound(i32);",
                  "",
                  "impl TestBound {",
                  "    fn increment(self) -> Self {",
                  "        TestBound(self.0 + 1)",
                  "    }",
                  "    ",
                  "    fn decrement(self) -> Self {",
                  "        TestBound(self.0 - 1)",
                  "    }",
                  "}",
                  "",
                  "impl Bound for TestBound {}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower_bound: TestBound,",
                  "    upper_bound: TestBound,",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = TestBound;",
                  "    ",
                  "    fn lower(&self) -> Self::Bound { self.lower_bound }",
                  "    fn upper(&self) -> Self::Bound { self.upper_bound }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower_bound = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper_bound = bound; }",
                  "    ",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    ",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper() >= other.lower() && self.lower() <= other.upper()",
                  "    }",
                  "    ",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper() < other.lower() || self.lower() > other.upper()",
                  "    }",
                  "    ",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower() >= other.lower() && self.upper() <= other.upper()",
                  "    }",
                  "}",
                  "    let mut interval_set = IntervalSet::new(vec![",
                  "        TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(4) },",
                  "        TestInterval { lower_bound: TestBound(2), upper_bound: TestBound(5) }",
                  "    ]);",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set = IntervalSet::new(vec![",
                  "    TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(4) },",
                  "    TestInterval { lower_bound: TestBound(2), upper_bound: TestBound(5) }",
                  "    ]);",
                  "    assert_eq!(interval_set.intervals(), &[",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct TestBound(i32);",
                  "",
                  "impl TestBound {",
                  "    fn increment(self) -> Self {",
                  "        TestBound(self.0 + 1)",
                  "    }",
                  "    ",
                  "    fn decrement(self) -> Self {",
                  "        TestBound(self.0 - 1)",
                  "    }",
                  "}",
                  "",
                  "impl Bound for TestBound {}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower_bound: TestBound,",
                  "    upper_bound: TestBound,",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = TestBound;",
                  "    ",
                  "    fn lower(&self) -> Self::Bound { self.lower_bound }",
                  "    fn upper(&self) -> Self::Bound { self.upper_bound }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower_bound = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper_bound = bound; }",
                  "    ",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    ",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper() >= other.lower() && self.lower() <= other.upper()",
                  "    }",
                  "    ",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper() < other.lower() || self.lower() > other.upper()",
                  "    }",
                  "    ",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower() >= other.lower() && self.upper() <= other.upper()",
                  "    }",
                  "}",
                  "    let mut interval_set = IntervalSet::new(vec![",
                  "        TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(4) },",
                  "        TestInterval { lower_bound: TestBound(2), upper_bound: TestBound(5) }",
                  "    ]);",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set = IntervalSet::new(vec![",
                  "    TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(4) },",
                  "    TestInterval { lower_bound: TestBound(2), upper_bound: TestBound(5) }",
                  "    ]);",
                  "    TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(5) }",
                  "    ]);",
                  "    assert!(interval_set.is_canonical());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: mismatched closing delimiter: `}`\n   --> regex-syntax/src/hir/interval.rs:551:43\n    |\n541 | {\n    | - closing delimiter possibly meant for this\n...\n551 |     assert_eq!(interval_set.intervals(), &[\n    |                                           ^ unclosed delimiter\n552 | }\n    | ^ mismatched closing delimiter\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: mismatched closing delimiter: `]`\n   --> regex-syntax/src/hir/interval.rs:541:1\n    |\n541 | {\n    | ^ unclosed delimiter\n...\n552 |     ]);\n    |     ^ mismatched closing delimiter\n\nerror: mismatched closing delimiter: `)`\n   --> regex-syntax/src/hir/interval.rs:492:14\n    |\n492 | mod llmtests {\n    |              ^ unclosed delimiter\n...\n552 |     ]);\n    |      ^ mismatched closing delimiter\n\nerror: unexpected closing delimiter: `}`\n   --> regex-syntax/src/hir/interval.rs:554:1\n    |\n552 |     ]);\n    |     -- missing open `(` for this delimiter\n    |     |\n    |     missing open `[` for this delimiter\n553 |     assert!(interval_set.is_canonical());\n554 | }\n    | ^ unexpected closing delimiter\n\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut interval_set = IntervalSet::new(vec![]);",
                "    #[should_panic]",
                "    interval_set.canonicalize();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut interval_set = IntervalSet::new(vec![]);",
                  "    assert!(interval_set.ranges.is_empty());"
                ],
                [
                  "    let mut interval_set = IntervalSet::new(vec![]);",
                  "    assert!(!interval_set.is_canonical());"
                ],
                [
                  "    let mut interval_set = IntervalSet::new(vec![]);",
                  "    assert_eq!(interval_set.ranges.len(), 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct TestBound(i32);",
                  "",
                  "impl TestBound {",
                  "    fn increment(self) -> Self {",
                  "        TestBound(self.0 + 1)",
                  "    }",
                  "    ",
                  "    fn decrement(self) -> Self {",
                  "        TestBound(self.0 - 1)",
                  "    }",
                  "}",
                  "",
                  "impl Bound for TestBound {}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower_bound: TestBound,",
                  "    upper_bound: TestBound,",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = TestBound;",
                  "    ",
                  "    fn lower(&self) -> Self::Bound { self.lower_bound }",
                  "    fn upper(&self) -> Self::Bound { self.upper_bound }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower_bound = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper_bound = bound; }",
                  "    ",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    ",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper() >= other.lower() && self.lower() <= other.upper()",
                  "    }",
                  "    ",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper() < other.lower() || self.lower() > other.upper()",
                  "    }",
                  "    ",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower() >= other.lower() && self.upper() <= other.upper()",
                  "    }",
                  "}",
                  "    let mut interval_set = IntervalSet::new(vec![]);",
                  "    #[should_panic]",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set = IntervalSet::new(vec![]);",
                  "    assert!(interval_set.ranges.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct TestBound(i32);",
                  "",
                  "impl TestBound {",
                  "    fn increment(self) -> Self {",
                  "        TestBound(self.0 + 1)",
                  "    }",
                  "    ",
                  "    fn decrement(self) -> Self {",
                  "        TestBound(self.0 - 1)",
                  "    }",
                  "}",
                  "",
                  "impl Bound for TestBound {}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower_bound: TestBound,",
                  "    upper_bound: TestBound,",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = TestBound;",
                  "    ",
                  "    fn lower(&self) -> Self::Bound { self.lower_bound }",
                  "    fn upper(&self) -> Self::Bound { self.upper_bound }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower_bound = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper_bound = bound; }",
                  "    ",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    ",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper() >= other.lower() && self.lower() <= other.upper()",
                  "    }",
                  "    ",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper() < other.lower() || self.lower() > other.upper()",
                  "    }",
                  "    ",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower() >= other.lower() && self.upper() <= other.upper()",
                  "    }",
                  "}",
                  "    let mut interval_set = IntervalSet::new(vec![]);",
                  "    #[should_panic]",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set = IntervalSet::new(vec![]);",
                  "    assert!(!interval_set.is_canonical());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct TestBound(i32);",
                  "",
                  "impl TestBound {",
                  "    fn increment(self) -> Self {",
                  "        TestBound(self.0 + 1)",
                  "    }",
                  "    ",
                  "    fn decrement(self) -> Self {",
                  "        TestBound(self.0 - 1)",
                  "    }",
                  "}",
                  "",
                  "impl Bound for TestBound {}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower_bound: TestBound,",
                  "    upper_bound: TestBound,",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = TestBound;",
                  "    ",
                  "    fn lower(&self) -> Self::Bound { self.lower_bound }",
                  "    fn upper(&self) -> Self::Bound { self.upper_bound }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower_bound = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper_bound = bound; }",
                  "    ",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    ",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper() >= other.lower() && self.lower() <= other.upper()",
                  "    }",
                  "    ",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper() < other.lower() || self.lower() > other.upper()",
                  "    }",
                  "    ",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower() >= other.lower() && self.upper() <= other.upper()",
                  "    }",
                  "}",
                  "    let mut interval_set = IntervalSet::new(vec![]);",
                  "    #[should_panic]",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set = IntervalSet::new(vec![]);",
                  "    assert_eq!(interval_set.ranges.len(), 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: `#[should_panic]` only has an effect on functions\n   --> regex-syntax/src/hir/interval.rs:543:5\n    |\n543 |     #[should_panic]\n    |     ^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_attributes)]` on by default\n\nerror[E0046]: not all trait items implemented, missing: `min_value`, `max_value`, `as_u32`, `increment`, `decrement`\n   --> regex-syntax/src/hir/interval.rs:508:1\n    |\n455 |     fn min_value() -> Self;\n    |     ----------------------- `min_value` from trait\n456 |     fn max_value() -> Self;\n    |     ----------------------- `max_value` from trait\n457 |     fn as_u32(self) -> u32;\n    |     ----------------------- `as_u32` from trait\n458 |     fn increment(self) -> Self;\n    |     --------------------------- `increment` from trait\n459 |     fn decrement(self) -> Self;\n    |     --------------------------- `decrement` from trait\n...\n508 | impl Bound for TestBound {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ missing `min_value`, `max_value`, `as_u32`, `increment`, `decrement` in implementation\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0283]: type annotations needed for `interval::IntervalSet<_>`\n   --> regex-syntax/src/hir/interval.rs:542:9\n    |\n542 |     let mut interval_set = IntervalSet::new(vec![]);\n    |         ^^^^^^^^^^^^^^^^   ------------------------ type must be known at this point\n    |\n    = note: cannot satisfy `_: interval::Interval`\n    = help: the following types implement trait `interval::Interval`:\n              TestInterval\n              hir::ClassBytesRange\n              hir::ClassUnicodeRange\nnote: required by a bound in `interval::IntervalSet::<I>::new`\n   --> regex-syntax/src/hir/interval.rs:37:9\n    |\n37  | impl<I: Interval> IntervalSet<I> {\n    |         ^^^^^^^^ required by this bound in `IntervalSet::<I>::new`\n...\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |            --- required by a bound in this associated function\nhelp: consider giving `interval_set` an explicit type, where the type for type parameter `I` is specified\n    |\n542 |     let mut interval_set: interval::IntervalSet<T> = IntervalSet::new(vec![]);\n    |                         ++++++++++++++++++++++++++\n\nwarning: unused variable: `intervals`\n   --> regex-syntax/src/hir/interval.rs:524:32\n    |\n524 |     fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}\n    |                                ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_intervals`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0277, E0283, E0432.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 19 warnings\nerror: could not compile `regex-syntax` (lib test) due to 42 previous errors; 19 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: `#[should_panic]` only has an effect on functions\n   --> regex-syntax/src/hir/interval.rs:543:5\n    |\n543 |     #[should_panic]\n    |     ^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_attributes)]` on by default\n\nerror[E0046]: not all trait items implemented, missing: `min_value`, `max_value`, `as_u32`, `increment`, `decrement`\n   --> regex-syntax/src/hir/interval.rs:508:1\n    |\n455 |     fn min_value() -> Self;\n    |     ----------------------- `min_value` from trait\n456 |     fn max_value() -> Self;\n    |     ----------------------- `max_value` from trait\n457 |     fn as_u32(self) -> u32;\n    |     ----------------------- `as_u32` from trait\n458 |     fn increment(self) -> Self;\n    |     --------------------------- `increment` from trait\n459 |     fn decrement(self) -> Self;\n    |     --------------------------- `decrement` from trait\n...\n508 | impl Bound for TestBound {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ missing `min_value`, `max_value`, `as_u32`, `increment`, `decrement` in implementation\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0283]: type annotations needed for `interval::IntervalSet<_>`\n   --> regex-syntax/src/hir/interval.rs:542:9\n    |\n542 |     let mut interval_set = IntervalSet::new(vec![]);\n    |         ^^^^^^^^^^^^^^^^   ------------------------ type must be known at this point\n    |\n    = note: cannot satisfy `_: interval::Interval`\n    = help: the following types implement trait `interval::Interval`:\n              TestInterval\n              hir::ClassBytesRange\n              hir::ClassUnicodeRange\nnote: required by a bound in `interval::IntervalSet::<I>::new`\n   --> regex-syntax/src/hir/interval.rs:37:9\n    |\n37  | impl<I: Interval> IntervalSet<I> {\n    |         ^^^^^^^^ required by this bound in `IntervalSet::<I>::new`\n...\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |            --- required by a bound in this associated function\nhelp: consider giving `interval_set` an explicit type, where the type for type parameter `I` is specified\n    |\n542 |     let mut interval_set: interval::IntervalSet<T> = IntervalSet::new(vec![]);\n    |                         ++++++++++++++++++++++++++\n\nwarning: unused variable: `intervals`\n   --> regex-syntax/src/hir/interval.rs:524:32\n    |\n524 |     fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}\n    |                                ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_intervals`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0277, E0283, E0432.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 19 warnings\nerror: could not compile `regex-syntax` (lib test) due to 42 previous errors; 19 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: `#[should_panic]` only has an effect on functions\n   --> regex-syntax/src/hir/interval.rs:543:5\n    |\n543 |     #[should_panic]\n    |     ^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unused_attributes)]` on by default\n\nerror[E0046]: not all trait items implemented, missing: `min_value`, `max_value`, `as_u32`, `increment`, `decrement`\n   --> regex-syntax/src/hir/interval.rs:508:1\n    |\n455 |     fn min_value() -> Self;\n    |     ----------------------- `min_value` from trait\n456 |     fn max_value() -> Self;\n    |     ----------------------- `max_value` from trait\n457 |     fn as_u32(self) -> u32;\n    |     ----------------------- `as_u32` from trait\n458 |     fn increment(self) -> Self;\n    |     --------------------------- `increment` from trait\n459 |     fn decrement(self) -> Self;\n    |     --------------------------- `decrement` from trait\n...\n508 | impl Bound for TestBound {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ missing `min_value`, `max_value`, `as_u32`, `increment`, `decrement` in implementation\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0283]: type annotations needed for `interval::IntervalSet<_>`\n   --> regex-syntax/src/hir/interval.rs:542:9\n    |\n542 |     let mut interval_set = IntervalSet::new(vec![]);\n    |         ^^^^^^^^^^^^^^^^   ------------------------ type must be known at this point\n    |\n    = note: cannot satisfy `_: interval::Interval`\n    = help: the following types implement trait `interval::Interval`:\n              TestInterval\n              hir::ClassBytesRange\n              hir::ClassUnicodeRange\nnote: required by a bound in `interval::IntervalSet::<I>::new`\n   --> regex-syntax/src/hir/interval.rs:37:9\n    |\n37  | impl<I: Interval> IntervalSet<I> {\n    |         ^^^^^^^^ required by this bound in `IntervalSet::<I>::new`\n...\n43  |     pub fn new<T: IntoIterator<Item=I>>(intervals: T) -> IntervalSet<I> {\n    |            --- required by a bound in this associated function\nhelp: consider giving `interval_set` an explicit type, where the type for type parameter `I` is specified\n    |\n542 |     let mut interval_set: interval::IntervalSet<T> = IntervalSet::new(vec![]);\n    |                         ++++++++++++++++++++++++++\n\nwarning: unused variable: `intervals`\n   --> regex-syntax/src/hir/interval.rs:524:32\n    |\n524 |     fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}\n    |                                ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_intervals`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0277, E0283, E0432.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 19 warnings\nerror: could not compile `regex-syntax` (lib test) due to 42 previous errors; 19 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut interval_set = IntervalSet::new(vec![",
                "        TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }",
                "    ]);",
                "    interval_set.canonicalize();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                  "    assert!(!interval_set.is_canonical());"
                ],
                [
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                  "    assert_eq!(interval_set.intervals(), &[TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);"
                ],
                [
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                  "    assert_eq!(interval_set.ranges.len(), 1);"
                ],
                [
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                  "    assert_eq!(interval_set.ranges[0].lower(), TestBound(1));"
                ],
                [
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                  "    assert_eq!(interval_set.ranges[0].upper(), TestBound(3));"
                ],
                [
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                  "    assert!(interval_set.ranges[0].is_contiguous(&interval_set.ranges[0]));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct TestBound(i32);",
                  "",
                  "impl TestBound {",
                  "    fn increment(self) -> Self {",
                  "        TestBound(self.0 + 1)",
                  "    }",
                  "    ",
                  "    fn decrement(self) -> Self {",
                  "        TestBound(self.0 - 1)",
                  "    }",
                  "}",
                  "",
                  "impl Bound for TestBound {}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower_bound: TestBound,",
                  "    upper_bound: TestBound,",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = TestBound;",
                  "    ",
                  "    fn lower(&self) -> Self::Bound { self.lower_bound }",
                  "    fn upper(&self) -> Self::Bound { self.upper_bound }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower_bound = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper_bound = bound; }",
                  "    ",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    ",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper() >= other.lower() && self.lower() <= other.upper()",
                  "    }",
                  "    ",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper() < other.lower() || self.lower() > other.upper()",
                  "    }",
                  "    ",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower() >= other.lower() && self.upper() <= other.upper()",
                  "    }",
                  "}",
                  "    let mut interval_set = IntervalSet::new(vec![",
                  "        TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }",
                  "    ]);",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                  "    assert!(!interval_set.is_canonical());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct TestBound(i32);",
                  "",
                  "impl TestBound {",
                  "    fn increment(self) -> Self {",
                  "        TestBound(self.0 + 1)",
                  "    }",
                  "    ",
                  "    fn decrement(self) -> Self {",
                  "        TestBound(self.0 - 1)",
                  "    }",
                  "}",
                  "",
                  "impl Bound for TestBound {}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower_bound: TestBound,",
                  "    upper_bound: TestBound,",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = TestBound;",
                  "    ",
                  "    fn lower(&self) -> Self::Bound { self.lower_bound }",
                  "    fn upper(&self) -> Self::Bound { self.upper_bound }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower_bound = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper_bound = bound; }",
                  "    ",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    ",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper() >= other.lower() && self.lower() <= other.upper()",
                  "    }",
                  "    ",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper() < other.lower() || self.lower() > other.upper()",
                  "    }",
                  "    ",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower() >= other.lower() && self.upper() <= other.upper()",
                  "    }",
                  "}",
                  "    let mut interval_set = IntervalSet::new(vec![",
                  "        TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }",
                  "    ]);",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                  "    assert_eq!(interval_set.intervals(), &[TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct TestBound(i32);",
                  "",
                  "impl TestBound {",
                  "    fn increment(self) -> Self {",
                  "        TestBound(self.0 + 1)",
                  "    }",
                  "    ",
                  "    fn decrement(self) -> Self {",
                  "        TestBound(self.0 - 1)",
                  "    }",
                  "}",
                  "",
                  "impl Bound for TestBound {}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower_bound: TestBound,",
                  "    upper_bound: TestBound,",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = TestBound;",
                  "    ",
                  "    fn lower(&self) -> Self::Bound { self.lower_bound }",
                  "    fn upper(&self) -> Self::Bound { self.upper_bound }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower_bound = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper_bound = bound; }",
                  "    ",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    ",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper() >= other.lower() && self.lower() <= other.upper()",
                  "    }",
                  "    ",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper() < other.lower() || self.lower() > other.upper()",
                  "    }",
                  "    ",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower() >= other.lower() && self.upper() <= other.upper()",
                  "    }",
                  "}",
                  "    let mut interval_set = IntervalSet::new(vec![",
                  "        TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }",
                  "    ]);",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                  "    assert_eq!(interval_set.ranges.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct TestBound(i32);",
                  "",
                  "impl TestBound {",
                  "    fn increment(self) -> Self {",
                  "        TestBound(self.0 + 1)",
                  "    }",
                  "    ",
                  "    fn decrement(self) -> Self {",
                  "        TestBound(self.0 - 1)",
                  "    }",
                  "}",
                  "",
                  "impl Bound for TestBound {}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower_bound: TestBound,",
                  "    upper_bound: TestBound,",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = TestBound;",
                  "    ",
                  "    fn lower(&self) -> Self::Bound { self.lower_bound }",
                  "    fn upper(&self) -> Self::Bound { self.upper_bound }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower_bound = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper_bound = bound; }",
                  "    ",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    ",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper() >= other.lower() && self.lower() <= other.upper()",
                  "    }",
                  "    ",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper() < other.lower() || self.lower() > other.upper()",
                  "    }",
                  "    ",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower() >= other.lower() && self.upper() <= other.upper()",
                  "    }",
                  "}",
                  "    let mut interval_set = IntervalSet::new(vec![",
                  "        TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }",
                  "    ]);",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                  "    assert_eq!(interval_set.ranges[0].lower(), TestBound(1));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct TestBound(i32);",
                  "",
                  "impl TestBound {",
                  "    fn increment(self) -> Self {",
                  "        TestBound(self.0 + 1)",
                  "    }",
                  "    ",
                  "    fn decrement(self) -> Self {",
                  "        TestBound(self.0 - 1)",
                  "    }",
                  "}",
                  "",
                  "impl Bound for TestBound {}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower_bound: TestBound,",
                  "    upper_bound: TestBound,",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = TestBound;",
                  "    ",
                  "    fn lower(&self) -> Self::Bound { self.lower_bound }",
                  "    fn upper(&self) -> Self::Bound { self.upper_bound }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower_bound = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper_bound = bound; }",
                  "    ",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    ",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper() >= other.lower() && self.lower() <= other.upper()",
                  "    }",
                  "    ",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper() < other.lower() || self.lower() > other.upper()",
                  "    }",
                  "    ",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower() >= other.lower() && self.upper() <= other.upper()",
                  "    }",
                  "}",
                  "    let mut interval_set = IntervalSet::new(vec![",
                  "        TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }",
                  "    ]);",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                  "    assert_eq!(interval_set.ranges[0].upper(), TestBound(3));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct TestBound(i32);",
                  "",
                  "impl TestBound {",
                  "    fn increment(self) -> Self {",
                  "        TestBound(self.0 + 1)",
                  "    }",
                  "    ",
                  "    fn decrement(self) -> Self {",
                  "        TestBound(self.0 - 1)",
                  "    }",
                  "}",
                  "",
                  "impl Bound for TestBound {}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower_bound: TestBound,",
                  "    upper_bound: TestBound,",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = TestBound;",
                  "    ",
                  "    fn lower(&self) -> Self::Bound { self.lower_bound }",
                  "    fn upper(&self) -> Self::Bound { self.upper_bound }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower_bound = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper_bound = bound; }",
                  "    ",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    ",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper() >= other.lower() && self.lower() <= other.upper()",
                  "    }",
                  "    ",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper() < other.lower() || self.lower() > other.upper()",
                  "    }",
                  "    ",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower() >= other.lower() && self.upper() <= other.upper()",
                  "    }",
                  "}",
                  "    let mut interval_set = IntervalSet::new(vec![",
                  "        TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }",
                  "    ]);",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);",
                  "    assert!(interval_set.ranges[0].is_contiguous(&interval_set.ranges[0]));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `min_value`, `max_value`, `as_u32`, `increment`, `decrement`\n   --> regex-syntax/src/hir/interval.rs:508:1\n    |\n455 |     fn min_value() -> Self;\n    |     ----------------------- `min_value` from trait\n456 |     fn max_value() -> Self;\n    |     ----------------------- `max_value` from trait\n457 |     fn as_u32(self) -> u32;\n    |     ----------------------- `as_u32` from trait\n458 |     fn increment(self) -> Self;\n    |     --------------------------- `increment` from trait\n459 |     fn decrement(self) -> Self;\n    |     --------------------------- `decrement` from trait\n...\n508 | impl Bound for TestBound {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ missing `min_value`, `max_value`, `as_u32`, `increment`, `decrement` in implementation\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nwarning: unused variable: `intervals`\n   --> regex-syntax/src/hir/interval.rs:524:32\n    |\n524 |     fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}\n    |                                ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_intervals`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:546:9\n    |\n546 |     let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);\n    |         ----^^^^^^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nSome errors have detailed explanations: E0046, E0277, E0432.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 19 warnings\nerror: could not compile `regex-syntax` (lib test) due to 41 previous errors; 19 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `min_value`, `max_value`, `as_u32`, `increment`, `decrement`\n   --> regex-syntax/src/hir/interval.rs:508:1\n    |\n455 |     fn min_value() -> Self;\n    |     ----------------------- `min_value` from trait\n456 |     fn max_value() -> Self;\n    |     ----------------------- `max_value` from trait\n457 |     fn as_u32(self) -> u32;\n    |     ----------------------- `as_u32` from trait\n458 |     fn increment(self) -> Self;\n    |     --------------------------- `increment` from trait\n459 |     fn decrement(self) -> Self;\n    |     --------------------------- `decrement` from trait\n...\n508 | impl Bound for TestBound {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ missing `min_value`, `max_value`, `as_u32`, `increment`, `decrement` in implementation\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nwarning: unused variable: `intervals`\n   --> regex-syntax/src/hir/interval.rs:524:32\n    |\n524 |     fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}\n    |                                ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_intervals`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:546:9\n    |\n546 |     let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);\n    |         ----^^^^^^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nSome errors have detailed explanations: E0046, E0277, E0432.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 19 warnings\nerror: could not compile `regex-syntax` (lib test) due to 41 previous errors; 19 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `min_value`, `max_value`, `as_u32`, `increment`, `decrement`\n   --> regex-syntax/src/hir/interval.rs:508:1\n    |\n455 |     fn min_value() -> Self;\n    |     ----------------------- `min_value` from trait\n456 |     fn max_value() -> Self;\n    |     ----------------------- `max_value` from trait\n457 |     fn as_u32(self) -> u32;\n    |     ----------------------- `as_u32` from trait\n458 |     fn increment(self) -> Self;\n    |     --------------------------- `increment` from trait\n459 |     fn decrement(self) -> Self;\n    |     --------------------------- `decrement` from trait\n...\n508 | impl Bound for TestBound {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ missing `min_value`, `max_value`, `as_u32`, `increment`, `decrement` in implementation\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nwarning: unused variable: `intervals`\n   --> regex-syntax/src/hir/interval.rs:524:32\n    |\n524 |     fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}\n    |                                ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_intervals`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:546:9\n    |\n546 |     let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(3) }]);\n    |         ----^^^^^^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nSome errors have detailed explanations: E0046, E0277, E0432.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 19 warnings\nerror: could not compile `regex-syntax` (lib test) due to 41 previous errors; 19 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `min_value`, `max_value`, `as_u32`, `increment`, `decrement`\n   --> regex-syntax/src/hir/interval.rs:508:1\n    |\n455 |     fn min_value() -> Self;\n    |     ----------------------- `min_value` from trait\n456 |     fn max_value() -> Self;\n    |     ----------------------- `max_value` from trait\n457 |     fn as_u32(self) -> u32;\n    |     ----------------------- `as_u32` from trait\n458 |     fn increment(self) -> Self;\n    |     --------------------------- `increment` from trait\n459 |     fn decrement(self) -> Self;\n    |     --------------------------- `decrement` from trait\n...\n508 | impl Bound for TestBound {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ missing `min_value`, `max_value`, `as_u32`, `increment`, `decrement` in implementation\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:547:39\n    |\n547 |     assert_eq!(interval_set.ranges[0].lower(), TestBound(1));\n    |                                       ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:547:39\n    |\n547 |     assert_eq!(interval_set.ranges[0].lower(), TestBound(1));\n    |                                       ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:547:39\n    |\n547 |     assert_eq!(interval_set.ranges[0].lower(), TestBound(1));\n    |                                       ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nwarning: unused variable: `intervals`\n   --> regex-syntax/src/hir/interval.rs:524:32\n    |\n524 |     fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}\n    |                                ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_intervals`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0277, E0432.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 44 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `min_value`, `max_value`, `as_u32`, `increment`, `decrement`\n   --> regex-syntax/src/hir/interval.rs:508:1\n    |\n455 |     fn min_value() -> Self;\n    |     ----------------------- `min_value` from trait\n456 |     fn max_value() -> Self;\n    |     ----------------------- `max_value` from trait\n457 |     fn as_u32(self) -> u32;\n    |     ----------------------- `as_u32` from trait\n458 |     fn increment(self) -> Self;\n    |     --------------------------- `increment` from trait\n459 |     fn decrement(self) -> Self;\n    |     --------------------------- `decrement` from trait\n...\n508 | impl Bound for TestBound {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ missing `min_value`, `max_value`, `as_u32`, `increment`, `decrement` in implementation\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:547:39\n    |\n547 |     assert_eq!(interval_set.ranges[0].upper(), TestBound(3));\n    |                                       ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:547:39\n    |\n547 |     assert_eq!(interval_set.ranges[0].upper(), TestBound(3));\n    |                                       ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:547:39\n    |\n547 |     assert_eq!(interval_set.ranges[0].upper(), TestBound(3));\n    |                                       ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nwarning: unused variable: `intervals`\n   --> regex-syntax/src/hir/interval.rs:524:32\n    |\n524 |     fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}\n    |                                ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_intervals`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0277, E0432.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 44 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `min_value`, `max_value`, `as_u32`, `increment`, `decrement`\n   --> regex-syntax/src/hir/interval.rs:508:1\n    |\n455 |     fn min_value() -> Self;\n    |     ----------------------- `min_value` from trait\n456 |     fn max_value() -> Self;\n    |     ----------------------- `max_value` from trait\n457 |     fn as_u32(self) -> u32;\n    |     ----------------------- `as_u32` from trait\n458 |     fn increment(self) -> Self;\n    |     --------------------------- `increment` from trait\n459 |     fn decrement(self) -> Self;\n    |     --------------------------- `decrement` from trait\n...\n508 | impl Bound for TestBound {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ missing `min_value`, `max_value`, `as_u32`, `increment`, `decrement` in implementation\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:547:13\n    |\n547 |     assert!(interval_set.ranges[0].is_contiguous(&interval_set.ranges[0]));\n    |             ^^^^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::is_contiguous`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::is_contiguous`\n...\n429 |     fn is_contiguous(&self, other: &Self) -> bool {\n    |        ------------- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:547:13\n    |\n547 |     assert!(interval_set.ranges[0].is_contiguous(&interval_set.ranges[0]));\n    |             ^^^^^^^^^^^^^^^^^^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::is_contiguous`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::is_contiguous`\n...\n429 |     fn is_contiguous(&self, other: &Self) -> bool {\n    |        ------------- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:547:13\n    |\n547 |     assert!(interval_set.ranges[0].is_contiguous(&interval_set.ranges[0]));\n    |             ^^^^^^^^^^^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::is_contiguous`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::is_contiguous`\n...\n429 |     fn is_contiguous(&self, other: &Self) -> bool {\n    |        ------------- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nwarning: unused variable: `intervals`\n   --> regex-syntax/src/hir/interval.rs:524:32\n    |\n524 |     fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}\n    |                                ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_intervals`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0277, E0432.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 44 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut interval_set = IntervalSet::new(vec![",
                "        TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(2) }",
                "    ]);",
                "    interval_set.canonicalize();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(2) }]);",
                  "    assert!(!interval_set.is_canonical());"
                ],
                [
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(2) }]);",
                  "    assert_eq!(interval_set.intervals().len(), 1);"
                ],
                [
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(2) }]);",
                  "    assert_eq!(interval_set.intervals()[0].lower(), TestBound(1));"
                ],
                [
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(2) }]);",
                  "    assert_eq!(interval_set.intervals()[0].upper(), TestBound(2));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct TestBound(i32);",
                  "",
                  "impl TestBound {",
                  "    fn increment(self) -> Self {",
                  "        TestBound(self.0 + 1)",
                  "    }",
                  "    ",
                  "    fn decrement(self) -> Self {",
                  "        TestBound(self.0 - 1)",
                  "    }",
                  "}",
                  "",
                  "impl Bound for TestBound {}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower_bound: TestBound,",
                  "    upper_bound: TestBound,",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = TestBound;",
                  "    ",
                  "    fn lower(&self) -> Self::Bound { self.lower_bound }",
                  "    fn upper(&self) -> Self::Bound { self.upper_bound }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower_bound = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper_bound = bound; }",
                  "    ",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    ",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper() >= other.lower() && self.lower() <= other.upper()",
                  "    }",
                  "    ",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper() < other.lower() || self.lower() > other.upper()",
                  "    }",
                  "    ",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower() >= other.lower() && self.upper() <= other.upper()",
                  "    }",
                  "}",
                  "    let mut interval_set = IntervalSet::new(vec![",
                  "        TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(2) }",
                  "    ]);",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(2) }]);",
                  "    assert!(!interval_set.is_canonical());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct TestBound(i32);",
                  "",
                  "impl TestBound {",
                  "    fn increment(self) -> Self {",
                  "        TestBound(self.0 + 1)",
                  "    }",
                  "    ",
                  "    fn decrement(self) -> Self {",
                  "        TestBound(self.0 - 1)",
                  "    }",
                  "}",
                  "",
                  "impl Bound for TestBound {}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower_bound: TestBound,",
                  "    upper_bound: TestBound,",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = TestBound;",
                  "    ",
                  "    fn lower(&self) -> Self::Bound { self.lower_bound }",
                  "    fn upper(&self) -> Self::Bound { self.upper_bound }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower_bound = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper_bound = bound; }",
                  "    ",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    ",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper() >= other.lower() && self.lower() <= other.upper()",
                  "    }",
                  "    ",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper() < other.lower() || self.lower() > other.upper()",
                  "    }",
                  "    ",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower() >= other.lower() && self.upper() <= other.upper()",
                  "    }",
                  "}",
                  "    let mut interval_set = IntervalSet::new(vec![",
                  "        TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(2) }",
                  "    ]);",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(2) }]);",
                  "    assert_eq!(interval_set.intervals().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct TestBound(i32);",
                  "",
                  "impl TestBound {",
                  "    fn increment(self) -> Self {",
                  "        TestBound(self.0 + 1)",
                  "    }",
                  "    ",
                  "    fn decrement(self) -> Self {",
                  "        TestBound(self.0 - 1)",
                  "    }",
                  "}",
                  "",
                  "impl Bound for TestBound {}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower_bound: TestBound,",
                  "    upper_bound: TestBound,",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = TestBound;",
                  "    ",
                  "    fn lower(&self) -> Self::Bound { self.lower_bound }",
                  "    fn upper(&self) -> Self::Bound { self.upper_bound }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower_bound = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper_bound = bound; }",
                  "    ",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    ",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper() >= other.lower() && self.lower() <= other.upper()",
                  "    }",
                  "    ",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper() < other.lower() || self.lower() > other.upper()",
                  "    }",
                  "    ",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower() >= other.lower() && self.upper() <= other.upper()",
                  "    }",
                  "}",
                  "    let mut interval_set = IntervalSet::new(vec![",
                  "        TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(2) }",
                  "    ]);",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(2) }]);",
                  "    assert_eq!(interval_set.intervals()[0].lower(), TestBound(1));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Copy, Debug, Default, Eq, PartialEq, PartialOrd, Ord)]",
                  "struct TestBound(i32);",
                  "",
                  "impl TestBound {",
                  "    fn increment(self) -> Self {",
                  "        TestBound(self.0 + 1)",
                  "    }",
                  "    ",
                  "    fn decrement(self) -> Self {",
                  "        TestBound(self.0 - 1)",
                  "    }",
                  "}",
                  "",
                  "impl Bound for TestBound {}",
                  "",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower_bound: TestBound,",
                  "    upper_bound: TestBound,",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = TestBound;",
                  "    ",
                  "    fn lower(&self) -> Self::Bound { self.lower_bound }",
                  "    fn upper(&self) -> Self::Bound { self.upper_bound }",
                  "    fn set_lower(&mut self, bound: Self::Bound) { self.lower_bound = bound; }",
                  "    fn set_upper(&mut self, bound: Self::Bound) { self.upper_bound = bound; }",
                  "    ",
                  "    fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}",
                  "    ",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper() >= other.lower() && self.lower() <= other.upper()",
                  "    }",
                  "    ",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper() < other.lower() || self.lower() > other.upper()",
                  "    }",
                  "    ",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower() >= other.lower() && self.upper() <= other.upper()",
                  "    }",
                  "}",
                  "    let mut interval_set = IntervalSet::new(vec![",
                  "        TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(2) }",
                  "    ]);",
                  "    interval_set.canonicalize();",
                  "    let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(2) }]);",
                  "    assert_eq!(interval_set.intervals()[0].upper(), TestBound(2));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `min_value`, `max_value`, `as_u32`, `increment`, `decrement`\n   --> regex-syntax/src/hir/interval.rs:508:1\n    |\n455 |     fn min_value() -> Self;\n    |     ----------------------- `min_value` from trait\n456 |     fn max_value() -> Self;\n    |     ----------------------- `max_value` from trait\n457 |     fn as_u32(self) -> u32;\n    |     ----------------------- `as_u32` from trait\n458 |     fn increment(self) -> Self;\n    |     --------------------------- `increment` from trait\n459 |     fn decrement(self) -> Self;\n    |     --------------------------- `decrement` from trait\n...\n508 | impl Bound for TestBound {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ missing `min_value`, `max_value`, `as_u32`, `increment`, `decrement` in implementation\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nwarning: unused variable: `intervals`\n   --> regex-syntax/src/hir/interval.rs:524:32\n    |\n524 |     fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}\n    |                                ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_intervals`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:546:9\n    |\n546 |     let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(2) }]);\n    |         ----^^^^^^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nSome errors have detailed explanations: E0046, E0277, E0432.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 19 warnings\nerror: could not compile `regex-syntax` (lib test) due to 41 previous errors; 19 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `min_value`, `max_value`, `as_u32`, `increment`, `decrement`\n   --> regex-syntax/src/hir/interval.rs:508:1\n    |\n455 |     fn min_value() -> Self;\n    |     ----------------------- `min_value` from trait\n456 |     fn max_value() -> Self;\n    |     ----------------------- `max_value` from trait\n457 |     fn as_u32(self) -> u32;\n    |     ----------------------- `as_u32` from trait\n458 |     fn increment(self) -> Self;\n    |     --------------------------- `increment` from trait\n459 |     fn decrement(self) -> Self;\n    |     --------------------------- `decrement` from trait\n...\n508 | impl Bound for TestBound {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ missing `min_value`, `max_value`, `as_u32`, `increment`, `decrement` in implementation\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nwarning: unused variable: `intervals`\n   --> regex-syntax/src/hir/interval.rs:524:32\n    |\n524 |     fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}\n    |                                ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_intervals`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:546:9\n    |\n546 |     let mut interval_set = IntervalSet::new(vec![TestInterval { lower_bound: TestBound(1), upper_bound: TestBound(2) }]);\n    |         ----^^^^^^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nSome errors have detailed explanations: E0046, E0277, E0432.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 19 warnings\nerror: could not compile `regex-syntax` (lib test) due to 41 previous errors; 19 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `min_value`, `max_value`, `as_u32`, `increment`, `decrement`\n   --> regex-syntax/src/hir/interval.rs:508:1\n    |\n455 |     fn min_value() -> Self;\n    |     ----------------------- `min_value` from trait\n456 |     fn max_value() -> Self;\n    |     ----------------------- `max_value` from trait\n457 |     fn as_u32(self) -> u32;\n    |     ----------------------- `as_u32` from trait\n458 |     fn increment(self) -> Self;\n    |     --------------------------- `increment` from trait\n459 |     fn decrement(self) -> Self;\n    |     --------------------------- `decrement` from trait\n...\n508 | impl Bound for TestBound {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ missing `min_value`, `max_value`, `as_u32`, `increment`, `decrement` in implementation\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:547:44\n    |\n547 |     assert_eq!(interval_set.intervals()[0].lower(), TestBound(1));\n    |                                            ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:547:44\n    |\n547 |     assert_eq!(interval_set.intervals()[0].lower(), TestBound(1));\n    |                                            ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:547:44\n    |\n547 |     assert_eq!(interval_set.intervals()[0].lower(), TestBound(1));\n    |                                            ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nwarning: unused variable: `intervals`\n   --> regex-syntax/src/hir/interval.rs:524:32\n    |\n524 |     fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}\n    |                                ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_intervals`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0277, E0432.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 44 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0046]: not all trait items implemented, missing: `min_value`, `max_value`, `as_u32`, `increment`, `decrement`\n   --> regex-syntax/src/hir/interval.rs:508:1\n    |\n455 |     fn min_value() -> Self;\n    |     ----------------------- `min_value` from trait\n456 |     fn max_value() -> Self;\n    |     ----------------------- `max_value` from trait\n457 |     fn as_u32(self) -> u32;\n    |     ----------------------- `as_u32` from trait\n458 |     fn increment(self) -> Self;\n    |     --------------------------- `increment` from trait\n459 |     fn decrement(self) -> Self;\n    |     --------------------------- `decrement` from trait\n...\n508 | impl Bound for TestBound {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^ missing `min_value`, `max_value`, `as_u32`, `increment`, `decrement` in implementation\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:516:19\n    |\n516 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:14\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:31\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:47\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:527:64\n    |\n527 |         self.upper() >= other.lower() && self.lower() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:14\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:30\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:46\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:531:62\n    |\n531 |         self.upper() < other.lower() || self.lower() > other.upper()\n    |                                                              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:14\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |              ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:31\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:47\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                               ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:535:64\n    |\n535 |         self.lower() >= other.lower() && self.upper() <= other.upper()\n    |                                                                ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:547:44\n    |\n547 |     assert_eq!(interval_set.intervals()[0].upper(), TestBound(2));\n    |                                            ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n511 + #[derive(Copy)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Default` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:547:44\n    |\n547 |     assert_eq!(interval_set.intervals()[0].upper(), TestBound(2));\n    |                                            ^^^^^ the trait `Default` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:28\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                            ^^^^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Default)]`\n    |\n511 + #[derive(Default)]\n512 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:547:44\n    |\n547 |     assert_eq!(interval_set.intervals()[0].upper(), TestBound(2));\n    |                                            ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n511 + #[derive(Ord)]\n512 | struct TestInterval {\n    |\n\nwarning: unused variable: `intervals`\n   --> regex-syntax/src/hir/interval.rs:524:32\n    |\n524 |     fn case_fold_simple(&self, intervals: &mut Vec<Self>) {}\n    |                                ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_intervals`\n    |\n    = note: `#[warn(unused_variables)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0046, E0277, E0432.\nFor more information about an error, try `rustc --explain E0046`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 44 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "// constraint: self.is_canonical() is false\n",
        "// constraint: self.ranges.is_empty() is false\n",
        "// constraint: oldi in 0..drain_end is false\n",
        "// constraint: self.ranges.drain(..drain_end) is \n"
      ],
      "input_infer": "0 < self.ranges.len() <= 1000, self.is_canonical() == false, 0 <= oldi < drain_end, confirmed that self.ranges is initialized properly.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut intervals = IntervalSet::new(vec![",
                "        TestInterval { lower: 1, upper: 5 },",
                "        TestInterval { lower: 3, upper: 7 },",
                "        TestInterval { lower: 8, upper: 10 },",
                "        TestInterval { lower: 9, upper: 12 },",
                "    ]);",
                "    intervals.canonicalize();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 5 }, TestInterval { lower: 3, upper: 7 }, TestInterval { lower: 8, upper: 10 }, TestInterval { lower: 9, upper: 12 }]);",
                  "    assert_eq!(intervals.intervals(), &[TestInterval { lower: 1, upper: 7 }, TestInterval { lower: 8, upper: 12 }]);"
                ],
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 5 }, TestInterval { lower: 3, upper: 7 }, TestInterval { lower: 8, upper: 10 }, TestInterval { lower: 9, upper: 12 }]);",
                  "    assert!(intervals.is_canonical());"
                ],
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 5 }, TestInterval { lower: 3, upper: 7 }, TestInterval { lower: 8, upper: 10 }, TestInterval { lower: 9, upper: 12 }]);",
                  "    assert_eq!(intervals.ranges.len(), 2);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 5 },",
                  "        TestInterval { lower: 3, upper: 7 },",
                  "        TestInterval { lower: 8, upper: 10 },",
                  "        TestInterval { lower: 9, upper: 12 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 5 }, TestInterval { lower: 3, upper: 7 }, TestInterval { lower: 8, upper: 10 }, TestInterval { lower: 9, upper: 12 }]);",
                  "    assert_eq!(intervals.intervals(), &[TestInterval { lower: 1, upper: 7 }, TestInterval { lower: 8, upper: 12 }]);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 5 },",
                  "        TestInterval { lower: 3, upper: 7 },",
                  "        TestInterval { lower: 8, upper: 10 },",
                  "        TestInterval { lower: 9, upper: 12 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 5 }, TestInterval { lower: 3, upper: 7 }, TestInterval { lower: 8, upper: 10 }, TestInterval { lower: 9, upper: 12 }]);",
                  "    assert!(intervals.is_canonical());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 5 },",
                  "        TestInterval { lower: 3, upper: 7 },",
                  "        TestInterval { lower: 8, upper: 10 },",
                  "        TestInterval { lower: 9, upper: 12 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 5 }, TestInterval { lower: 3, upper: 7 }, TestInterval { lower: 8, upper: 10 }, TestInterval { lower: 9, upper: 12 }]);",
                  "    assert_eq!(intervals.ranges.len(), 2);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:551:9\n    |\n551 |     let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 5 }, TestInterval { lower: 3, upper: 7 }, TestInterval { lo...\n    |         ----^^^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:551:9\n    |\n551 |     let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 5 }, TestInterval { lower: 3, upper: 7 }, TestInterval { lo...\n    |         ----^^^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:551:9\n    |\n551 |     let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 5 }, TestInterval { lower: 3, upper: 7 }, TestInterval { lo...\n    |         ----^^^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut intervals = IntervalSet::new(vec![",
                "        TestInterval { lower: 1, upper: 2 },",
                "        TestInterval { lower: 3, upper: 4 },",
                "        TestInterval { lower: 5, upper: 6 },",
                "    ]);",
                "    intervals.canonicalize();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 3, upper: 4 }, TestInterval { lower: 5, upper: 6 }]);",
                  "    assert_eq!(intervals.intervals(), &[TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 3, upper: 4 }, TestInterval { lower: 5, upper: 6 }]);"
                ],
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 3, upper: 4 }, TestInterval { lower: 5, upper: 6 }]);",
                  "    intervals.canonicalize();",
                  "    assert_eq!(intervals.intervals(), &[TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 3, upper: 4 }, TestInterval { lower: 5, upper: 6 }]);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 2 },",
                  "        TestInterval { lower: 3, upper: 4 },",
                  "        TestInterval { lower: 5, upper: 6 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 3, upper: 4 }, TestInterval { lower: 5, upper: 6 }]);",
                  "    assert_eq!(intervals.intervals(), &[TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 3, upper: 4 }, TestInterval { lower: 5, upper: 6 }]);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 2 },",
                  "        TestInterval { lower: 3, upper: 4 },",
                  "        TestInterval { lower: 5, upper: 6 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 3, upper: 4 }, TestInterval { lower: 5, upper: 6 }]);",
                  "    intervals.canonicalize();",
                  "    assert_eq!(intervals.intervals(), &[TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 3, upper: 4 }, TestInterval { lower: 5, upper: 6 }]);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:550:9\n    |\n550 |     let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 3, upper: 4 }, TestInterval { lo...\n    |         ----^^^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut intervals = IntervalSet::new(vec![",
                "        TestInterval { lower: 1, upper: 4 },",
                "        TestInterval { lower: 4, upper: 5 },",
                "        TestInterval { lower: 6, upper: 10 },",
                "    ]);",
                "    intervals.canonicalize();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 4 }, TestInterval { lower: 4, upper: 5 }, TestInterval { lower: 6, upper: 10 }]);",
                  "    assert_eq!(intervals.intervals(), &vec![TestInterval { lower: 1, upper: 5 }, TestInterval { lower: 6, upper: 10 }]);"
                ],
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 4 }, TestInterval { lower: 4, upper: 5 }, TestInterval { lower: 6, upper: 10 }]);",
                  "    assert!(intervals.is_canonical());"
                ],
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 4 }, TestInterval { lower: 4, upper: 5 }, TestInterval { lower: 6, upper: 10 }]);",
                  "    assert!(intervals.ranges.len() == 2);"
                ],
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 4 }, TestInterval { lower: 4, upper: 5 }, TestInterval { lower: 6, upper: 10 }]);",
                  "    assert!(intervals.ranges[0].lower() == 1);"
                ],
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 4 }, TestInterval { lower: 4, upper: 5 }, TestInterval { lower: 6, upper: 10 }]);",
                  "    assert!(intervals.ranges[0].upper() == 5);"
                ],
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 4 }, TestInterval { lower: 4, upper: 5 }, TestInterval { lower: 6, upper: 10 }]);",
                  "    assert!(intervals.ranges[1].lower() == 6);"
                ],
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 4 }, TestInterval { lower: 4, upper: 5 }, TestInterval { lower: 6, upper: 10 }]);",
                  "    assert!(intervals.ranges[1].upper() == 10);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 4 },",
                  "        TestInterval { lower: 4, upper: 5 },",
                  "        TestInterval { lower: 6, upper: 10 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 4 }, TestInterval { lower: 4, upper: 5 }, TestInterval { lower: 6, upper: 10 }]);",
                  "    assert_eq!(intervals.intervals(), &vec![TestInterval { lower: 1, upper: 5 }, TestInterval { lower: 6, upper: 10 }]);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 4 },",
                  "        TestInterval { lower: 4, upper: 5 },",
                  "        TestInterval { lower: 6, upper: 10 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 4 }, TestInterval { lower: 4, upper: 5 }, TestInterval { lower: 6, upper: 10 }]);",
                  "    assert!(intervals.is_canonical());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 4 },",
                  "        TestInterval { lower: 4, upper: 5 },",
                  "        TestInterval { lower: 6, upper: 10 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 4 }, TestInterval { lower: 4, upper: 5 }, TestInterval { lower: 6, upper: 10 }]);",
                  "    assert!(intervals.ranges.len() == 2);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 4 },",
                  "        TestInterval { lower: 4, upper: 5 },",
                  "        TestInterval { lower: 6, upper: 10 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 4 }, TestInterval { lower: 4, upper: 5 }, TestInterval { lower: 6, upper: 10 }]);",
                  "    assert!(intervals.ranges[0].lower() == 1);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 4 },",
                  "        TestInterval { lower: 4, upper: 5 },",
                  "        TestInterval { lower: 6, upper: 10 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 4 }, TestInterval { lower: 4, upper: 5 }, TestInterval { lower: 6, upper: 10 }]);",
                  "    assert!(intervals.ranges[0].upper() == 5);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 4 },",
                  "        TestInterval { lower: 4, upper: 5 },",
                  "        TestInterval { lower: 6, upper: 10 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 4 }, TestInterval { lower: 4, upper: 5 }, TestInterval { lower: 6, upper: 10 }]);",
                  "    assert!(intervals.ranges[1].lower() == 6);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 4 },",
                  "        TestInterval { lower: 4, upper: 5 },",
                  "        TestInterval { lower: 6, upper: 10 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 4 }, TestInterval { lower: 4, upper: 5 }, TestInterval { lower: 6, upper: 10 }]);",
                  "    assert!(intervals.ranges[1].upper() == 10);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:550:9\n    |\n550 |     let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 4 }, TestInterval { lower: 4, upper: 5 }, TestInterval { lo...\n    |         ----^^^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:550:9\n    |\n550 |     let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 4 }, TestInterval { lower: 4, upper: 5 }, TestInterval { lo...\n    |         ----^^^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:550:9\n    |\n550 |     let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 4 }, TestInterval { lower: 4, upper: 5 }, TestInterval { lo...\n    |         ----^^^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:551:33\n    |\n551 |     assert!(intervals.ranges[0].lower() == 1);\n    |                                 ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:551:33\n    |\n551 |     assert!(intervals.ranges[0].lower() == 1);\n    |                                 ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:551:33\n    |\n551 |     assert!(intervals.ranges[0].upper() == 5);\n    |                                 ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:551:33\n    |\n551 |     assert!(intervals.ranges[0].upper() == 5);\n    |                                 ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:551:33\n    |\n551 |     assert!(intervals.ranges[1].lower() == 6);\n    |                                 ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:551:33\n    |\n551 |     assert!(intervals.ranges[1].lower() == 6);\n    |                                 ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:551:33\n    |\n551 |     assert!(intervals.ranges[1].upper() == 10);\n    |                                 ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:551:33\n    |\n551 |     assert!(intervals.ranges[1].upper() == 10);\n    |                                 ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut intervals = IntervalSet::new(vec![",
                "        TestInterval { lower: 1, upper: 10 },",
                "    ]);",
                "    intervals.canonicalize();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 10 }]);",
                  "    assert_eq!(intervals.intervals().len(), 1);"
                ],
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 10 }]);",
                  "    assert_eq!(intervals.intervals()[0].lower(), 1);"
                ],
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 10 }]);",
                  "    assert_eq!(intervals.intervals()[0].upper(), 10);"
                ],
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 10 }]);",
                  "    assert!(intervals.is_canonical());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 10 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 10 }]);",
                  "    assert_eq!(intervals.intervals().len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 10 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 10 }]);",
                  "    assert_eq!(intervals.intervals()[0].lower(), 1);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 10 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 10 }]);",
                  "    assert_eq!(intervals.intervals()[0].upper(), 10);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 10 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 10 }]);",
                  "    assert!(intervals.is_canonical());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:548:9\n    |\n548 |     let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 10 }]);\n    |         ----^^^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:549:41\n    |\n549 |     assert_eq!(intervals.intervals()[0].lower(), 1);\n    |                                         ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:549:41\n    |\n549 |     assert_eq!(intervals.intervals()[0].lower(), 1);\n    |                                         ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:549:41\n    |\n549 |     assert_eq!(intervals.intervals()[0].upper(), 10);\n    |                                         ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:549:41\n    |\n549 |     assert_eq!(intervals.intervals()[0].upper(), 10);\n    |                                         ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:548:9\n    |\n548 |     let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 10 }]);\n    |         ----^^^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut intervals = IntervalSet::new(vec![",
                "        TestInterval { lower: 1, upper: 2 },",
                "        TestInterval { lower: 2, upper: 3 },",
                "        TestInterval { lower: 3, upper: 6 },",
                "    ]);",
                "    intervals.canonicalize();",
                "}"
              ],
              "oracles": [
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lower: 3, upper: 6 }]);",
                  "    assert_eq!(intervals.intervals(), &[TestInterval { lower: 1, upper: 6 }]);"
                ],
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lower: 3, upper: 6 }]);",
                  "    assert!(!intervals.is_canonical());"
                ],
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lower: 3, upper: 6 }]);",
                  "    assert_eq!(intervals.ranges.len(), 1);"
                ],
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lower: 3, upper: 6 }]);",
                  "    assert!(intervals.ranges[0].is_contiguous(&TestInterval { lower: 1, upper: 6 }));"
                ],
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lower: 3, upper: 6 }]);",
                  "    assert!(intervals.ranges[0].is_subset(&TestInterval { lower: 1, upper: 6 }));"
                ],
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lower: 3, upper: 6 }]);",
                  "    assert!(intervals.ranges[0].is_intersection_empty(&TestInterval { lower: 7, upper: 8 }));"
                ],
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lower: 3, upper: 6 }]);",
                  "    assert!(intervals.ranges[0].is_intersection_empty(&TestInterval { lower: 0, upper: 1 }));"
                ],
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lower: 3, upper: 6 }]);",
                  "    assert!(intervals.ranges[0].is_contiguous(&TestInterval { lower: 6, upper: 7 }));"
                ],
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lower: 3, upper: 6 }]);",
                  "    assert!(intervals.ranges.len() > 0);"
                ],
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lower: 3, upper: 6 }]);",
                  "    assert_eq!(intervals.ranges[0].lower(), 1);"
                ],
                [
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lower: 3, upper: 6 }]);",
                  "    assert_eq!(intervals.ranges[0].upper(), 6);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 2 },",
                  "        TestInterval { lower: 2, upper: 3 },",
                  "        TestInterval { lower: 3, upper: 6 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lower: 3, upper: 6 }]);",
                  "    assert_eq!(intervals.intervals(), &[TestInterval { lower: 1, upper: 6 }]);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 2 },",
                  "        TestInterval { lower: 2, upper: 3 },",
                  "        TestInterval { lower: 3, upper: 6 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lower: 3, upper: 6 }]);",
                  "    assert!(!intervals.is_canonical());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 2 },",
                  "        TestInterval { lower: 2, upper: 3 },",
                  "        TestInterval { lower: 3, upper: 6 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lower: 3, upper: 6 }]);",
                  "    assert_eq!(intervals.ranges.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 2 },",
                  "        TestInterval { lower: 2, upper: 3 },",
                  "        TestInterval { lower: 3, upper: 6 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lower: 3, upper: 6 }]);",
                  "    assert!(intervals.ranges[0].is_contiguous(&TestInterval { lower: 1, upper: 6 }));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 2 },",
                  "        TestInterval { lower: 2, upper: 3 },",
                  "        TestInterval { lower: 3, upper: 6 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lower: 3, upper: 6 }]);",
                  "    assert!(intervals.ranges[0].is_subset(&TestInterval { lower: 1, upper: 6 }));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 2 },",
                  "        TestInterval { lower: 2, upper: 3 },",
                  "        TestInterval { lower: 3, upper: 6 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lower: 3, upper: 6 }]);",
                  "    assert!(intervals.ranges[0].is_intersection_empty(&TestInterval { lower: 7, upper: 8 }));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 2 },",
                  "        TestInterval { lower: 2, upper: 3 },",
                  "        TestInterval { lower: 3, upper: 6 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lower: 3, upper: 6 }]);",
                  "    assert!(intervals.ranges[0].is_intersection_empty(&TestInterval { lower: 0, upper: 1 }));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 2 },",
                  "        TestInterval { lower: 2, upper: 3 },",
                  "        TestInterval { lower: 3, upper: 6 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lower: 3, upper: 6 }]);",
                  "    assert!(intervals.ranges[0].is_contiguous(&TestInterval { lower: 6, upper: 7 }));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 2 },",
                  "        TestInterval { lower: 2, upper: 3 },",
                  "        TestInterval { lower: 3, upper: 6 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lower: 3, upper: 6 }]);",
                  "    assert!(intervals.ranges.len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 2 },",
                  "        TestInterval { lower: 2, upper: 3 },",
                  "        TestInterval { lower: 3, upper: 6 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lower: 3, upper: 6 }]);",
                  "    assert_eq!(intervals.ranges[0].lower(), 1);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone, Debug, Eq, PartialEq)]",
                  "struct TestInterval {",
                  "    lower: u32,",
                  "    upper: u32,",
                  "}",
                  "",
                  "impl Default for TestInterval {",
                  "    fn default() -> Self {",
                  "        TestInterval { lower: 0, upper: 0 }",
                  "    }",
                  "}",
                  "",
                  "impl Interval for TestInterval {",
                  "    type Bound = u32;",
                  "",
                  "    fn lower(&self) -> Self::Bound {",
                  "        self.lower",
                  "    }",
                  "",
                  "    fn upper(&self) -> Self::Bound {",
                  "        self.upper",
                  "    }",
                  "",
                  "    fn set_lower(&mut self, bound: Self::Bound) {",
                  "        self.lower = bound;",
                  "    }",
                  "",
                  "    fn set_upper(&mut self, bound: Self::Bound) {",
                  "        self.upper = bound;",
                  "    }",
                  "",
                  "    fn case_fold_simple(&self, _intervals: &mut Vec<Self>) {}",
                  "",
                  "    fn is_contiguous(&self, other: &Self) -> bool {",
                  "        self.upper == other.lower || self.lower == other.upper",
                  "    }",
                  "",
                  "    fn is_intersection_empty(&self, other: &Self) -> bool {",
                  "        self.upper < other.lower || self.lower > other.upper",
                  "    }",
                  "",
                  "    fn is_subset(&self, other: &Self) -> bool {",
                  "        self.lower >= other.lower && self.upper <= other.upper",
                  "    }",
                  "}",
                  "    let mut intervals = IntervalSet::new(vec![",
                  "        TestInterval { lower: 1, upper: 2 },",
                  "        TestInterval { lower: 2, upper: 3 },",
                  "        TestInterval { lower: 3, upper: 6 },",
                  "    ]);",
                  "    intervals.canonicalize();",
                  "    let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lower: 3, upper: 6 }]);",
                  "    assert_eq!(intervals.ranges[0].upper(), 6);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:550:9\n    |\n550 |     let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lo...\n    |         ----^^^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:550:9\n    |\n550 |     let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lo...\n    |         ----^^^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:550:9\n    |\n550 |     let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lo...\n    |         ----^^^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:551:13\n    |\n551 |     assert!(intervals.ranges[0].is_contiguous(&TestInterval { lower: 1, upper: 6 }));\n    |             ^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::is_contiguous`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::is_contiguous`\n...\n429 |     fn is_contiguous(&self, other: &Self) -> bool {\n    |        ------------- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:551:13\n    |\n551 |     assert!(intervals.ranges[0].is_contiguous(&TestInterval { lower: 1, upper: 6 }));\n    |             ^^^^^^^^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::is_contiguous`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::is_contiguous`\n...\n429 |     fn is_contiguous(&self, other: &Self) -> bool {\n    |        ------------- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:551:13\n    |\n551 |     assert!(intervals.ranges[0].is_subset(&TestInterval { lower: 1, upper: 6 }));\n    |             ^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::is_subset`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::is_subset`\n...\n446 |     fn is_subset(&self, other: &Self) -> bool {\n    |        --------- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:551:13\n    |\n551 |     assert!(intervals.ranges[0].is_subset(&TestInterval { lower: 1, upper: 6 }));\n    |             ^^^^^^^^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::is_subset`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::is_subset`\n...\n446 |     fn is_subset(&self, other: &Self) -> bool {\n    |        --------- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:551:13\n    |\n551 |     assert!(intervals.ranges[0].is_intersection_empty(&TestInterval { lower: 7, upper: 8 }));\n    |             ^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::is_intersection_empty`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::is_intersection_empty`\n...\n439 |     fn is_intersection_empty(&self, other: &Self) -> bool {\n    |        --------------------- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:551:13\n    |\n551 |     assert!(intervals.ranges[0].is_intersection_empty(&TestInterval { lower: 7, upper: 8 }));\n    |             ^^^^^^^^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::is_intersection_empty`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::is_intersection_empty`\n...\n439 |     fn is_intersection_empty(&self, other: &Self) -> bool {\n    |        --------------------- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:551:13\n    |\n551 |     assert!(intervals.ranges[0].is_intersection_empty(&TestInterval { lower: 0, upper: 1 }));\n    |             ^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::is_intersection_empty`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::is_intersection_empty`\n...\n439 |     fn is_intersection_empty(&self, other: &Self) -> bool {\n    |        --------------------- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:551:13\n    |\n551 |     assert!(intervals.ranges[0].is_intersection_empty(&TestInterval { lower: 0, upper: 1 }));\n    |             ^^^^^^^^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::is_intersection_empty`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::is_intersection_empty`\n...\n439 |     fn is_intersection_empty(&self, other: &Self) -> bool {\n    |        --------------------- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:551:13\n    |\n551 |     assert!(intervals.ranges[0].is_contiguous(&TestInterval { lower: 6, upper: 7 }));\n    |             ^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::is_contiguous`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::is_contiguous`\n...\n429 |     fn is_contiguous(&self, other: &Self) -> bool {\n    |        ------------- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:551:13\n    |\n551 |     assert!(intervals.ranges[0].is_contiguous(&TestInterval { lower: 6, upper: 7 }));\n    |             ^^^^^^^^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::is_contiguous`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::is_contiguous`\n...\n429 |     fn is_contiguous(&self, other: &Self) -> bool {\n    |        ------------- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/interval.rs:550:9\n    |\n550 |     let mut intervals = IntervalSet::new(vec![TestInterval { lower: 1, upper: 2 }, TestInterval { lower: 2, upper: 3 }, TestInterval { lo...\n    |         ----^^^^^^^^^\n    |         |\n    |         help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 18 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 18 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:551:36\n    |\n551 |     assert_eq!(intervals.ranges[0].lower(), 1);\n    |                                    ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:551:36\n    |\n551 |     assert_eq!(intervals.ranges[0].lower(), 1);\n    |                                    ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::lower`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::lower`\n...\n331 |     fn lower(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n   --> regex-syntax/src/hir/interval.rs:494:8\n    |\n494 |    use ntest::timeout;\n    |        ^^^^^ maybe a missing crate `ntest`?\n    |\n    = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:507:19\n    |\n507 | impl Interval for TestInterval {\n    |                   ^^^^^^^^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n326 | pub trait Interval:\n    |           -------- required by a bound in this trait\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval`\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `u32: interval::Bound` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:508:18\n    |\n508 |     type Bound = u32;\n    |                  ^^^ the trait `interval::Bound` is not implemented for `u32`\n    |\n    = help: the trait `interval::Bound` is implemented for `u8`\nnote: required by a bound in `interval::Interval::Bound`\n   --> regex-syntax/src/hir/interval.rs:329:17\n    |\n329 |     type Bound: Bound;\n    |                 ^^^^^ required by this bound in `Interval::Bound`\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `TestInterval: Copy` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:551:36\n    |\n551 |     assert_eq!(intervals.ranges[0].upper(), 6);\n    |                                    ^^^^^ the trait `Copy` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:13\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |             ^^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Copy)]`\n    |\n496 + #[derive(Copy)]\n497 | struct TestInterval {\n    |\n\nerror[E0277]: the trait bound `TestInterval: Ord` is not satisfied\n   --> regex-syntax/src/hir/interval.rs:551:36\n    |\n551 |     assert_eq!(intervals.ranges[0].upper(), 6);\n    |                                    ^^^^^ the trait `Ord` is not implemented for `TestInterval`\n    |\nnote: required by a bound in `interval::Interval::upper`\n   --> regex-syntax/src/hir/interval.rs:327:68\n    |\n327 |     Clone + Copy + Debug + Default + Eq + PartialEq + PartialOrd + Ord\n    |                                                                    ^^^ required by this bound in `Interval::upper`\n...\n332 |     fn upper(&self) -> Self::Bound;\n    |        ----- required by a bound in this associated function\nhelp: consider annotating `TestInterval` with `#[derive(Ord)]`\n    |\n496 + #[derive(Ord)]\n497 | struct TestInterval {\n    |\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0432.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}