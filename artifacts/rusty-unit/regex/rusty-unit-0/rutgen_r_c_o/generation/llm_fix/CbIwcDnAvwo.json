{
  "name": "regex_syntax::hir::translate::hir::translate::TranslatorI<'t, 'p>::hir_assertion",
  "name_with_impl": "regex_syntax::hir::translate::{impl#5}::hir_assertion",
  "mod_info": {
    "name": "hir::translate",
    "loc": "regex-syntax/src/hir/mod.rs:29:1:29:19"
  },
  "visible": false,
  "loc": "regex-syntax/src/hir/translate.rs:689:5:735:6",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: asst.kind matches ast::AssertionKind::NotWordBoundary is true\n",
        "// constraint: unicode is true\n",
        "// expected return value/type: Ok(match asst.kind {\n            ast::AssertionKind::StartLine => {\n                Hir::anchor(if multi_line {\n                    hir::Anchor::StartLine\n                } else {\n                    hir::Anchor::StartText\n                })\n            }\n            ast::AssertionKind::EndLine => {\n                Hir::anchor(if multi_line {\n                    hir::Anchor::EndLine\n                } else {\n                    hir::Anchor::EndText\n                })\n            }\n            ast::AssertionKind::StartText => {\n                Hir::anchor(hir::Anchor::StartText)\n            }\n            ast::AssertionKind::EndText => {\n                Hir::anchor(hir::Anchor::EndText)\n            }\n            ast::AssertionKind::WordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::Unicode\n                } else {\n                    hir::WordBoundary::Ascii\n                })\n            }\n            ast::AssertionKind::NotWordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::UnicodeNegate\n                } else {\n                    // It is possible for negated ASCII word boundaries to\n                    // match at invalid UTF-8 boundaries, even when searching\n                    // valid UTF-8.\n                    if !self.trans().allow_invalid_utf8 {\n                        return Err(self.error(\n                            asst.span, ErrorKind::InvalidUtf8));\n                    }\n                    hir::WordBoundary::AsciiNegate\n                })\n            }\n        })\n"
      ],
      "input_infer": "NotWordBoundary, unicode = true, allow_invalid_utf8 = false\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \".*\";",
                "    let trans = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(true),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: Position::from(0), end: Position::from(2) },",
                "        kind: ast::AssertionKind::NotWordBoundary,",
                "    };",
                "",
                "    let translator_instance = TranslatorI::new(&trans, pattern);",
                "    translator_instance.hir_assertion(&assertion).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position::from(0), end: Position::from(2) }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position::from(0), end: Position::from(2) }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().is_anchored_start(), false);"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position::from(0), end: Position::from(2) }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().is_anchored_end(), false);"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position::from(0), end: Position::from(2) }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().is_match_empty(), false);"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position::from(0), end: Position::from(2) }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::UnicodeNegate));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position::from(0), end: Position::from(2) },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    translator_instance.hir_assertion(&assertion).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position::from(0), end: Position::from(2) }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position::from(0), end: Position::from(2) },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    translator_instance.hir_assertion(&assertion).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position::from(0), end: Position::from(2) }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().is_anchored_start(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position::from(0), end: Position::from(2) },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    translator_instance.hir_assertion(&assertion).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position::from(0), end: Position::from(2) }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().is_anchored_end(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position::from(0), end: Position::from(2) },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    translator_instance.hir_assertion(&assertion).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position::from(0), end: Position::from(2) }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().is_match_empty(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position::from(0), end: Position::from(2) },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    translator_instance.hir_assertion(&assertion).unwrap();",
                  "    let trans = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position::from(0), end: Position::from(2) }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::UnicodeNegate));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2554:53\n     |\n2554 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2561:58\n     |\n2561 |     let assertion = ast::Assertion { span: Span { start: Position::from(0), end: Position::from(2) }, kind: ast::AssertionKind::NotWordBo...\n     |                                                          ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2561:82\n     |\n2561 |     let assertion = ast::Assertion { span: Span { start: Position::from(0), end: Position::from(2) }, kind: ast::AssertionKind::NotWordBo...\n     |                                                                                  ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2554:53\n     |\n2554 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2561:58\n     |\n2561 |     let assertion = ast::Assertion { span: Span { start: Position::from(0), end: Position::from(2) }, kind: ast::AssertionKind::NotWordBo...\n     |                                                          ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2561:82\n     |\n2561 |     let assertion = ast::Assertion { span: Span { start: Position::from(0), end: Position::from(2) }, kind: ast::AssertionKind::NotWordBo...\n     |                                                                                  ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2554:53\n     |\n2554 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2561:58\n     |\n2561 |     let assertion = ast::Assertion { span: Span { start: Position::from(0), end: Position::from(2) }, kind: ast::AssertionKind::NotWordBo...\n     |                                                          ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2561:82\n     |\n2561 |     let assertion = ast::Assertion { span: Span { start: Position::from(0), end: Position::from(2) }, kind: ast::AssertionKind::NotWordBo...\n     |                                                                                  ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2554:53\n     |\n2554 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2561:58\n     |\n2561 |     let assertion = ast::Assertion { span: Span { start: Position::from(0), end: Position::from(2) }, kind: ast::AssertionKind::NotWordBo...\n     |                                                          ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2561:82\n     |\n2561 |     let assertion = ast::Assertion { span: Span { start: Position::from(0), end: Position::from(2) }, kind: ast::AssertionKind::NotWordBo...\n     |                                                                                  ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2554:53\n     |\n2554 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2561:58\n     |\n2561 |     let assertion = ast::Assertion { span: Span { start: Position::from(0), end: Position::from(2) }, kind: ast::AssertionKind::NotWordBo...\n     |                                                          ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2561:82\n     |\n2561 |     let assertion = ast::Assertion { span: Span { start: Position::from(0), end: Position::from(2) }, kind: ast::AssertionKind::NotWordBo...\n     |                                                                                  ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2564:41\n     |\n2564 |     assert_eq!(result.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::UnicodeNegate));\n     |                                         ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let pattern = \".*\";",
                "    let trans = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(true),",
                "            multi_line: Some(true),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: Position::from(0), end: Position::from(2) },",
                "        kind: ast::AssertionKind::NotWordBoundary,",
                "    };",
                "",
                "    let translator_instance = TranslatorI::new(&trans, pattern);",
                "    translator_instance.hir_assertion(&assertion).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position::from(0), end: Position::from(2) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position::from(0), end: Position::from(2) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    let hir_value = result.unwrap();",
                  "    assert_eq!(hir_value.is_always_utf8(), true);"
                ],
                [
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position::from(0), end: Position::from(2) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    let hir_value = result.unwrap();",
                  "    assert_eq!(hir_value.is_all_assertions(), true);"
                ],
                [
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position::from(0), end: Position::from(2) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    let hir_value = result.unwrap();",
                  "    assert_eq!(hir_value.is_match_empty(), false);"
                ],
                [
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position::from(0), end: Position::from(2) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    let hir_value = result.unwrap();",
                  "    assert_eq!(hir_value.is_anchored_start(), false);"
                ],
                [
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position::from(0), end: Position::from(2) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    let hir_value = result.unwrap();",
                  "    assert_eq!(hir_value.is_anchored_end(), false);"
                ],
                [
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position::from(0), end: Position::from(2) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    let hir_value = result.unwrap();",
                  "    assert_eq!(hir_value.is_any_anchored_start(), false);"
                ],
                [
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position::from(0), end: Position::from(2) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    let hir_value = result.unwrap();",
                  "    assert_eq!(hir_value.is_any_anchored_end(), false);"
                ],
                [
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position::from(0), end: Position::from(2) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    let hir_value = result.unwrap();",
                  "    if let HirKind::WordBoundary(word_boundary) = hir_value.kind() {",
                  "    assert_eq!(word_boundary, hir::WordBoundary::UnicodeNegate);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position::from(0), end: Position::from(2) },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    translator_instance.hir_assertion(&assertion).unwrap();",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position::from(0), end: Position::from(2) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position::from(0), end: Position::from(2) },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    translator_instance.hir_assertion(&assertion).unwrap();",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    let hir_value = result.unwrap();",
                  "    assert_eq!(hir_value.is_always_utf8(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position::from(0), end: Position::from(2) },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    translator_instance.hir_assertion(&assertion).unwrap();",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position::from(0), end: Position::from(2) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    let hir_value = result.unwrap();",
                  "    assert_eq!(hir_value.is_all_assertions(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position::from(0), end: Position::from(2) },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    translator_instance.hir_assertion(&assertion).unwrap();",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    let hir_value = result.unwrap();",
                  "    assert_eq!(hir_value.is_match_empty(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position::from(0), end: Position::from(2) },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    translator_instance.hir_assertion(&assertion).unwrap();",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position::from(0), end: Position::from(2) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    let hir_value = result.unwrap();",
                  "    assert_eq!(hir_value.is_anchored_start(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position::from(0), end: Position::from(2) },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    translator_instance.hir_assertion(&assertion).unwrap();",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position::from(0), end: Position::from(2) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    let hir_value = result.unwrap();",
                  "    assert_eq!(hir_value.is_anchored_end(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position::from(0), end: Position::from(2) },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    translator_instance.hir_assertion(&assertion).unwrap();",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position::from(0), end: Position::from(2) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    let hir_value = result.unwrap();",
                  "    assert_eq!(hir_value.is_any_anchored_start(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position::from(0), end: Position::from(2) },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    translator_instance.hir_assertion(&assertion).unwrap();",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    let hir_value = result.unwrap();",
                  "    assert_eq!(hir_value.is_any_anchored_end(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position::from(0), end: Position::from(2) },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    translator_instance.hir_assertion(&assertion).unwrap();",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position::from(0), end: Position::from(2) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    let hir_value = result.unwrap();",
                  "    if let HirKind::WordBoundary(word_boundary) = hir_value.kind() {",
                  "    assert_eq!(word_boundary, hir::WordBoundary::UnicodeNegate);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:53\n     |\n2555 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2572:25\n     |\n2572 |     span: Span { start: Position::from(0), end: Position::from(2) },\n     |                         ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2572:49\n     |\n2572 |     span: Span { start: Position::from(0), end: Position::from(2) },\n     |                                                 ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:53\n     |\n2555 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `span` in initializer of `Assertion`\n    --> regex-syntax/src/hir/translate.rs:2571:21\n     |\n2571 |     let assertion = ast::Assertion {\n     |                     ^^^^^^^^^^^^^^ missing `span`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:53\n     |\n2555 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2572:25\n     |\n2572 |     span: Span { start: Position::from(0), end: Position::from(2) },\n     |                         ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2572:49\n     |\n2572 |     span: Span { start: Position::from(0), end: Position::from(2) },\n     |                                                 ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:53\n     |\n2555 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `span` in initializer of `Assertion`\n    --> regex-syntax/src/hir/translate.rs:2571:21\n     |\n2571 |     let assertion = ast::Assertion {\n     |                     ^^^^^^^^^^^^^^ missing `span`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:53\n     |\n2555 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2572:25\n     |\n2572 |     span: Span { start: Position::from(0), end: Position::from(2) },\n     |                         ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2572:49\n     |\n2572 |     span: Span { start: Position::from(0), end: Position::from(2) },\n     |                                                 ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:53\n     |\n2555 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2572:25\n     |\n2572 |     span: Span { start: Position::from(0), end: Position::from(2) },\n     |                         ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2572:49\n     |\n2572 |     span: Span { start: Position::from(0), end: Position::from(2) },\n     |                                                 ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:53\n     |\n2555 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2572:25\n     |\n2572 |     span: Span { start: Position::from(0), end: Position::from(2) },\n     |                         ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2572:49\n     |\n2572 |     span: Span { start: Position::from(0), end: Position::from(2) },\n     |                                                 ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:53\n     |\n2555 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0063]: missing field `span` in initializer of `Assertion`\n    --> regex-syntax/src/hir/translate.rs:2571:21\n     |\n2571 |     let assertion = ast::Assertion {\n     |                     ^^^^^^^^^^^^^^ missing `span`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0063, E0433.\nFor more information about an error, try `rustc --explain E0063`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2581:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2581 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [
                "#[should_panic]"
              ],
              "prefix": [
                "{",
                "    let pattern = \".*\";",
                "    let trans = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(true),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: Position::from(0), end: Position::from(2) },",
                "        kind: ast::AssertionKind::NotWordBoundary,",
                "    };",
                "",
                "    let translator_instance = TranslatorI::new(&trans, pattern);",
                "    translator_instance.hir_assertion(&assertion).unwrap();",
                "}"
              ],
              "oracles": [
                [
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position::from(0), end: Position::from(2) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position::from(0), end: Position::from(2) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::InvalidUtf8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position::from(0), end: Position::from(2) },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    translator_instance.hir_assertion(&assertion).unwrap();",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position::from(0), end: Position::from(2) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position::from(0), end: Position::from(2) },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    translator_instance.hir_assertion(&assertion).unwrap();",
                  "    let pattern = \".*\";",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position::from(0), end: Position::from(2) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&trans, pattern);",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::InvalidUtf8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:53\n     |\n2555 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: Position::from(0), end: Position::from(2) },\n     |                         ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2571:49\n     |\n2571 |     span: Span { start: Position::from(0), end: Position::from(2) },\n     |                                                 ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2555:53\n     |\n2555 |         span: Span { start: Position::from(0), end: Position::from(2) },\n     |                                                     ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: Position::from(0), end: Position::from(2) },\n     |                         ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2571:49\n     |\n2571 |     span: Span { start: Position::from(0), end: Position::from(2) },\n     |                                                 ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 2,
      "prompt_conds": [
        "// constraint: asst.kind matches ast::AssertionKind::NotWordBoundary is true\n",
        "// constraint: unicode is false\n",
        "// constraint: self.trans().allow_invalid_utf8 is true\n",
        "// expected return value/type: Ok(match asst.kind {\n            ast::AssertionKind::StartLine => {\n                Hir::anchor(if multi_line {\n                    hir::Anchor::StartLine\n                } else {\n                    hir::Anchor::StartText\n                })\n            }\n            ast::AssertionKind::EndLine => {\n                Hir::anchor(if multi_line {\n                    hir::Anchor::EndLine\n                } else {\n                    hir::Anchor::EndText\n                })\n            }\n            ast::AssertionKind::StartText => {\n                Hir::anchor(hir::Anchor::StartText)\n            }\n            ast::AssertionKind::EndText => {\n                Hir::anchor(hir::Anchor::EndText)\n            }\n            ast::AssertionKind::WordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::Unicode\n                } else {\n                    hir::WordBoundary::Ascii\n                })\n            }\n            ast::AssertionKind::NotWordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::UnicodeNegate\n                } else {\n                    // It is possible for negated ASCII word boundaries to\n                    // match at invalid UTF-8 boundaries, even when searching\n                    // valid UTF-8.\n                    if !self.trans().allow_invalid_utf8 {\n                        return Err(self.error(\n                            asst.span, ErrorKind::InvalidUtf8));\n                    }\n                    hir::WordBoundary::AsciiNegate\n                })\n            }\n        })\n"
      ],
      "input_infer": "asst.kind: ast::AssertionKind::NotWordBoundary, unicode: false, self.trans().allow_invalid_utf8: true\n",
      "answers": [
        {
          "uses": [
            "use hir::Hir;",
            "use ast;",
            "use hir::ErrorKind;",
            "use ::unicode;",
            "use ast::AssertionKind;",
            "use ast::Assertion;",
            "use hir;"
          ],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{self, Assertion, AssertionKind};",
                "    use hir::{self, Hir, ErrorKind};",
                "    use unicode;",
                "",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "",
                "    let asst = Assertion {",
                "        span: Span { start: Position::default(), end: Position::default() },",
                "        kind: AssertionKind::NotWordBoundary,",
                "    };",
                "",
                "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                "    let result = translator_instance.hir_assertion(&asst);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::AsciiNegate));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{self, Assertion, AssertionKind};",
                  "    use hir::{self, Hir, ErrorKind};",
                  "    use unicode;",
                  "",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let asst = Assertion {",
                  "        span: Span { start: Position::default(), end: Position::default() },",
                  "        kind: AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{self, Assertion, AssertionKind};",
                  "    use hir::{self, Hir, ErrorKind};",
                  "    use unicode;",
                  "",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let asst = Assertion {",
                  "        span: Span { start: Position::default(), end: Position::default() },",
                  "        kind: AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::AsciiNegate));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position::default(), end: Position::default() },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2554:55\n     |\n2554 |         span: Span { start: Position::default(), end: Position::default() },\n     |                                                       ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `self`\n    --> regex-syntax/src/hir/translate.rs:2543:15\n     |\n2543 |     use ast::{self, Assertion, AssertionKind};\n     |               ^^^^\n\nwarning: unused imports: `ErrorKind`, `Hir`, and `self`\n    --> regex-syntax/src/hir/translate.rs:2544:15\n     |\n2544 |     use hir::{self, Hir, ErrorKind};\n     |               ^^^^  ^^^  ^^^^^^^^^\n\nwarning: unused import: `unicode`\n    --> regex-syntax/src/hir/translate.rs:2545:9\n     |\n2545 |     use unicode;\n     |         ^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 20 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 20 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position::default(), end: Position::default() },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2554:55\n     |\n2554 |         span: Span { start: Position::default(), end: Position::default() },\n     |                                                       ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2563:36\n     |\n2563 |     assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::AsciiNegate));\n     |                                    ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `self`\n    --> regex-syntax/src/hir/translate.rs:2543:15\n     |\n2543 |     use ast::{self, Assertion, AssertionKind};\n     |               ^^^^\n\nwarning: unused imports: `ErrorKind` and `Hir`\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |     use hir::{self, Hir, ErrorKind};\n     |                     ^^^  ^^^^^^^^^\n\nwarning: unused import: `unicode`\n    --> regex-syntax/src/hir/translate.rs:2545:9\n     |\n2545 |     use unicode;\n     |         ^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 20 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 20 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{self, Assertion, AssertionKind};",
                "    use hir::{self, Hir, ErrorKind};",
                "    use unicode;",
                "",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let asst = Assertion {",
                "        span: Span { start: Position::default(), end: Position::default() },",
                "        kind: AssertionKind::NotWordBoundary,",
                "    };",
                "",
                "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                "    let result = translator_instance.hir_assertion(&asst);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let asst = Assertion {",
                  "    span: Span { start: Position::default(), end: Position::default() },",
                  "    kind: AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let asst = Assertion {",
                  "    span: Span { start: Position::default(), end: Position::default() },",
                  "    kind: AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::WordBoundary(hir::WordBoundary::AsciiNegate));"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let asst = Assertion {",
                  "    span: Span { start: Position::default(), end: Position::default() },",
                  "    kind: AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    let error = translator_instance.hir_assertion(&asst);",
                  "    assert!(error.is_err());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let asst = Assertion {",
                  "    span: Span { start: Position::default(), end: Position::default() },",
                  "    kind: AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    let error = translator_instance.hir_assertion(&asst);",
                  "    assert_eq!(error.unwrap_err().kind, ErrorKind::InvalidUtf8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{self, Assertion, AssertionKind};",
                  "    use hir::{self, Hir, ErrorKind};",
                  "    use unicode;",
                  "",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let asst = Assertion {",
                  "        span: Span { start: Position::default(), end: Position::default() },",
                  "        kind: AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let asst = Assertion {",
                  "    span: Span { start: Position::default(), end: Position::default() },",
                  "    kind: AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{self, Assertion, AssertionKind};",
                  "    use hir::{self, Hir, ErrorKind};",
                  "    use unicode;",
                  "",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let asst = Assertion {",
                  "        span: Span { start: Position::default(), end: Position::default() },",
                  "        kind: AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let asst = Assertion {",
                  "    span: Span { start: Position::default(), end: Position::default() },",
                  "    kind: AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{self, Assertion, AssertionKind};",
                  "    use hir::{self, Hir, ErrorKind};",
                  "    use unicode;",
                  "",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let asst = Assertion {",
                  "        span: Span { start: Position::default(), end: Position::default() },",
                  "        kind: AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let asst = Assertion {",
                  "    span: Span { start: Position::default(), end: Position::default() },",
                  "    kind: AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    let error = translator_instance.hir_assertion(&asst);",
                  "    assert!(error.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{self, Assertion, AssertionKind};",
                  "    use hir::{self, Hir, ErrorKind};",
                  "    use unicode;",
                  "",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let asst = Assertion {",
                  "        span: Span { start: Position::default(), end: Position::default() },",
                  "        kind: AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let asst = Assertion {",
                  "    span: Span { start: Position::default(), end: Position::default() },",
                  "    kind: AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    let error = translator_instance.hir_assertion(&asst);",
                  "    assert_eq!(error.unwrap_err().kind, ErrorKind::InvalidUtf8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position::default(), end: Position::default() },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2554:55\n     |\n2554 |         span: Span { start: Position::default(), end: Position::default() },\n     |                                                       ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     span: Span { start: Position::default(), end: Position::default() },\n     |                         ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2566:51\n     |\n2566 |     span: Span { start: Position::default(), end: Position::default() },\n     |                                                   ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `self`\n    --> regex-syntax/src/hir/translate.rs:2543:15\n     |\n2543 |     use ast::{self, Assertion, AssertionKind};\n     |               ^^^^\n\nwarning: unused imports: `ErrorKind`, `Hir`, and `self`\n    --> regex-syntax/src/hir/translate.rs:2544:15\n     |\n2544 |     use hir::{self, Hir, ErrorKind};\n     |               ^^^^  ^^^  ^^^^^^^^^\n\nwarning: unused import: `unicode`\n    --> regex-syntax/src/hir/translate.rs:2545:9\n     |\n2545 |     use unicode;\n     |         ^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 20 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 20 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position::default(), end: Position::default() },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2554:55\n     |\n2554 |         span: Span { start: Position::default(), end: Position::default() },\n     |                                                       ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     span: Span { start: Position::default(), end: Position::default() },\n     |                         ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2566:51\n     |\n2566 |     span: Span { start: Position::default(), end: Position::default() },\n     |                                                   ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `self`\n    --> regex-syntax/src/hir/translate.rs:2543:15\n     |\n2543 |     use ast::{self, Assertion, AssertionKind};\n     |               ^^^^\n\nwarning: unused imports: `ErrorKind`, `Hir`, and `self`\n    --> regex-syntax/src/hir/translate.rs:2544:15\n     |\n2544 |     use hir::{self, Hir, ErrorKind};\n     |               ^^^^  ^^^  ^^^^^^^^^\n\nwarning: unused import: `unicode`\n    --> regex-syntax/src/hir/translate.rs:2545:9\n     |\n2545 |     use unicode;\n     |         ^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 20 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 20 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position::default(), end: Position::default() },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2554:55\n     |\n2554 |         span: Span { start: Position::default(), end: Position::default() },\n     |                                                       ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     span: Span { start: Position::default(), end: Position::default() },\n     |                         ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2566:51\n     |\n2566 |     span: Span { start: Position::default(), end: Position::default() },\n     |                                                   ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `self`\n    --> regex-syntax/src/hir/translate.rs:2543:15\n     |\n2543 |     use ast::{self, Assertion, AssertionKind};\n     |               ^^^^\n\nwarning: unused imports: `ErrorKind`, `Hir`, and `self`\n    --> regex-syntax/src/hir/translate.rs:2544:15\n     |\n2544 |     use hir::{self, Hir, ErrorKind};\n     |               ^^^^  ^^^  ^^^^^^^^^\n\nwarning: unused import: `unicode`\n    --> regex-syntax/src/hir/translate.rs:2545:9\n     |\n2545 |     use unicode;\n     |         ^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 20 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 20 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2554:29\n     |\n2554 |         span: Span { start: Position::default(), end: Position::default() },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2554:55\n     |\n2554 |         span: Span { start: Position::default(), end: Position::default() },\n     |                                                       ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2566:25\n     |\n2566 |     span: Span { start: Position::default(), end: Position::default() },\n     |                         ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2566:51\n     |\n2566 |     span: Span { start: Position::default(), end: Position::default() },\n     |                                                   ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `self`\n    --> regex-syntax/src/hir/translate.rs:2543:15\n     |\n2543 |     use ast::{self, Assertion, AssertionKind};\n     |               ^^^^\n\nwarning: unused imports: `Hir` and `self`\n    --> regex-syntax/src/hir/translate.rs:2544:15\n     |\n2544 |     use hir::{self, Hir, ErrorKind};\n     |               ^^^^  ^^^\n\nwarning: unused import: `unicode`\n    --> regex-syntax/src/hir/translate.rs:2545:9\n     |\n2545 |     use unicode;\n     |         ^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 20 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 20 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{self, Assertion, AssertionKind};",
                "    use hir::{self, Hir};",
                "",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "",
                "    let asst = Assertion {",
                "        span: Span { start: Position::default(), end: Position::default() },",
                "        kind: AssertionKind::WordBoundary,",
                "    };",
                "",
                "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                "    let result = translator_instance.hir_assertion(&asst);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let asst = Assertion {",
                  "    span: Span { start: Position::default(), end: Position::default() },",
                  "    kind: AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let asst = Assertion {",
                  "    span: Span { start: Position::default(), end: Position::default() },",
                  "    kind: AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::WordBoundary(hir::WordBoundary::AsciiNegate));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{self, Assertion, AssertionKind};",
                  "    use hir::{self, Hir};",
                  "",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let asst = Assertion {",
                  "        span: Span { start: Position::default(), end: Position::default() },",
                  "        kind: AssertionKind::WordBoundary,",
                  "    };",
                  "",
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let asst = Assertion {",
                  "    span: Span { start: Position::default(), end: Position::default() },",
                  "    kind: AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    use ast::{self, Assertion, AssertionKind};",
                  "    use hir::{self, Hir};",
                  "",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(true), ..Flags::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let asst = Assertion {",
                  "        span: Span { start: Position::default(), end: Position::default() },",
                  "        kind: AssertionKind::WordBoundary,",
                  "    };",
                  "",
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let asst = Assertion {",
                  "    span: Span { start: Position::default(), end: Position::default() },",
                  "    kind: AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::WordBoundary(hir::WordBoundary::AsciiNegate));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: Position::default(), end: Position::default() },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:55\n     |\n2553 |         span: Span { start: Position::default(), end: Position::default() },\n     |                                                       ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2565:25\n     |\n2565 |     span: Span { start: Position::default(), end: Position::default() },\n     |                         ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2565:51\n     |\n2565 |     span: Span { start: Position::default(), end: Position::default() },\n     |                                                   ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `self`\n    --> regex-syntax/src/hir/translate.rs:2543:15\n     |\n2543 |     use ast::{self, Assertion, AssertionKind};\n     |               ^^^^\n\nwarning: unused imports: `Hir` and `self`\n    --> regex-syntax/src/hir/translate.rs:2544:15\n     |\n2544 |     use hir::{self, Hir};\n     |               ^^^^  ^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 19 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 19 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: Position::default(), end: Position::default() },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:55\n     |\n2553 |         span: Span { start: Position::default(), end: Position::default() },\n     |                                                       ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2565:25\n     |\n2565 |     span: Span { start: Position::default(), end: Position::default() },\n     |                         ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2565:51\n     |\n2565 |     span: Span { start: Position::default(), end: Position::default() },\n     |                                                   ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2571:29\n     |\n2571 |     assert_eq!(hir.kind(), &HirKind::WordBoundary(hir::WordBoundary::AsciiNegate));\n     |                             ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `self`\n    --> regex-syntax/src/hir/translate.rs:2543:15\n     |\n2543 |     use ast::{self, Assertion, AssertionKind};\n     |               ^^^^\n\nwarning: unused import: `Hir`\n    --> regex-syntax/src/hir/translate.rs:2544:21\n     |\n2544 |     use hir::{self, Hir};\n     |                     ^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 19 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 19 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    use ast::{self, Assertion, AssertionKind};",
                "    use hir::{self, Hir};",
                "",
                "    let mut translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "",
                "    let asst = Assertion {",
                "        span: Span { start: Position::default(), end: Position::default() },",
                "        kind: AssertionKind::NotWordBoundary,",
                "    };",
                "",
                "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                "    let result = translator_instance.hir_assertion(&asst);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: true };",
                  "    let asst = Assertion { span: Span { start: Position::default(), end: Position::default() }, kind: AssertionKind::NotWordBoundary };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    assert!(result.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    use ast::{self, Assertion, AssertionKind};",
                  "    use hir::{self, Hir};",
                  "",
                  "    let mut translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let asst = Assertion {",
                  "        span: Span { start: Position::default(), end: Position::default() },",
                  "        kind: AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: true };",
                  "    let asst = Assertion { span: Span { start: Position::default(), end: Position::default() }, kind: AssertionKind::NotWordBoundary };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test_pattern\");",
                  "    let result = translator_instance.hir_assertion(&asst);",
                  "    assert!(result.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: Position::default(), end: Position::default() },\n     |                             ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2553:55\n     |\n2553 |         span: Span { start: Position::default(), end: Position::default() },\n     |                                                       ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2560:48\n     |\n2560 |     let asst = Assertion { span: Span { start: Position::default(), end: Position::default() }, kind: AssertionKind::NotWordBoundary };\n     |                                                ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `Position`\n    --> regex-syntax/src/hir/translate.rs:2560:74\n     |\n2560 |     let asst = Assertion { span: Span { start: Position::default(), end: Position::default() }, kind: AssertionKind::NotWordBoundary };\n     |                                                                          ^^^^^^^^ use of undeclared type `Position`\n     |\nhelp: consider importing this struct\n     |\n2535 +    use ast::Position;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused import: `self`\n    --> regex-syntax/src/hir/translate.rs:2543:15\n     |\n2543 |     use ast::{self, Assertion, AssertionKind};\n     |               ^^^^\n\nwarning: unused imports: `Hir` and `self`\n    --> regex-syntax/src/hir/translate.rs:2544:15\n     |\n2544 |     use hir::{self, Hir};\n     |               ^^^^  ^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 19 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 19 warnings emitted\n"
                }
              ],
              "repaired": [
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: asst.kind matches ast::AssertionKind::NotWordBoundary is true\n",
        "// constraint: unicode is false\n",
        "// constraint: self.trans().allow_invalid_utf8 is false\n",
        "// expected return value/type: Err(self.error(\n                            asst.span, ErrorKind::InvalidUtf8))\n"
      ],
      "input_infer": "test input ranges: asst.kind = ast::AssertionKind::NotWordBoundary, unicode = false, self.trans().allow_invalid_utf8 = false, span.start = 0, span.end = 1\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let asst = ast::Assertion {",
                "        span,",
                "        kind: ast::AssertionKind::NotWordBoundary,",
                "    };",
                "",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: Some(false),",
                "            multi_line: Some(false),",
                "            dot_matches_new_line: Some(false),",
                "            swap_greed: Some(false),",
                "            unicode: Some(false),",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let translator_i = TranslatorI {",
                "        trans: &translator,",
                "        pattern: \"\",",
                "    };",
                "",
                "    let _result = translator_i.hir_assertion(&asst);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let asst = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: Some(false),",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let translator_i = TranslatorI {",
                  "    trans: &translator,",
                  "    pattern: \"\",",
                  "    };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let asst = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: Some(false),",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let translator_i = TranslatorI {",
                  "    trans: &translator,",
                  "    pattern: \"\",",
                  "    };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::InvalidUtf8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: Some(false),",
                  "            swap_greed: Some(false),",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI {",
                  "        trans: &translator,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    let _result = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let asst = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: Some(false),",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let translator_i = TranslatorI {",
                  "    trans: &translator,",
                  "    pattern: \"\",",
                  "    };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: Some(false),",
                  "            swap_greed: Some(false),",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI {",
                  "        trans: &translator,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    let _result = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let asst = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: Some(false),",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let translator_i = TranslatorI {",
                  "    trans: &translator,",
                  "    pattern: \"\",",
                  "    };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::InvalidUtf8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2543:30\n     |\n2543 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2543:38\n     |\n2543 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2567:30\n     |\n2567 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2567:38\n     |\n2567 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2543:30\n     |\n2543 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2543:38\n     |\n2543 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2567:30\n     |\n2567 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2567:38\n     |\n2567 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let asst = ast::Assertion {",
                "        span,",
                "        kind: ast::AssertionKind::NotWordBoundary,",
                "    };",
                "",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: Some(false),",
                "            multi_line: Some(false),",
                "            dot_matches_new_line: Some(false),",
                "            swap_greed: Some(false),",
                "            unicode: Some(true),",
                "        }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "",
                "    let translator_i = TranslatorI {",
                "        trans: &translator,",
                "        pattern: \"\",",
                "    };",
                "",
                "    let _result = translator_i.hir_assertion(&asst);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let asst = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: Some(false),",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let translator_i = TranslatorI {",
                  "    trans: &translator,",
                  "    pattern: \"\",",
                  "    };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let asst = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: Some(false),",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let translator_i = TranslatorI {",
                  "    trans: &translator,",
                  "    pattern: \"\",",
                  "    };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::InvalidUtf8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: Some(false),",
                  "            swap_greed: Some(false),",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI {",
                  "        trans: &translator,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    let _result = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let asst = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: Some(false),",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let translator_i = TranslatorI {",
                  "    trans: &translator,",
                  "    pattern: \"\",",
                  "    };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: Some(false),",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: Some(false),",
                  "            swap_greed: Some(false),",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI {",
                  "        trans: &translator,",
                  "        pattern: \"\",",
                  "    };",
                  "",
                  "    let _result = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let asst = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: Some(false),",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: Some(false),",
                  "    swap_greed: Some(false),",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let translator_i = TranslatorI {",
                  "    trans: &translator,",
                  "    pattern: \"\",",
                  "    };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert_eq!(result.err().unwrap().kind, ErrorKind::InvalidUtf8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2543:30\n     |\n2543 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2543:38\n     |\n2543 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2567:30\n     |\n2567 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2567:38\n     |\n2567 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2543:30\n     |\n2543 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2543:38\n     |\n2543 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2567:30\n     |\n2567 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2567:38\n     |\n2567 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: asst.kind matches ast::AssertionKind::WordBoundary is true\n",
        "// constraint: asst.kind matches ast::AssertionKind::WordBoundary is true\n",
        "// constraint: unicode is true\n",
        "// expected return value/type: Ok(match asst.kind {\n            ast::AssertionKind::StartLine => {\n                Hir::anchor(if multi_line {\n                    hir::Anchor::StartLine\n                } else {\n                    hir::Anchor::StartText\n                })\n            }\n            ast::AssertionKind::EndLine => {\n                Hir::anchor(if multi_line {\n                    hir::Anchor::EndLine\n                } else {\n                    hir::Anchor::EndText\n                })\n            }\n            ast::AssertionKind::StartText => {\n                Hir::anchor(hir::Anchor::StartText)\n            }\n            ast::AssertionKind::EndText => {\n                Hir::anchor(hir::Anchor::EndText)\n            }\n            ast::AssertionKind::WordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::Unicode\n                } else {\n                    hir::WordBoundary::Ascii\n                })\n            }\n            ast::AssertionKind::NotWordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::UnicodeNegate\n                } else {\n                    // It is possible for negated ASCII word boundaries to\n                    // match at invalid UTF-8 boundaries, even when searching\n                    // valid UTF-8.\n                    if !self.trans().allow_invalid_utf8 {\n                        return Err(self.error(\n                            asst.span, ErrorKind::InvalidUtf8));\n                    }\n                    hir::WordBoundary::AsciiNegate\n                })\n            }\n        })\n"
      ],
      "input_infer": "asst.kind: {WordBoundary}, unicode: {true}, multi_line: {true, false}\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(true),",
                "            multi_line: Some(true),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \".*\";",
                "    let translator_i = TranslatorI::new(&trans, pattern);",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: Position(0), end: Position(1) },",
                "        kind: ast::AssertionKind::WordBoundary,",
                "    };",
                "    let _result = translator_i.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::WordBoundary(hir::WordBoundary::Unicode));"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_always_utf8());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_all_assertions());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_anchored_start());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_anchored_end());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_any_anchored_start());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_any_anchored_end());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_match_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::WordBoundary(hir::WordBoundary::Unicode));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_always_utf8());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_all_assertions());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_anchored_start());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_anchored_end());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_any_anchored_start());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_any_anchored_end());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_match_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:43\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2576:29\n     |\n2576 |     assert_eq!(hir.kind(), &HirKind::WordBoundary(hir::WordBoundary::Unicode));\n     |                             ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:43\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:43\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:43\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:43\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:43\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:43\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:43\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:43\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(true),",
                "            multi_line: Some(false),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \".*\";",
                "    let translator_i = TranslatorI::new(&trans, pattern);",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: Position(0), end: Position(1) },",
                "        kind: ast::AssertionKind::WordBoundary,",
                "    };",
                "    let _result = translator_i.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::WordBoundary(hir::WordBoundary::Unicode));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            multi_line: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            multi_line: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::WordBoundary(hir::WordBoundary::Unicode));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:43\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2576:29\n     |\n2576 |     assert_eq!(hir.kind(), &HirKind::WordBoundary(hir::WordBoundary::Unicode));\n     |                             ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:43\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(false),",
                "            multi_line: Some(true),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \".*\";",
                "    let translator_i = TranslatorI::new(&trans, pattern);",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: Position(0), end: Position(1) },",
                "        kind: ast::AssertionKind::WordBoundary,",
                "    };",
                "    let _result = translator_i.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::Unicode));"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::AsciiNegate));"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::UnicodeNegate));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::Unicode));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::AsciiNegate));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::UnicodeNegate));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:43\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2576:36\n     |\n2576 |     assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::Unicode));\n     |                                    ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:43\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:43\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2588:25\n     |\n2588 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2588:43\n     |\n2588 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2593:36\n     |\n2593 |     assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));\n     |                                    ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:43\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2588:25\n     |\n2588 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2588:43\n     |\n2588 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:43\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2588:25\n     |\n2588 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2588:43\n     |\n2588 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2605:25\n     |\n2605 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2605:43\n     |\n2605 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2610:36\n     |\n2610 |     assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::AsciiNegate));\n     |                                    ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:43\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2588:25\n     |\n2588 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2588:43\n     |\n2588 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2605:25\n     |\n2605 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2605:43\n     |\n2605 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:43\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2588:25\n     |\n2588 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2588:43\n     |\n2588 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2605:25\n     |\n2605 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2605:43\n     |\n2605 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2622:25\n     |\n2622 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2622:43\n     |\n2622 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2627:36\n     |\n2627 |     assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::UnicodeNegate));\n     |                                    ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:43\n     |\n2571 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2588:25\n     |\n2588 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2588:43\n     |\n2588 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2605:25\n     |\n2605 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2605:43\n     |\n2605 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2622:25\n     |\n2622 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2622:43\n     |\n2622 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(false),",
                "            multi_line: Some(false),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let pattern = \".*\";",
                "    let translator_i = TranslatorI::new(&trans, pattern);",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: Position(0), end: Position(1) },",
                "        kind: ast::AssertionKind::WordBoundary,",
                "    };",
                "    let _result = translator_i.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::Unicode));"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::Unicode));"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::AsciiNegate));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            multi_line: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            multi_line: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::Unicode));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            multi_line: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            multi_line: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            multi_line: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            multi_line: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::Unicode));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            multi_line: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            multi_line: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            multi_line: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(false),",
                  "            multi_line: Some(false),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let pattern = \".*\";",
                  "    let translator_i = TranslatorI::new(&trans, pattern);",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(1) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(false),",
                  "    multi_line: Some(false),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(1) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::AsciiNegate));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:25\n     |\n2569 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:43\n     |\n2569 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2573:41\n     |\n2573 |     assert_eq!(result.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::Unicode));\n     |                                         ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:25\n     |\n2569 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:43\n     |\n2569 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:25\n     |\n2569 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:43\n     |\n2569 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2583:25\n     |\n2583 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2583:43\n     |\n2583 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2587:41\n     |\n2587 |     assert_eq!(result.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));\n     |                                         ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:25\n     |\n2569 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:43\n     |\n2569 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2583:25\n     |\n2583 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2583:43\n     |\n2583 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:25\n     |\n2569 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:43\n     |\n2569 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2583:25\n     |\n2583 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2583:43\n     |\n2583 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2597:25\n     |\n2597 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2597:43\n     |\n2597 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2601:41\n     |\n2601 |     assert_eq!(result.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::Unicode));\n     |                                         ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:25\n     |\n2569 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:43\n     |\n2569 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2583:25\n     |\n2583 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2583:43\n     |\n2583 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2597:25\n     |\n2597 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2597:43\n     |\n2597 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:25\n     |\n2569 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:43\n     |\n2569 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2583:25\n     |\n2583 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2583:43\n     |\n2583 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2597:25\n     |\n2597 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2597:43\n     |\n2597 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2611:25\n     |\n2611 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2611:43\n     |\n2611 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2615:41\n     |\n2615 |     assert_eq!(result.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));\n     |                                         ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:25\n     |\n2569 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:43\n     |\n2569 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2583:25\n     |\n2583 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2583:43\n     |\n2583 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2597:25\n     |\n2597 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2597:43\n     |\n2597 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2611:25\n     |\n2611 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2611:43\n     |\n2611 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:25\n     |\n2569 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:43\n     |\n2569 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2583:25\n     |\n2583 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2583:43\n     |\n2583 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2597:25\n     |\n2597 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2597:43\n     |\n2597 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2611:25\n     |\n2611 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2611:43\n     |\n2611 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2625:25\n     |\n2625 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2625:43\n     |\n2625 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2629:41\n     |\n2629 |     assert_eq!(result.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::AsciiNegate));\n     |                                         ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:29\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:47\n     |\n2555 |         span: Span { start: Position(0), end: Position(1) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:25\n     |\n2569 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2569:43\n     |\n2569 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2583:25\n     |\n2583 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2583:43\n     |\n2583 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2597:25\n     |\n2597 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2597:43\n     |\n2597 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2611:25\n     |\n2611 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2611:43\n     |\n2611 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2625:25\n     |\n2625 |     span: Span { start: Position(0), end: Position(1) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2625:43\n     |\n2625 |     span: Span { start: Position(0), end: Position(1) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: asst.kind matches ast::AssertionKind::WordBoundary is true\n",
        "// constraint: asst.kind matches ast::AssertionKind::WordBoundary is true\n",
        "// constraint: unicode is false\n",
        "// expected return value/type: Ok(match asst.kind {\n            ast::AssertionKind::StartLine => {\n                Hir::anchor(if multi_line {\n                    hir::Anchor::StartLine\n                } else {\n                    hir::Anchor::StartText\n                })\n            }\n            ast::AssertionKind::EndLine => {\n                Hir::anchor(if multi_line {\n                    hir::Anchor::EndLine\n                } else {\n                    hir::Anchor::EndText\n                })\n            }\n            ast::AssertionKind::StartText => {\n                Hir::anchor(hir::Anchor::StartText)\n            }\n            ast::AssertionKind::EndText => {\n                Hir::anchor(hir::Anchor::EndText)\n            }\n            ast::AssertionKind::WordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::Unicode\n                } else {\n                    hir::WordBoundary::Ascii\n                })\n            }\n            ast::AssertionKind::NotWordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::UnicodeNegate\n                } else {\n                    // It is possible for negated ASCII word boundaries to\n                    // match at invalid UTF-8 boundaries, even when searching\n                    // valid UTF-8.\n                    if !self.trans().allow_invalid_utf8 {\n                        return Err(self.error(\n                            asst.span, ErrorKind::InvalidUtf8));\n                    }\n                    hir::WordBoundary::AsciiNegate\n                })\n            }\n        })\n"
      ],
      "input_infer": "ast::AssertionKind::WordBoundary where unicode is false and multi_line is true or false\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            multi_line: Some(true),",
                "            unicode: Some(false),",
                "            ..Flags::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: Position(0), end: Position(0) },",
                "        kind: ast::AssertionKind::StartLine,",
                "    };",
                "    let translator_i = TranslatorI::new(&trans, \"\");",
                "    let _ = translator_i.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine, };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    assert_eq!(translator_i.hir_assertion(&assertion), Ok(Hir::anchor(hir::Anchor::StartLine)));"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine, };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let assertion_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };",
                  "    assert_eq!(translator_i.hir_assertion(&assertion_end_line), Ok(Hir::anchor(hir::Anchor::EndLine)));"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine, };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let assertion_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };",
                  "    let assertion_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText, };",
                  "    assert_eq!(translator_i.hir_assertion(&assertion_start_text), Ok(Hir::anchor(hir::Anchor::StartText)));"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine, };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let assertion_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };",
                  "    let assertion_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText, };",
                  "    let assertion_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    assert_eq!(translator_i.hir_assertion(&assertion_end_text), Ok(Hir::anchor(hir::Anchor::EndText)));"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine, };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let assertion_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };",
                  "    let assertion_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText, };",
                  "    let assertion_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let assertion_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary, };",
                  "    assert_eq!(translator_i.hir_assertion(&assertion_word_boundary), Ok(Hir::word_boundary(hir::WordBoundary::Ascii)));"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine, };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let assertion_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };",
                  "    let assertion_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText, };",
                  "    let assertion_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let assertion_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary, };",
                  "    let assertion_not_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::NotWordBoundary, };",
                  "    assert_eq!(translator_i.hir_assertion(&assertion_not_word_boundary), Err(translator_i.error(assertion_not_word_boundary.span, ErrorKind::InvalidUtf8)));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine, };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    assert_eq!(translator_i.hir_assertion(&assertion), Ok(Hir::anchor(hir::Anchor::StartLine)));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine, };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let assertion_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };",
                  "    assert_eq!(translator_i.hir_assertion(&assertion_end_line), Ok(Hir::anchor(hir::Anchor::EndLine)));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine, };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let assertion_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };",
                  "    let assertion_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText, };",
                  "    assert_eq!(translator_i.hir_assertion(&assertion_start_text), Ok(Hir::anchor(hir::Anchor::StartText)));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine, };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let assertion_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };",
                  "    let assertion_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText, };",
                  "    let assertion_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    assert_eq!(translator_i.hir_assertion(&assertion_end_text), Ok(Hir::anchor(hir::Anchor::EndText)));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine, };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let assertion_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };",
                  "    let assertion_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText, };",
                  "    let assertion_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let assertion_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary, };",
                  "    assert_eq!(translator_i.hir_assertion(&assertion_word_boundary), Ok(Hir::word_boundary(hir::WordBoundary::Ascii)));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine, };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let assertion_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };",
                  "    let assertion_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText, };",
                  "    let assertion_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let assertion_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary, };",
                  "    let assertion_not_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::NotWordBoundary, };",
                  "    assert_eq!(translator_i.hir_assertion(&assertion_not_word_boundary), Err(translator_i.error(assertion_not_word_boundary.span, ErrorKind::InvalidUtf8)));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:47\n     |\n2553 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:58\n     |\n2559 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine, };\n     |                                                          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:76\n     |\n2559 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine, };\n     |                                                                            ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:47\n     |\n2553 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:58\n     |\n2559 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine, };\n     |                                                          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:76\n     |\n2559 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine, };\n     |                                                                            ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:67\n     |\n2561 |     let assertion_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };\n     |                                                                   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:85\n     |\n2561 |     let assertion_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };\n     |                                                                                     ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:47\n     |\n2553 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:58\n     |\n2559 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine, };\n     |                                                          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:76\n     |\n2559 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine, };\n     |                                                                            ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:67\n     |\n2561 |     let assertion_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };\n     |                                                                   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:85\n     |\n2561 |     let assertion_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };\n     |                                                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:69\n     |\n2562 |     let assertion_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText, };\n     |                                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:87\n     |\n2562 |     let assertion_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText, };\n     |                                                                                       ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:47\n     |\n2553 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:58\n     |\n2559 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine, };\n     |                                                          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:76\n     |\n2559 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine, };\n     |                                                                            ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:67\n     |\n2561 |     let assertion_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };\n     |                                                                   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:85\n     |\n2561 |     let assertion_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };\n     |                                                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:69\n     |\n2562 |     let assertion_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText, };\n     |                                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:87\n     |\n2562 |     let assertion_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText, };\n     |                                                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:67\n     |\n2563 |     let assertion_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                                   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:85\n     |\n2563 |     let assertion_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                                                     ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:47\n     |\n2553 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:58\n     |\n2559 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine, };\n     |                                                          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:76\n     |\n2559 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine, };\n     |                                                                            ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:67\n     |\n2561 |     let assertion_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };\n     |                                                                   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:85\n     |\n2561 |     let assertion_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };\n     |                                                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:69\n     |\n2562 |     let assertion_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText, };\n     |                                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:87\n     |\n2562 |     let assertion_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText, };\n     |                                                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:67\n     |\n2563 |     let assertion_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                                   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:85\n     |\n2563 |     let assertion_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:72\n     |\n2564 |     let assertion_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBou...\n     |                                                                        ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:90\n     |\n2564 |     let assertion_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBou...\n     |                                                                                          ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:47\n     |\n2553 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:58\n     |\n2559 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine, };\n     |                                                          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:76\n     |\n2559 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine, };\n     |                                                                            ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:67\n     |\n2561 |     let assertion_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };\n     |                                                                   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:85\n     |\n2561 |     let assertion_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };\n     |                                                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:69\n     |\n2562 |     let assertion_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText, };\n     |                                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2562:87\n     |\n2562 |     let assertion_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText, };\n     |                                                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:67\n     |\n2563 |     let assertion_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                                   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2563:85\n     |\n2563 |     let assertion_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:72\n     |\n2564 |     let assertion_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBou...\n     |                                                                        ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:90\n     |\n2564 |     let assertion_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBou...\n     |                                                                                          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:76\n     |\n2565 |     let assertion_not_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::Not...\n     |                                                                            ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:94\n     |\n2565 |     let assertion_not_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::Not...\n     |                                                                                              ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            multi_line: Some(true),",
                "            unicode: Some(false),",
                "            ..Flags::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: Position(0), end: Position(0) },",
                "        kind: ast::AssertionKind::EndLine,",
                "    };",
                "    let translator_i = TranslatorI::new(&trans, \"\");",
                "    let _ = translator_i.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    assert_eq!(translator_i.hir_assertion(&assertion), Ok(Hir::anchor(hir::Anchor::EndLine)));"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    assert!(trans.flags.get().multi_line.unwrap());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    assert!(!trans.flags.get().unicode.unwrap());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    assert!(!trans.allow_invalid_utf8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    assert_eq!(translator_i.hir_assertion(&assertion), Ok(Hir::anchor(hir::Anchor::EndLine)));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    assert!(trans.flags.get().multi_line.unwrap());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    assert!(!trans.flags.get().unicode.unwrap());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    assert!(!trans.allow_invalid_utf8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:47\n     |\n2553 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:58\n     |\n2559 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };\n     |                                                          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:76\n     |\n2559 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };\n     |                                                                            ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:47\n     |\n2553 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:58\n     |\n2559 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };\n     |                                                          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:76\n     |\n2559 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };\n     |                                                                            ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:47\n     |\n2553 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:58\n     |\n2559 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };\n     |                                                          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:76\n     |\n2559 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };\n     |                                                                            ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:47\n     |\n2553 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:58\n     |\n2559 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };\n     |                                                          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2559:76\n     |\n2559 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine, };\n     |                                                                            ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            multi_line: Some(true),",
                "            unicode: Some(false),",
                "            ..Flags::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: Position(0), end: Position(0) },",
                "        kind: ast::AssertionKind::StartText,",
                "    };",
                "    let translator_i = TranslatorI::new(&trans, \"\");",
                "    let _ = translator_i.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    multi_line: Some(true),",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    multi_line: Some(true),",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    multi_line: Some(true),",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    multi_line: Some(true),",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2553:47\n     |\n2553 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:25\n     |\n2568 |     span: Span { start: Position(0), end: Position(0) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2568:43\n     |\n2568 |     span: Span { start: Position(0), end: Position(0) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2571:36\n     |\n2571 |     assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));\n     |                                    ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:29\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:47\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:25\n     |\n2565 |     span: Span { start: Position(0), end: Position(0) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:43\n     |\n2565 |     span: Span { start: Position(0), end: Position(0) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            multi_line: Some(true),",
                "            unicode: Some(false),",
                "            ..Flags::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: Position(0), end: Position(0) },",
                "        kind: ast::AssertionKind::EndText,",
                "    };",
                "    let translator_i = TranslatorI::new(&trans, \"\");",
                "    let _ = translator_i.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    multi_line: Some(true),",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    multi_line: Some(true),",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::Anchor(hir::Anchor::EndText));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    multi_line: Some(true),",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    multi_line: Some(true),",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::Anchor(hir::Anchor::EndText));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:29\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:47\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:25\n     |\n2565 |     span: Span { start: Position(0), end: Position(0) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:43\n     |\n2565 |     span: Span { start: Position(0), end: Position(0) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2570:41\n     |\n2570 |     assert_eq!(result.unwrap().kind(), &HirKind::Anchor(hir::Anchor::EndText));\n     |                                         ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:29\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:47\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:25\n     |\n2565 |     span: Span { start: Position(0), end: Position(0) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:43\n     |\n2565 |     span: Span { start: Position(0), end: Position(0) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            multi_line: Some(false),",
                "            unicode: Some(false),",
                "            ..Flags::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: Position(0), end: Position(0) },",
                "        kind: ast::AssertionKind::WordBoundary,",
                "    };",
                "    let translator_i = TranslatorI::new(&trans, \"\");",
                "    let _ = translator_i.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(false), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(false), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(false), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(hir_result.is_always_utf8());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(false), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(hir_result.is_all_assertions());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(false), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(!hir_result.is_anchored_start());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(false), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(!hir_result.is_anchored_end());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(false), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(!hir_result.is_any_anchored_start());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(false), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(!hir_result.is_any_anchored_end());"
                ],
                [
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(false), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(hir_result.is_match_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(false),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(false), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(false),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(false), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(false),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(false), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(hir_result.is_always_utf8());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(false),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(false), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(hir_result.is_all_assertions());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(false),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(false), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(!hir_result.is_anchored_start());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(false),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(false), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(!hir_result.is_anchored_end());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(false),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(false), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(!hir_result.is_any_anchored_start());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(false),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(false), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(!hir_result.is_any_anchored_end());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(false),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(false), unicode: Some(false), ..Flags::default() }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(hir_result.is_match_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:29\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:47\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:58\n     |\n2556 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:76\n     |\n2556 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                            ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2560:36\n     |\n2560 |     assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));\n     |                                    ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:29\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:47\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:58\n     |\n2556 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:76\n     |\n2556 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                            ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:29\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:47\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:58\n     |\n2556 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:76\n     |\n2556 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                            ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:29\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:47\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:58\n     |\n2556 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:76\n     |\n2556 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                            ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:29\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:47\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:58\n     |\n2556 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:76\n     |\n2556 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                            ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:29\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:47\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:58\n     |\n2556 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:76\n     |\n2556 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                            ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:29\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:47\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:58\n     |\n2556 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:76\n     |\n2556 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                            ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:29\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:47\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:58\n     |\n2556 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:76\n     |\n2556 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                            ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:29\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:47\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:58\n     |\n2556 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                          ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2556:76\n     |\n2556 |     let assertion = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                            ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            multi_line: Some(false),",
                "            unicode: Some(false),",
                "            ..Flags::default()",
                "        }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: Position(0), end: Position(0) },",
                "        kind: ast::AssertionKind::NotWordBoundary,",
                "    };",
                "    let translator_i = TranslatorI::new(&trans, \"\");",
                "    let _ = translator_i.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    multi_line: Some(false),",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    multi_line: Some(false),",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), HirKind::WordBoundary(hir::WordBoundary::AsciiNegate));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(false),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    multi_line: Some(false),",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(false),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    multi_line: Some(false),",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), HirKind::WordBoundary(hir::WordBoundary::AsciiNegate));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:29\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:47\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:25\n     |\n2565 |     span: Span { start: Position(0), end: Position(0) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:43\n     |\n2565 |     span: Span { start: Position(0), end: Position(0) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2570:40\n     |\n2570 |     assert_eq!(result.unwrap().kind(), HirKind::WordBoundary(hir::WordBoundary::AsciiNegate));\n     |                                        ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:29\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:47\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:25\n     |\n2565 |     span: Span { start: Position(0), end: Position(0) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:43\n     |\n2565 |     span: Span { start: Position(0), end: Position(0) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let trans = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            multi_line: Some(false),",
                "            unicode: Some(false),",
                "            ..Flags::default()",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: Position(0), end: Position(0) },",
                "        kind: ast::AssertionKind::WordBoundary,",
                "    };",
                "    let translator_i = TranslatorI::new(&trans, \"\");",
                "    let _ = translator_i.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    multi_line: Some(false),",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    multi_line: Some(false),",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(false),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    multi_line: Some(false),",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let trans = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(false),",
                  "            unicode: Some(false),",
                  "            ..Flags::default()",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let trans = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    multi_line: Some(false),",
                  "    unicode: Some(false),",
                  "    ..Flags::default()",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&trans, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:29\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:47\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:25\n     |\n2565 |     span: Span { start: Position(0), end: Position(0) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:43\n     |\n2565 |     span: Span { start: Position(0), end: Position(0) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2571:36\n     |\n2571 |     assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));\n     |                                    ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:29\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2550:47\n     |\n2550 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:25\n     |\n2565 |     span: Span { start: Position(0), end: Position(0) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2565:43\n     |\n2565 |     span: Span { start: Position(0), end: Position(0) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "// constraint: asst.kind matches ast::AssertionKind::EndText is true\n",
        "// constraint: asst.kind matches ast::AssertionKind::EndText is true\n",
        "// expected return value/type: Ok(match asst.kind {\n            ast::AssertionKind::StartLine => {\n                Hir::anchor(if multi_line {\n                    hir::Anchor::StartLine\n                } else {\n                    hir::Anchor::StartText\n                })\n            }\n            ast::AssertionKind::EndLine => {\n                Hir::anchor(if multi_line {\n                    hir::Anchor::EndLine\n                } else {\n                    hir::Anchor::EndText\n                })\n            }\n            ast::AssertionKind::StartText => {\n                Hir::anchor(hir::Anchor::StartText)\n            }\n            ast::AssertionKind::EndText => {\n                Hir::anchor(hir::Anchor::EndText)\n            }\n            ast::AssertionKind::WordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::Unicode\n                } else {\n                    hir::WordBoundary::Ascii\n                })\n            }\n            ast::AssertionKind::NotWordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::UnicodeNegate\n                } else {\n                    // It is possible for negated ASCII word boundaries to\n                    // match at invalid UTF-8 boundaries, even when searching\n                    // valid UTF-8.\n                    if !self.trans().allow_invalid_utf8 {\n                        return Err(self.error(\n                            asst.span, ErrorKind::InvalidUtf8));\n                    }\n                    hir::WordBoundary::AsciiNegate\n                })\n            }\n        })\n"
      ],
      "input_infer": "asst.kind = ast::AssertionKind::StartLine, asst.kind = ast::AssertionKind::EndLine, asst.kind = ast::AssertionKind::StartText, asst.kind = ast::AssertionKind::EndText\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let pattern = \"\";",
                "    let translator_i = TranslatorI::new(&translator, pattern);",
                "    let asst = ast::Assertion {",
                "        span: Span { start: Position(0), end: Position(0) },",
                "        kind: ast::AssertionKind::StartLine,",
                "    };",
                "    translator_i.hir_assertion(&asst);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };",
                  "    let result_start_line = translator_i.hir_assertion(&asst_start_line);",
                  "    assert!(result_start_line.is_ok());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };",
                  "    let result_start_line = translator_i.hir_assertion(&asst_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    assert_eq!(hir_start_line.kind(), &HirKind::Anchor(hir::Anchor::StartText));"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };",
                  "    let result_start_line = translator_i.hir_assertion(&asst_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };",
                  "    let result_end_line = translator_i.hir_assertion(&asst_end_line);",
                  "    assert!(result_end_line.is_ok());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };",
                  "    let result_start_line = translator_i.hir_assertion(&asst_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };",
                  "    let result_end_line = translator_i.hir_assertion(&asst_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    assert_eq!(hir_end_line.kind(), &HirKind::Anchor(hir::Anchor::EndLine));"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };",
                  "    let result_start_line = translator_i.hir_assertion(&asst_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };",
                  "    let result_end_line = translator_i.hir_assertion(&asst_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };",
                  "    let result_start_text = translator_i.hir_assertion(&asst_start_text);",
                  "    assert!(result_start_text.is_ok());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };",
                  "    let result_start_line = translator_i.hir_assertion(&asst_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };",
                  "    let result_end_line = translator_i.hir_assertion(&asst_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };",
                  "    let result_start_text = translator_i.hir_assertion(&asst_start_text);",
                  "    let hir_start_text = result_start_text.unwrap();",
                  "    assert_eq!(hir_start_text.kind(), &HirKind::Anchor(hir::Anchor::StartText));"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };",
                  "    let result_start_line = translator_i.hir_assertion(&asst_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };",
                  "    let result_end_line = translator_i.hir_assertion(&asst_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };",
                  "    let result_start_text = translator_i.hir_assertion(&asst_start_text);",
                  "    let hir_start_text = result_start_text.unwrap();",
                  "    let asst_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText };",
                  "    let result_end_text = translator_i.hir_assertion(&asst_end_text);",
                  "    assert!(result_end_text.is_ok());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };",
                  "    let result_start_line = translator_i.hir_assertion(&asst_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };",
                  "    let result_end_line = translator_i.hir_assertion(&asst_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };",
                  "    let result_start_text = translator_i.hir_assertion(&asst_start_text);",
                  "    let hir_start_text = result_start_text.unwrap();",
                  "    let asst_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText };",
                  "    let result_end_text = translator_i.hir_assertion(&asst_end_text);",
                  "    let hir_end_text = result_end_text.unwrap();",
                  "    assert_eq!(hir_end_text.kind(), &HirKind::Anchor(hir::Anchor::EndText));"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };",
                  "    let result_start_line = translator_i.hir_assertion(&asst_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };",
                  "    let result_end_line = translator_i.hir_assertion(&asst_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };",
                  "    let result_start_text = translator_i.hir_assertion(&asst_start_text);",
                  "    let hir_start_text = result_start_text.unwrap();",
                  "    let asst_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText };",
                  "    let result_end_text = translator_i.hir_assertion(&asst_end_text);",
                  "    let hir_end_text = result_end_text.unwrap();",
                  "    let asst_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let result_word_boundary = translator_i.hir_assertion(&asst_word_boundary);",
                  "    assert!(result_word_boundary.is_ok());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };",
                  "    let result_start_line = translator_i.hir_assertion(&asst_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };",
                  "    let result_end_line = translator_i.hir_assertion(&asst_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };",
                  "    let result_start_text = translator_i.hir_assertion(&asst_start_text);",
                  "    let hir_start_text = result_start_text.unwrap();",
                  "    let asst_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText };",
                  "    let result_end_text = translator_i.hir_assertion(&asst_end_text);",
                  "    let hir_end_text = result_end_text.unwrap();",
                  "    let asst_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let result_word_boundary = translator_i.hir_assertion(&asst_word_boundary);",
                  "    let hir_word_boundary = result_word_boundary.unwrap();",
                  "    assert_eq!(hir_word_boundary.kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };",
                  "    let result_start_line = translator_i.hir_assertion(&asst_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };",
                  "    let result_end_line = translator_i.hir_assertion(&asst_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };",
                  "    let result_start_text = translator_i.hir_assertion(&asst_start_text);",
                  "    let hir_start_text = result_start_text.unwrap();",
                  "    let asst_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText };",
                  "    let result_end_text = translator_i.hir_assertion(&asst_end_text);",
                  "    let hir_end_text = result_end_text.unwrap();",
                  "    let asst_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let result_word_boundary = translator_i.hir_assertion(&asst_word_boundary);",
                  "    let hir_word_boundary = result_word_boundary.unwrap();",
                  "    let asst_not_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let result_not_word_boundary = translator_i.hir_assertion(&asst_not_word_boundary);",
                  "    assert!(result_not_word_boundary.is_ok());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };",
                  "    let result_start_line = translator_i.hir_assertion(&asst_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };",
                  "    let result_end_line = translator_i.hir_assertion(&asst_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };",
                  "    let result_start_text = translator_i.hir_assertion(&asst_start_text);",
                  "    let hir_start_text = result_start_text.unwrap();",
                  "    let asst_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText };",
                  "    let result_end_text = translator_i.hir_assertion(&asst_end_text);",
                  "    let hir_end_text = result_end_text.unwrap();",
                  "    let asst_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let result_word_boundary = translator_i.hir_assertion(&asst_word_boundary);",
                  "    let hir_word_boundary = result_word_boundary.unwrap();",
                  "    let asst_not_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let result_not_word_boundary = translator_i.hir_assertion(&asst_not_word_boundary);",
                  "    let hir_not_word_boundary = result_not_word_boundary.unwrap();",
                  "    assert_eq!(hir_not_word_boundary.kind(), &HirKind::WordBoundary(hir::WordBoundary::AsciiNegate));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };",
                  "    let result_start_line = translator_i.hir_assertion(&asst_start_line);",
                  "    assert!(result_start_line.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };",
                  "    let result_start_line = translator_i.hir_assertion(&asst_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    assert_eq!(hir_start_line.kind(), &HirKind::Anchor(hir::Anchor::StartText));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };",
                  "    let result_start_line = translator_i.hir_assertion(&asst_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };",
                  "    let result_end_line = translator_i.hir_assertion(&asst_end_line);",
                  "    assert!(result_end_line.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };",
                  "    let result_start_line = translator_i.hir_assertion(&asst_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };",
                  "    let result_end_line = translator_i.hir_assertion(&asst_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    assert_eq!(hir_end_line.kind(), &HirKind::Anchor(hir::Anchor::EndLine));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };",
                  "    let result_start_line = translator_i.hir_assertion(&asst_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };",
                  "    let result_end_line = translator_i.hir_assertion(&asst_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };",
                  "    let result_start_text = translator_i.hir_assertion(&asst_start_text);",
                  "    assert!(result_start_text.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };",
                  "    let result_start_line = translator_i.hir_assertion(&asst_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };",
                  "    let result_end_line = translator_i.hir_assertion(&asst_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };",
                  "    let result_start_text = translator_i.hir_assertion(&asst_start_text);",
                  "    let hir_start_text = result_start_text.unwrap();",
                  "    assert_eq!(hir_start_text.kind(), &HirKind::Anchor(hir::Anchor::StartText));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };",
                  "    let result_start_line = translator_i.hir_assertion(&asst_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };",
                  "    let result_end_line = translator_i.hir_assertion(&asst_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };",
                  "    let result_start_text = translator_i.hir_assertion(&asst_start_text);",
                  "    let hir_start_text = result_start_text.unwrap();",
                  "    let asst_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText };",
                  "    let result_end_text = translator_i.hir_assertion(&asst_end_text);",
                  "    assert!(result_end_text.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };",
                  "    let result_start_line = translator_i.hir_assertion(&asst_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };",
                  "    let result_end_line = translator_i.hir_assertion(&asst_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };",
                  "    let result_start_text = translator_i.hir_assertion(&asst_start_text);",
                  "    let hir_start_text = result_start_text.unwrap();",
                  "    let asst_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText };",
                  "    let result_end_text = translator_i.hir_assertion(&asst_end_text);",
                  "    let hir_end_text = result_end_text.unwrap();",
                  "    assert_eq!(hir_end_text.kind(), &HirKind::Anchor(hir::Anchor::EndText));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };",
                  "    let result_start_line = translator_i.hir_assertion(&asst_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };",
                  "    let result_end_line = translator_i.hir_assertion(&asst_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };",
                  "    let result_start_text = translator_i.hir_assertion(&asst_start_text);",
                  "    let hir_start_text = result_start_text.unwrap();",
                  "    let asst_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText };",
                  "    let result_end_text = translator_i.hir_assertion(&asst_end_text);",
                  "    let hir_end_text = result_end_text.unwrap();",
                  "    let asst_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let result_word_boundary = translator_i.hir_assertion(&asst_word_boundary);",
                  "    assert!(result_word_boundary.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };",
                  "    let result_start_line = translator_i.hir_assertion(&asst_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };",
                  "    let result_end_line = translator_i.hir_assertion(&asst_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };",
                  "    let result_start_text = translator_i.hir_assertion(&asst_start_text);",
                  "    let hir_start_text = result_start_text.unwrap();",
                  "    let asst_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText };",
                  "    let result_end_text = translator_i.hir_assertion(&asst_end_text);",
                  "    let hir_end_text = result_end_text.unwrap();",
                  "    let asst_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let result_word_boundary = translator_i.hir_assertion(&asst_word_boundary);",
                  "    let hir_word_boundary = result_word_boundary.unwrap();",
                  "    assert_eq!(hir_word_boundary.kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };",
                  "    let result_start_line = translator_i.hir_assertion(&asst_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };",
                  "    let result_end_line = translator_i.hir_assertion(&asst_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };",
                  "    let result_start_text = translator_i.hir_assertion(&asst_start_text);",
                  "    let hir_start_text = result_start_text.unwrap();",
                  "    let asst_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText };",
                  "    let result_end_text = translator_i.hir_assertion(&asst_end_text);",
                  "    let hir_end_text = result_end_text.unwrap();",
                  "    let asst_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let result_word_boundary = translator_i.hir_assertion(&asst_word_boundary);",
                  "    let hir_word_boundary = result_word_boundary.unwrap();",
                  "    let asst_not_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let result_not_word_boundary = translator_i.hir_assertion(&asst_not_word_boundary);",
                  "    assert!(result_not_word_boundary.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };",
                  "    let result_start_line = translator_i.hir_assertion(&asst_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };",
                  "    let result_end_line = translator_i.hir_assertion(&asst_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };",
                  "    let result_start_text = translator_i.hir_assertion(&asst_start_text);",
                  "    let hir_start_text = result_start_text.unwrap();",
                  "    let asst_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText };",
                  "    let result_end_text = translator_i.hir_assertion(&asst_end_text);",
                  "    let hir_end_text = result_end_text.unwrap();",
                  "    let asst_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };",
                  "    let result_word_boundary = translator_i.hir_assertion(&asst_word_boundary);",
                  "    let hir_word_boundary = result_word_boundary.unwrap();",
                  "    let asst_not_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let result_not_word_boundary = translator_i.hir_assertion(&asst_not_word_boundary);",
                  "    let hir_not_word_boundary = result_not_word_boundary.unwrap();",
                  "    assert_eq!(hir_not_word_boundary.kind(), &HirKind::WordBoundary(hir::WordBoundary::AsciiNegate));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:64\n     |\n2555 |     let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };\n     |                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:82\n     |\n2555 |     let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };\n     |                                                                                  ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2558:40\n     |\n2558 |     assert_eq!(hir_start_line.kind(), &HirKind::Anchor(hir::Anchor::StartText));\n     |                                        ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:64\n     |\n2555 |     let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };\n     |                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:82\n     |\n2555 |     let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };\n     |                                                                                  ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:64\n     |\n2555 |     let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };\n     |                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:82\n     |\n2555 |     let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };\n     |                                                                                  ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:62\n     |\n2558 |     let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };\n     |                                                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:80\n     |\n2558 |     let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };\n     |                                                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2561:38\n     |\n2561 |     assert_eq!(hir_end_line.kind(), &HirKind::Anchor(hir::Anchor::EndLine));\n     |                                      ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:64\n     |\n2555 |     let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };\n     |                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:82\n     |\n2555 |     let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };\n     |                                                                                  ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:62\n     |\n2558 |     let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };\n     |                                                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:80\n     |\n2558 |     let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };\n     |                                                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:64\n     |\n2555 |     let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };\n     |                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:82\n     |\n2555 |     let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };\n     |                                                                                  ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:62\n     |\n2558 |     let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };\n     |                                                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:80\n     |\n2558 |     let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };\n     |                                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:64\n     |\n2561 |     let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };\n     |                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:82\n     |\n2561 |     let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };\n     |                                                                                  ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2564:40\n     |\n2564 |     assert_eq!(hir_start_text.kind(), &HirKind::Anchor(hir::Anchor::StartText));\n     |                                        ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:64\n     |\n2555 |     let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };\n     |                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:82\n     |\n2555 |     let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };\n     |                                                                                  ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:62\n     |\n2558 |     let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };\n     |                                                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:80\n     |\n2558 |     let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };\n     |                                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:64\n     |\n2561 |     let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };\n     |                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:82\n     |\n2561 |     let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };\n     |                                                                                  ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:64\n     |\n2555 |     let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };\n     |                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:82\n     |\n2555 |     let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };\n     |                                                                                  ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:62\n     |\n2558 |     let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };\n     |                                                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:80\n     |\n2558 |     let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };\n     |                                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:64\n     |\n2561 |     let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };\n     |                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:82\n     |\n2561 |     let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };\n     |                                                                                  ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:62\n     |\n2564 |     let asst_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText };\n     |                                                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:80\n     |\n2564 |     let asst_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText };\n     |                                                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2567:38\n     |\n2567 |     assert_eq!(hir_end_text.kind(), &HirKind::Anchor(hir::Anchor::EndText));\n     |                                      ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:64\n     |\n2555 |     let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };\n     |                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:82\n     |\n2555 |     let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };\n     |                                                                                  ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:62\n     |\n2558 |     let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };\n     |                                                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:80\n     |\n2558 |     let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };\n     |                                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:64\n     |\n2561 |     let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };\n     |                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:82\n     |\n2561 |     let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };\n     |                                                                                  ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:62\n     |\n2564 |     let asst_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText };\n     |                                                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:80\n     |\n2564 |     let asst_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText };\n     |                                                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:64\n     |\n2555 |     let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };\n     |                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:82\n     |\n2555 |     let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };\n     |                                                                                  ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:62\n     |\n2558 |     let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };\n     |                                                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:80\n     |\n2558 |     let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };\n     |                                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:64\n     |\n2561 |     let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };\n     |                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:82\n     |\n2561 |     let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };\n     |                                                                                  ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:62\n     |\n2564 |     let asst_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText };\n     |                                                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:80\n     |\n2564 |     let asst_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText };\n     |                                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:67\n     |\n2567 |     let asst_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:85\n     |\n2567 |     let asst_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                                     ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2570:43\n     |\n2570 |     assert_eq!(hir_word_boundary.kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));\n     |                                           ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:64\n     |\n2555 |     let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };\n     |                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:82\n     |\n2555 |     let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };\n     |                                                                                  ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:62\n     |\n2558 |     let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };\n     |                                                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:80\n     |\n2558 |     let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };\n     |                                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:64\n     |\n2561 |     let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };\n     |                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:82\n     |\n2561 |     let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };\n     |                                                                                  ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:62\n     |\n2564 |     let asst_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText };\n     |                                                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:80\n     |\n2564 |     let asst_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText };\n     |                                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:67\n     |\n2567 |     let asst_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:85\n     |\n2567 |     let asst_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                                     ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:64\n     |\n2555 |     let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };\n     |                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:82\n     |\n2555 |     let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };\n     |                                                                                  ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:62\n     |\n2558 |     let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };\n     |                                                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:80\n     |\n2558 |     let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };\n     |                                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:64\n     |\n2561 |     let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };\n     |                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:82\n     |\n2561 |     let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };\n     |                                                                                  ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:62\n     |\n2564 |     let asst_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText };\n     |                                                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:80\n     |\n2564 |     let asst_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText };\n     |                                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:67\n     |\n2567 |     let asst_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:85\n     |\n2567 |     let asst_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:71\n     |\n2570 |     let asst_not_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::NotWordB...\n     |                                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:89\n     |\n2570 |     let asst_not_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::NotWordB...\n     |                                                                                         ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2573:47\n     |\n2573 |     assert_eq!(hir_not_word_boundary.kind(), &HirKind::WordBoundary(hir::WordBoundary::AsciiNegate));\n     |                                               ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:64\n     |\n2555 |     let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };\n     |                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:82\n     |\n2555 |     let asst_start_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartLine };\n     |                                                                                  ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:62\n     |\n2558 |     let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };\n     |                                                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:80\n     |\n2558 |     let asst_end_line = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndLine };\n     |                                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:64\n     |\n2561 |     let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };\n     |                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:82\n     |\n2561 |     let asst_start_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::StartText };\n     |                                                                                  ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:62\n     |\n2564 |     let asst_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText };\n     |                                                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2564:80\n     |\n2564 |     let asst_end_text = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText };\n     |                                                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:67\n     |\n2567 |     let asst_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2567:85\n     |\n2567 |     let asst_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:71\n     |\n2570 |     let asst_not_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::NotWordB...\n     |                                                                       ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2570:89\n     |\n2570 |     let asst_not_word_boundary = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::NotWordB...\n     |                                                                                         ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let pattern = \"\";",
                "    let translator_i = TranslatorI::new(&translator, pattern);",
                "    let asst = ast::Assertion {",
                "        span: Span { start: Position(0), end: Position(0) },",
                "        kind: ast::AssertionKind::EndLine,",
                "    };",
                "    translator_i.hir_assertion(&asst);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::Anchor(hir::Anchor::EndLine));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::Anchor(hir::Anchor::EndLine));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:25\n     |\n2560 |     span: Span { start: Position(0), end: Position(0) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:43\n     |\n2560 |     span: Span { start: Position(0), end: Position(0) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2565:36\n     |\n2565 |     assert_eq!(hir_result.kind(), &HirKind::Anchor(hir::Anchor::EndLine));\n     |                                    ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:25\n     |\n2560 |     span: Span { start: Position(0), end: Position(0) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:43\n     |\n2560 |     span: Span { start: Position(0), end: Position(0) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let pattern = \"\";",
                "    let translator_i = TranslatorI::new(&translator, pattern);",
                "    let asst = ast::Assertion {",
                "        span: Span { start: Position(0), end: Position(0) },",
                "        kind: ast::AssertionKind::StartText,",
                "    };",
                "    translator_i.hir_assertion(&asst);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.is_anchored_start(), true);"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.is_anchored_end(), false);"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::StartText));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.is_anchored_start(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.is_anchored_end(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags::default()),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "    span: Span { start: Position(0), end: Position(0) },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::StartText));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:25\n     |\n2560 |     span: Span { start: Position(0), end: Position(0) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:43\n     |\n2560 |     span: Span { start: Position(0), end: Position(0) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:25\n     |\n2560 |     span: Span { start: Position(0), end: Position(0) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:43\n     |\n2560 |     span: Span { start: Position(0), end: Position(0) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:25\n     |\n2560 |     span: Span { start: Position(0), end: Position(0) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:43\n     |\n2560 |     span: Span { start: Position(0), end: Position(0) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2565:29\n     |\n2565 |     assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::StartText));\n     |                             ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:25\n     |\n2560 |     span: Span { start: Position(0), end: Position(0) },\n     |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:43\n     |\n2560 |     span: Span { start: Position(0), end: Position(0) },\n     |                                           ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let pattern = \"\";",
                "    let translator_i = TranslatorI::new(&translator, pattern);",
                "    let asst = ast::Assertion {",
                "        span: Span { start: Position(0), end: Position(0) },",
                "        kind: ast::AssertionKind::EndText,",
                "    };",
                "    translator_i.hir_assertion(&asst);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::EndText));"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_always_utf8());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_all_assertions());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_anchored_start());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_anchored_end());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_any_anchored_start());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_any_anchored_end());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_match_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::EndText));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_always_utf8());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_all_assertions());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_anchored_start());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_anchored_end());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_any_anchored_start());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_any_anchored_end());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_match_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:53\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:71\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2558:29\n     |\n2558 |     assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::EndText));\n     |                             ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:53\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:71\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:53\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:71\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:53\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:71\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:53\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:71\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:53\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:71\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:53\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:71\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:53\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:71\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:53\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:71\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let pattern = \"\";",
                "    let translator_i = TranslatorI::new(&translator, pattern);",
                "    let asst = ast::Assertion {",
                "        span: Span { start: Position(0), end: Position(0) },",
                "        kind: ast::AssertionKind::WordBoundary,",
                "    };",
                "    translator_i.hir_assertion(&asst);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::EndText));"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_anchored_end());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::EndText));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_anchored_end());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:53\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:71\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2558:29\n     |\n2558 |     assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::EndText));\n     |                             ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:53\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:71\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:53\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:71\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags::default()),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let pattern = \"\";",
                "    let translator_i = TranslatorI::new(&translator, pattern);",
                "    let asst = ast::Assertion {",
                "        span: Span { start: Position(0), end: Position(0) },",
                "        kind: ast::AssertionKind::NotWordBoundary,",
                "    };",
                "    translator_i.hir_assertion(&asst);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::EndText));"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_anchored_end());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::EndText));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags::default()),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion {",
                  "        span: Span { start: Position(0), end: Position(0) },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    translator_i.hir_assertion(&asst);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags::default()), allow_invalid_utf8: true, };",
                  "    let pattern = \"\";",
                  "    let translator_i = TranslatorI::new(&translator, pattern);",
                  "    let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_anchored_end());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:53\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:71\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2558:29\n     |\n2558 |     assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::EndText));\n     |                             ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:53\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:71\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:29\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2548:47\n     |\n2548 |         span: Span { start: Position(0), end: Position(0) },\n     |                                               ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:53\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2555:71\n     |\n2555 |     let asst = ast::Assertion { span: Span { start: Position(0), end: Position(0) }, kind: ast::AssertionKind::EndText, };\n     |                                                                       ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 7,
      "prompt_conds": [
        "// constraint: asst.kind matches ast::AssertionKind::StartText is true\n",
        "// constraint: asst.kind matches ast::AssertionKind::StartText is true\n",
        "// expected return value/type: Ok(match asst.kind {\n            ast::AssertionKind::StartLine => {\n                Hir::anchor(if multi_line {\n                    hir::Anchor::StartLine\n                } else {\n                    hir::Anchor::StartText\n                })\n            }\n            ast::AssertionKind::EndLine => {\n                Hir::anchor(if multi_line {\n                    hir::Anchor::EndLine\n                } else {\n                    hir::Anchor::EndText\n                })\n            }\n            ast::AssertionKind::StartText => {\n                Hir::anchor(hir::Anchor::StartText)\n            }\n            ast::AssertionKind::EndText => {\n                Hir::anchor(hir::Anchor::EndText)\n            }\n            ast::AssertionKind::WordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::Unicode\n                } else {\n                    hir::WordBoundary::Ascii\n                })\n            }\n            ast::AssertionKind::NotWordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::UnicodeNegate\n                } else {\n                    // It is possible for negated ASCII word boundaries to\n                    // match at invalid UTF-8 boundaries, even when searching\n                    // valid UTF-8.\n                    if !self.trans().allow_invalid_utf8 {\n                        return Err(self.error(\n                            asst.span, ErrorKind::InvalidUtf8));\n                    }\n                    hir::WordBoundary::AsciiNegate\n                })\n            }\n        })\n"
      ],
      "input_infer": "asst.kind: [ast::AssertionKind::StartText, ast::AssertionKind::EndText, ast::AssertionKind::StartLine, ast::AssertionKind::EndLine, ast::AssertionKind::WordBoundary, ast::AssertionKind::NotWordBoundary]; flags: {case_insensitive: [None, Some(true), Some(false)], multi_line: [None, Some(true), Some(false)], dot_matches_new_line: [None, Some(true), Some(false)], swap_greed: [None, Some(true), Some(false)], unicode: [None, Some(true), Some(false)]}; self.trans().allow_invalid_utf8: [true, false]\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: None,",
                "            multi_line: None,",
                "            dot_matches_new_line: None,",
                "            swap_greed: None,",
                "            unicode: None,",
                "        }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: 0, end: 0 },",
                "        kind: ast::AssertionKind::StartText,",
                "    };",
                "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                "    let _ = translator_instance.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::StartText));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 0, end: 0 },",
                  "        kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let _ = translator_instance.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 0, end: 0 },",
                  "        kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let _ = translator_instance.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::StartText));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:29\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:37\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2569:25\n     |\n2569 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2569:33\n     |\n2569 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2575:29\n     |\n2575 |     assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::StartText));\n     |                             ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:29\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:37\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2569:25\n     |\n2569 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2569:33\n     |\n2569 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: None,",
                "            multi_line: None,",
                "            dot_matches_new_line: None,",
                "            swap_greed: None,",
                "            unicode: None,",
                "        }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: 0, end: 0 },",
                "        kind: ast::AssertionKind::EndText,",
                "    };",
                "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                "    let _ = translator_instance.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: None, multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: None, }), allow_invalid_utf8: true };",
                  "    let assertion = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: None, multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: None, }), allow_invalid_utf8: true };",
                  "    let assertion = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    if let Ok(hir) = result {",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::EndText));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 0, end: 0 },",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let _ = translator_instance.hir_assertion(&assertion);",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: None, multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: None, }), allow_invalid_utf8: true };",
                  "    let assertion = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 0, end: 0 },",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let _ = translator_instance.hir_assertion(&assertion);",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: None, multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: None, }), allow_invalid_utf8: true };",
                  "    let assertion = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    if let Ok(hir) = result {",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::EndText));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:29\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:37\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:58\n     |\n2558 |     let assertion = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:66\n     |\n2558 |     let assertion = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };\n     |                                                                  ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2564:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2564 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: None,",
                "            multi_line: Some(true),",
                "            dot_matches_new_line: None,",
                "            swap_greed: None,",
                "            unicode: None,",
                "        }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: 0, end: 0 },",
                "        kind: ast::AssertionKind::StartLine,",
                "    };",
                "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                "    let _ = translator_instance.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let multi_line = translator.flags.get().multi_line.unwrap_or(false);",
                  "    let assertion_kind = assertion.kind;",
                  "    let expected_anchor = if multi_line { hir::Anchor::StartLine } else { hir::Anchor::StartText };",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let multi_line = translator.flags.get().multi_line.unwrap_or(false);",
                  "    let assertion_kind = assertion.kind;",
                  "    let expected_anchor = if multi_line { hir::Anchor::StartLine } else { hir::Anchor::StartText };",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::Anchor(expected_anchor));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(true),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 0, end: 0 },",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let _ = translator_instance.hir_assertion(&assertion);",
                  "    let multi_line = translator.flags.get().multi_line.unwrap_or(false);",
                  "    let assertion_kind = assertion.kind;",
                  "    let expected_anchor = if multi_line { hir::Anchor::StartLine } else { hir::Anchor::StartText };",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(true),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 0, end: 0 },",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let _ = translator_instance.hir_assertion(&assertion);",
                  "    let multi_line = translator.flags.get().multi_line.unwrap_or(false);",
                  "    let assertion_kind = assertion.kind;",
                  "    let expected_anchor = if multi_line { hir::Anchor::StartLine } else { hir::Anchor::StartText };",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::Anchor(expected_anchor));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:29\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:37\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                                     ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2561:41\n     |\n2561 |     assert_eq!(result.unwrap().kind(), &HirKind::Anchor(expected_anchor));\n     |                                         ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:29\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:37\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                                     ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: None,",
                "            multi_line: Some(false),",
                "            dot_matches_new_line: None,",
                "            swap_greed: None,",
                "            unicode: None,",
                "        }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: 0, end: 0 },",
                "        kind: ast::AssertionKind::EndLine,",
                "    };",
                "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                "    let _ = translator_instance.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };",
                  "    let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line).unwrap();",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert_eq!(result_start_line.kind(), &HirKind::Anchor(hir::Anchor::EndLine));"
                ],
                [
                  "    let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };",
                  "    let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line).unwrap();",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert_eq!(result_end_line.kind(), &HirKind::Anchor(hir::Anchor::EndLine));"
                ],
                [
                  "    let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };",
                  "    let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line).unwrap();",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert_eq!(result_start_text.kind(), &HirKind::Anchor(hir::Anchor::StartText));"
                ],
                [
                  "    let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };",
                  "    let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line).unwrap();",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert_eq!(result_end_text.kind(), &HirKind::Anchor(hir::Anchor::EndText));"
                ],
                [
                  "    let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };",
                  "    let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line).unwrap();",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert_eq!(result_word_boundary.kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));"
                ],
                [
                  "    let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };",
                  "    let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line).unwrap();",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert!(result_not_word_boundary.is_err());"
                ],
                [
                  "    let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };",
                  "    let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line).unwrap();",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert_eq!(result_not_word_boundary.unwrap_err().kind, ErrorKind::InvalidUtf8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 0, end: 0 },",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let _ = translator_instance.hir_assertion(&assertion);",
                  "    let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };",
                  "    let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line).unwrap();",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert_eq!(result_start_line.kind(), &HirKind::Anchor(hir::Anchor::EndLine));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 0, end: 0 },",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let _ = translator_instance.hir_assertion(&assertion);",
                  "    let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };",
                  "    let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line).unwrap();",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert_eq!(result_end_line.kind(), &HirKind::Anchor(hir::Anchor::EndLine));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 0, end: 0 },",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let _ = translator_instance.hir_assertion(&assertion);",
                  "    let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };",
                  "    let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line).unwrap();",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert_eq!(result_start_text.kind(), &HirKind::Anchor(hir::Anchor::StartText));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 0, end: 0 },",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let _ = translator_instance.hir_assertion(&assertion);",
                  "    let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };",
                  "    let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line).unwrap();",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert_eq!(result_end_text.kind(), &HirKind::Anchor(hir::Anchor::EndText));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 0, end: 0 },",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let _ = translator_instance.hir_assertion(&assertion);",
                  "    let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };",
                  "    let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line).unwrap();",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert_eq!(result_word_boundary.kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 0, end: 0 },",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let _ = translator_instance.hir_assertion(&assertion);",
                  "    let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };",
                  "    let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line).unwrap();",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert!(result_not_word_boundary.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 0, end: 0 },",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let _ = translator_instance.hir_assertion(&assertion);",
                  "    let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };",
                  "    let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line).unwrap();",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert_eq!(result_not_word_boundary.unwrap_err().kind, ErrorKind::InvalidUtf8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2569:43\n     |\n2569 |     assert_eq!(result_start_line.kind(), &HirKind::Anchor(hir::Anchor::EndLine));\n     |                                           ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:29\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:37\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:69\n     |\n2557 |     let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:77\n     |\n2557 |     let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };\n     |                                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:67\n     |\n2558 |     let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };\n     |                                                                   ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:75\n     |\n2558 |     let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };\n     |                                                                           ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:69\n     |\n2559 |     let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:77\n     |\n2559 |     let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };\n     |                                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:67\n     |\n2560 |     let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };\n     |                                                                   ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:75\n     |\n2560 |     let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };\n     |                                                                           ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:72\n     |\n2561 |     let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:80\n     |\n2561 |     let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:76\n     |\n2562 |     let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };\n     |                                                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:84\n     |\n2562 |     let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };\n     |                                                                                    ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2569:41\n     |\n2569 |     assert_eq!(result_end_line.kind(), &HirKind::Anchor(hir::Anchor::EndLine));\n     |                                         ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:29\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:37\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:69\n     |\n2557 |     let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:77\n     |\n2557 |     let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };\n     |                                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:67\n     |\n2558 |     let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };\n     |                                                                   ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:75\n     |\n2558 |     let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };\n     |                                                                           ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:69\n     |\n2559 |     let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:77\n     |\n2559 |     let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };\n     |                                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:67\n     |\n2560 |     let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };\n     |                                                                   ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:75\n     |\n2560 |     let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };\n     |                                                                           ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:72\n     |\n2561 |     let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:80\n     |\n2561 |     let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:76\n     |\n2562 |     let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };\n     |                                                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:84\n     |\n2562 |     let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };\n     |                                                                                    ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2569:43\n     |\n2569 |     assert_eq!(result_start_text.kind(), &HirKind::Anchor(hir::Anchor::StartText));\n     |                                           ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:29\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:37\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:69\n     |\n2557 |     let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:77\n     |\n2557 |     let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };\n     |                                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:67\n     |\n2558 |     let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };\n     |                                                                   ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:75\n     |\n2558 |     let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };\n     |                                                                           ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:69\n     |\n2559 |     let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:77\n     |\n2559 |     let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };\n     |                                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:67\n     |\n2560 |     let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };\n     |                                                                   ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:75\n     |\n2560 |     let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };\n     |                                                                           ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:72\n     |\n2561 |     let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:80\n     |\n2561 |     let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:76\n     |\n2562 |     let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };\n     |                                                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:84\n     |\n2562 |     let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };\n     |                                                                                    ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2569:41\n     |\n2569 |     assert_eq!(result_end_text.kind(), &HirKind::Anchor(hir::Anchor::EndText));\n     |                                         ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:29\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:37\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:69\n     |\n2557 |     let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:77\n     |\n2557 |     let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };\n     |                                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:67\n     |\n2558 |     let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };\n     |                                                                   ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:75\n     |\n2558 |     let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };\n     |                                                                           ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:69\n     |\n2559 |     let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:77\n     |\n2559 |     let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };\n     |                                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:67\n     |\n2560 |     let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };\n     |                                                                   ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:75\n     |\n2560 |     let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };\n     |                                                                           ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:72\n     |\n2561 |     let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:80\n     |\n2561 |     let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:76\n     |\n2562 |     let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };\n     |                                                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:84\n     |\n2562 |     let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };\n     |                                                                                    ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2569:46\n     |\n2569 |     assert_eq!(result_word_boundary.kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));\n     |                                              ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:29\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:37\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:69\n     |\n2557 |     let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:77\n     |\n2557 |     let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };\n     |                                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:67\n     |\n2558 |     let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };\n     |                                                                   ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:75\n     |\n2558 |     let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };\n     |                                                                           ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:69\n     |\n2559 |     let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:77\n     |\n2559 |     let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };\n     |                                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:67\n     |\n2560 |     let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };\n     |                                                                   ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:75\n     |\n2560 |     let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };\n     |                                                                           ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:72\n     |\n2561 |     let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:80\n     |\n2561 |     let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:76\n     |\n2562 |     let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };\n     |                                                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:84\n     |\n2562 |     let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };\n     |                                                                                    ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:29\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:37\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:69\n     |\n2557 |     let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:77\n     |\n2557 |     let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };\n     |                                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:67\n     |\n2558 |     let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };\n     |                                                                   ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:75\n     |\n2558 |     let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };\n     |                                                                           ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:69\n     |\n2559 |     let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:77\n     |\n2559 |     let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };\n     |                                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:67\n     |\n2560 |     let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };\n     |                                                                   ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:75\n     |\n2560 |     let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };\n     |                                                                           ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:72\n     |\n2561 |     let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:80\n     |\n2561 |     let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:76\n     |\n2562 |     let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };\n     |                                                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:84\n     |\n2562 |     let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };\n     |                                                                                    ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:29\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:37\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:69\n     |\n2557 |     let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2557:77\n     |\n2557 |     let assertion_start_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartLine };\n     |                                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:67\n     |\n2558 |     let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };\n     |                                                                   ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:75\n     |\n2558 |     let assertion_end_line = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndLine };\n     |                                                                           ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:69\n     |\n2559 |     let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };\n     |                                                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2559:77\n     |\n2559 |     let assertion_start_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::StartText };\n     |                                                                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:67\n     |\n2560 |     let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };\n     |                                                                   ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:75\n     |\n2560 |     let assertion_end_text = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::EndText };\n     |                                                                           ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:72\n     |\n2561 |     let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                        ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2561:80\n     |\n2561 |     let assertion_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                                ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:76\n     |\n2562 |     let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };\n     |                                                                            ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2562:84\n     |\n2562 |     let assertion_not_word_boundary = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary };\n     |                                                                                    ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: None,",
                "            multi_line: None,",
                "            dot_matches_new_line: None,",
                "            swap_greed: None,",
                "            unicode: Some(true),",
                "        }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: 0, end: 0 },",
                "        kind: ast::AssertionKind::WordBoundary,",
                "    };",
                "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                "    let _ = translator_instance.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let assertion_word_boundary = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let assertion_not_word_boundary = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line);",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line);",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text);",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text);",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary);",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert!(result_start_line.is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let assertion_word_boundary = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let assertion_not_word_boundary = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line);",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line);",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text);",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text);",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary);",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert!(result_end_line.is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let assertion_word_boundary = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let assertion_not_word_boundary = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line);",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line);",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text);",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text);",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary);",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert!(result_start_text.is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let assertion_word_boundary = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let assertion_not_word_boundary = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line);",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line);",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text);",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text);",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary);",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert!(result_end_text.is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let assertion_word_boundary = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let assertion_not_word_boundary = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line);",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line);",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text);",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text);",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary);",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert!(result_word_boundary.is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let assertion_word_boundary = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let assertion_not_word_boundary = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line);",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line);",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text);",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text);",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary);",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert!(result_not_word_boundary.is_ok());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 0, end: 0 },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let _ = translator_instance.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let assertion_word_boundary = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let assertion_not_word_boundary = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line);",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line);",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text);",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text);",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary);",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert!(result_start_line.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 0, end: 0 },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let _ = translator_instance.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let assertion_word_boundary = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let assertion_not_word_boundary = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line);",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line);",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text);",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text);",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary);",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert!(result_end_line.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 0, end: 0 },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let _ = translator_instance.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let assertion_word_boundary = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let assertion_not_word_boundary = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line);",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line);",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text);",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text);",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary);",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert!(result_start_text.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 0, end: 0 },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let _ = translator_instance.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let assertion_word_boundary = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let assertion_not_word_boundary = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line);",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line);",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text);",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text);",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary);",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert!(result_end_text.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 0, end: 0 },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let _ = translator_instance.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let assertion_word_boundary = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let assertion_not_word_boundary = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line);",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line);",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text);",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text);",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary);",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert!(result_word_boundary.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 0, end: 0 },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let _ = translator_instance.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: None,",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(true),",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let assertion_word_boundary = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let assertion_not_word_boundary = ast::Assertion {",
                  "    span: Span { start: 0, end: 0 },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let result_start_line = translator_instance.hir_assertion(&assertion_start_line);",
                  "    let result_end_line = translator_instance.hir_assertion(&assertion_end_line);",
                  "    let result_start_text = translator_instance.hir_assertion(&assertion_start_text);",
                  "    let result_end_text = translator_instance.hir_assertion(&assertion_end_text);",
                  "    let result_word_boundary = translator_instance.hir_assertion(&assertion_word_boundary);",
                  "    let result_not_word_boundary = translator_instance.hir_assertion(&assertion_not_word_boundary);",
                  "    assert!(result_not_word_boundary.is_ok());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:29\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:37\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2569:25\n     |\n2569 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2569:33\n     |\n2569 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:25\n     |\n2573 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:33\n     |\n2573 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2577:25\n     |\n2577 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2577:33\n     |\n2577 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:25\n     |\n2581 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:33\n     |\n2581 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2585:25\n     |\n2585 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2585:33\n     |\n2585 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2589:25\n     |\n2589 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2589:33\n     |\n2589 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:29\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:37\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2569:25\n     |\n2569 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2569:33\n     |\n2569 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:25\n     |\n2573 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:33\n     |\n2573 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2577:25\n     |\n2577 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2577:33\n     |\n2577 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:25\n     |\n2581 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:33\n     |\n2581 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2585:25\n     |\n2585 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2585:33\n     |\n2585 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2589:25\n     |\n2589 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2589:33\n     |\n2589 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:29\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:37\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2569:25\n     |\n2569 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2569:33\n     |\n2569 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:25\n     |\n2573 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:33\n     |\n2573 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2577:25\n     |\n2577 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2577:33\n     |\n2577 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:25\n     |\n2581 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:33\n     |\n2581 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2585:25\n     |\n2585 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2585:33\n     |\n2585 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2589:25\n     |\n2589 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2589:33\n     |\n2589 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:29\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:37\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2569:25\n     |\n2569 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2569:33\n     |\n2569 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:25\n     |\n2573 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:33\n     |\n2573 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2577:25\n     |\n2577 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2577:33\n     |\n2577 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:25\n     |\n2581 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:33\n     |\n2581 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2585:25\n     |\n2585 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2585:33\n     |\n2585 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2589:25\n     |\n2589 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2589:33\n     |\n2589 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:29\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:37\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2569:25\n     |\n2569 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2569:33\n     |\n2569 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:25\n     |\n2573 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:33\n     |\n2573 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2577:25\n     |\n2577 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2577:33\n     |\n2577 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:25\n     |\n2581 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:33\n     |\n2581 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2585:25\n     |\n2585 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2585:33\n     |\n2585 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2589:25\n     |\n2589 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2589:33\n     |\n2589 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:29\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:37\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2569:25\n     |\n2569 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2569:33\n     |\n2569 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:25\n     |\n2573 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2573:33\n     |\n2573 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2577:25\n     |\n2577 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2577:33\n     |\n2577 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:25\n     |\n2581 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:33\n     |\n2581 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2585:25\n     |\n2585 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2585:33\n     |\n2585 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2589:25\n     |\n2589 |     span: Span { start: 0, end: 0 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2589:33\n     |\n2589 |     span: Span { start: 0, end: 0 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: None,",
                "            multi_line: None,",
                "            dot_matches_new_line: None,",
                "            swap_greed: None,",
                "            unicode: Some(false),",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: 0, end: 0 },",
                "        kind: ast::AssertionKind::NotWordBoundary,",
                "    };",
                "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                "    let _ = translator_instance.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: None, multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(false), }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary, };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert!(result.is_err());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: None, multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(false), }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary, };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap_err().kind, ErrorKind::InvalidUtf8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 0, end: 0 },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let _ = translator_instance.hir_assertion(&assertion);",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: None, multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(false), }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary, };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert!(result.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: None,",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 0, end: 0 },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let _ = translator_instance.hir_assertion(&assertion);",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { case_insensitive: None, multi_line: None, dot_matches_new_line: None, swap_greed: None, unicode: Some(false), }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary, };",
                  "    let translator_instance = TranslatorI::new(&translator, \"test\");",
                  "    let result = translator_instance.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap_err().kind, ErrorKind::InvalidUtf8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:29\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:37\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:58\n     |\n2558 |     let assertion = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary, };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:66\n     |\n2558 |     let assertion = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary, };\n     |                                                                  ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:29\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:37\n     |\n2552 |         span: Span { start: 0, end: 0 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:58\n     |\n2558 |     let assertion = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary, };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2558:66\n     |\n2558 |     let assertion = ast::Assertion { span: Span { start: 0, end: 0 }, kind: ast::AssertionKind::NotWordBoundary, };\n     |                                                                  ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 8,
      "prompt_conds": [
        "// constraint: asst.kind matches ast::AssertionKind::EndLine is true\n",
        "// constraint: asst.kind matches ast::AssertionKind::EndLine is true\n",
        "// constraint: multi_line is true\n",
        "// expected return value/type: Ok(match asst.kind {\n            ast::AssertionKind::StartLine => {\n                Hir::anchor(if multi_line {\n                    hir::Anchor::StartLine\n                } else {\n                    hir::Anchor::StartText\n                })\n            }\n            ast::AssertionKind::EndLine => {\n                Hir::anchor(if multi_line {\n                    hir::Anchor::EndLine\n                } else {\n                    hir::Anchor::EndText\n                })\n            }\n            ast::AssertionKind::StartText => {\n                Hir::anchor(hir::Anchor::StartText)\n            }\n            ast::AssertionKind::EndText => {\n                Hir::anchor(hir::Anchor::EndText)\n            }\n            ast::AssertionKind::WordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::Unicode\n                } else {\n                    hir::WordBoundary::Ascii\n                })\n            }\n            ast::AssertionKind::NotWordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::UnicodeNegate\n                } else {\n                    // It is possible for negated ASCII word boundaries to\n                    // match at invalid UTF-8 boundaries, even when searching\n                    // valid UTF-8.\n                    if !self.trans().allow_invalid_utf8 {\n                        return Err(self.error(\n                            asst.span, ErrorKind::InvalidUtf8));\n                    }\n                    hir::WordBoundary::AsciiNegate\n                })\n            }\n        })\n"
      ],
      "input_infer": "asst.kind = ast::AssertionKind::EndLine; multi_line = true; unicode = Some(true) or None; allow_invalid_utf8 = true; span.start >= 0 and span.end >= span.start\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let assertion = ast::Assertion {",
                "        span,",
                "        kind: ast::AssertionKind::EndLine,",
                "    };",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                "    translator_i.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::Anchor(hir::Anchor::EndLine));"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(hir_result.is_always_utf8());"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(hir_result.is_all_assertions());"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(!hir_result.is_anchored_start());"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(hir_result.is_anchored_end());"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(!hir_result.is_any_anchored_start());"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(hir_result.is_any_anchored_end());"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(hir_result.is_match_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    translator_i.hir_assertion(&assertion);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    translator_i.hir_assertion(&assertion);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::Anchor(hir::Anchor::EndLine));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    translator_i.hir_assertion(&assertion);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(hir_result.is_always_utf8());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    translator_i.hir_assertion(&assertion);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(hir_result.is_all_assertions());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    translator_i.hir_assertion(&assertion);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(!hir_result.is_anchored_start());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    translator_i.hir_assertion(&assertion);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(hir_result.is_anchored_end());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    translator_i.hir_assertion(&assertion);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(!hir_result.is_any_anchored_start());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    translator_i.hir_assertion(&assertion);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(hir_result.is_any_anchored_end());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    translator_i.hir_assertion(&assertion);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(hir_result.is_match_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2558:36\n     |\n2558 |     assert_eq!(hir_result.kind(), &HirKind::Anchor(hir::Anchor::EndLine));\n     |                                    ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let assertion = ast::Assertion {",
                "        span,",
                "        kind: ast::AssertionKind::EndLine,",
                "    };",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(true), ..Default::default() }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                "    translator_i.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(true), ..Default::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(true), ..Default::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    match result {",
                  "    Ok(hir_result) => {",
                  "    assert_eq!(hir_result.kind(), &HirKind::Anchor(hir::Anchor::EndLine));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(true), ..Default::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    translator_i.hir_assertion(&assertion);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(true), ..Default::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(true), ..Default::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    translator_i.hir_assertion(&assertion);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(true), ..Default::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    match result {",
                  "    Ok(hir_result) => {",
                  "    assert_eq!(hir_result.kind(), &HirKind::Anchor(hir::Anchor::EndLine));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror: this file contains an unclosed delimiter\n    --> regex-syntax/src/hir/translate.rs:2568:3\n     |\n2534 | mod llmtests {\n     |              - unclosed delimiter\n...\n2539 | {\n     | - unclosed delimiter\n...\n2565 |     Ok(hir_result) => {\n     |                       - this delimiter might not be properly closed...\n2566 |     assert_eq!(hir_result.kind(), &HirKind::Anchor(hir::Anchor::EndLine));\n2567 | }\n     | - ...as it matches this but it has different indentation\n2568 | }\n     |   ^\n\nerror: could not compile `regex-syntax` (lib test) due to 1 previous error\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: 0, end: 1 };",
                "    let assertion = ast::Assertion {",
                "        span,",
                "        kind: ast::AssertionKind::EndLine,",
                "    };",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Default::default() }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                "    translator_i.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Default::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Default::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::EndLine));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    translator_i.hir_assertion(&assertion);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Default::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Default::default() }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    translator_i.hir_assertion(&assertion);",
                  "    let span = Span { start: 0, end: 1 };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags { multi_line: Some(true), unicode: Some(false), ..Default::default() }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::EndLine));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2565:29\n     |\n2565 |     assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::EndLine));\n     |                             ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2540:38\n     |\n2540 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                              ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2552:38\n     |\n2552 |     let span = Span { start: 0, end: 1 };\n     |                                      ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 9,
      "prompt_conds": [
        "// constraint: asst.kind matches ast::AssertionKind::EndLine is true\n",
        "// constraint: asst.kind matches ast::AssertionKind::EndLine is true\n",
        "// constraint: multi_line is false\n",
        "// expected return value/type: Ok(match asst.kind {\n            ast::AssertionKind::StartLine => {\n                Hir::anchor(if multi_line {\n                    hir::Anchor::StartLine\n                } else {\n                    hir::Anchor::StartText\n                })\n            }\n            ast::AssertionKind::EndLine => {\n                Hir::anchor(if multi_line {\n                    hir::Anchor::EndLine\n                } else {\n                    hir::Anchor::EndText\n                })\n            }\n            ast::AssertionKind::StartText => {\n                Hir::anchor(hir::Anchor::StartText)\n            }\n            ast::AssertionKind::EndText => {\n                Hir::anchor(hir::Anchor::EndText)\n            }\n            ast::AssertionKind::WordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::Unicode\n                } else {\n                    hir::WordBoundary::Ascii\n                })\n            }\n            ast::AssertionKind::NotWordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::UnicodeNegate\n                } else {\n                    // It is possible for negated ASCII word boundaries to\n                    // match at invalid UTF-8 boundaries, even when searching\n                    // valid UTF-8.\n                    if !self.trans().allow_invalid_utf8 {\n                        return Err(self.error(\n                            asst.span, ErrorKind::InvalidUtf8));\n                    }\n                    hir::WordBoundary::AsciiNegate\n                })\n            }\n        })\n"
      ],
      "input_infer": "asst.kind = ast::AssertionKind::EndLine, multi_line = false, expected return value = Ok(Hir::anchor(hir::Anchor::EndText))\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: None,",
                "            multi_line: Some(false),",
                "            dot_matches_new_line: None,",
                "            swap_greed: None,",
                "            unicode: None,",
                "        }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "",
                "    let span = Span { start: Position(0), end: Position(0) };",
                "    let assertion = ast::Assertion {",
                "        span,",
                "        kind: ast::AssertionKind::EndLine,",
                "    };",
                "",
                "    let translator_i = TranslatorI::new(&translator, \"\");",
                "    let _result = translator_i.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::Anchor(hir::Anchor::EndLine));"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(!hir_result.is_any_anchored_start());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(!hir_result.is_any_anchored_end());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(hir_result.is_anchored_end());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(!hir_result.is_anchored_start());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::Anchor(hir::Anchor::EndLine));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(!hir_result.is_any_anchored_start());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(!hir_result.is_any_anchored_end());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(hir_result.is_anchored_end());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(!hir_result.is_anchored_start());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:30\n     |\n2571 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:48\n     |\n2571 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2579:36\n     |\n2579 |     assert_eq!(hir_result.kind(), &HirKind::Anchor(hir::Anchor::EndLine));\n     |                                    ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:30\n     |\n2571 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:48\n     |\n2571 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:30\n     |\n2571 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:48\n     |\n2571 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:30\n     |\n2571 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:48\n     |\n2571 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:30\n     |\n2571 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:48\n     |\n2571 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:30\n     |\n2571 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:48\n     |\n2571 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: None,",
                "            multi_line: Some(false),",
                "            dot_matches_new_line: None,",
                "            swap_greed: None,",
                "            unicode: None,",
                "        }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "",
                "    let span = Span { start: Position(0), end: Position(0) };",
                "    let assertion = ast::Assertion {",
                "        span,",
                "        kind: ast::AssertionKind::StartText,",
                "    };",
                "",
                "    let translator_i = TranslatorI::new(&translator, \"\");",
                "    let _result = translator_i.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: None, }), allow_invalid_utf8: true, };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion_end_line = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary_unicode = ast::Assertion { span, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let assertion_not_word_boundary_ascii = ast::Assertion { span, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_i.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary_unicode = translator_i.hir_assertion(&assertion_not_word_boundary_unicode).unwrap();",
                  "    let result_not_word_boundary_ascii = translator_i.hir_assertion(&assertion_not_word_boundary_ascii);",
                  "    assert_eq!(result_end_line.is_anchored_end(), true);"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: None, }), allow_invalid_utf8: true, };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion_end_line = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary_unicode = ast::Assertion { span, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let assertion_not_word_boundary_ascii = ast::Assertion { span, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_i.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary_unicode = translator_i.hir_assertion(&assertion_not_word_boundary_unicode).unwrap();",
                  "    let result_not_word_boundary_ascii = translator_i.hir_assertion(&assertion_not_word_boundary_ascii);",
                  "    assert_eq!(result_start_text.is_anchored_start(), true);"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: None, }), allow_invalid_utf8: true, };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion_end_line = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary_unicode = ast::Assertion { span, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let assertion_not_word_boundary_ascii = ast::Assertion { span, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_i.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary_unicode = translator_i.hir_assertion(&assertion_not_word_boundary_unicode).unwrap();",
                  "    let result_not_word_boundary_ascii = translator_i.hir_assertion(&assertion_not_word_boundary_ascii);",
                  "    assert_eq!(result_end_text.is_anchored_end(), true);"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: None, }), allow_invalid_utf8: true, };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion_end_line = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary_unicode = ast::Assertion { span, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let assertion_not_word_boundary_ascii = ast::Assertion { span, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_i.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary_unicode = translator_i.hir_assertion(&assertion_not_word_boundary_unicode).unwrap();",
                  "    let result_not_word_boundary_ascii = translator_i.hir_assertion(&assertion_not_word_boundary_ascii);",
                  "    assert_eq!(result_word_boundary.is_match_empty(), false);"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: None, }), allow_invalid_utf8: true, };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion_end_line = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary_unicode = ast::Assertion { span, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let assertion_not_word_boundary_ascii = ast::Assertion { span, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_i.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary_unicode = translator_i.hir_assertion(&assertion_not_word_boundary_unicode).unwrap();",
                  "    let result_not_word_boundary_ascii = translator_i.hir_assertion(&assertion_not_word_boundary_ascii);",
                  "    assert_eq!(result_not_word_boundary_unicode.is_match_empty(), false);"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: None, }), allow_invalid_utf8: true, };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion_end_line = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary_unicode = ast::Assertion { span, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let assertion_not_word_boundary_ascii = ast::Assertion { span, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_i.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary_unicode = translator_i.hir_assertion(&assertion_not_word_boundary_unicode).unwrap();",
                  "    let result_not_word_boundary_ascii = translator_i.hir_assertion(&assertion_not_word_boundary_ascii);",
                  "    assert!(result_not_word_boundary_ascii.is_err());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::StartText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: None, }), allow_invalid_utf8: true, };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion_end_line = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary_unicode = ast::Assertion { span, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let assertion_not_word_boundary_ascii = ast::Assertion { span, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_i.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary_unicode = translator_i.hir_assertion(&assertion_not_word_boundary_unicode).unwrap();",
                  "    let result_not_word_boundary_ascii = translator_i.hir_assertion(&assertion_not_word_boundary_ascii);",
                  "    assert_eq!(result_end_line.is_anchored_end(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::StartText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: None, }), allow_invalid_utf8: true, };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion_end_line = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary_unicode = ast::Assertion { span, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let assertion_not_word_boundary_ascii = ast::Assertion { span, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_i.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary_unicode = translator_i.hir_assertion(&assertion_not_word_boundary_unicode).unwrap();",
                  "    let result_not_word_boundary_ascii = translator_i.hir_assertion(&assertion_not_word_boundary_ascii);",
                  "    assert_eq!(result_start_text.is_anchored_start(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::StartText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: None, }), allow_invalid_utf8: true, };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion_end_line = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary_unicode = ast::Assertion { span, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let assertion_not_word_boundary_ascii = ast::Assertion { span, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_i.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary_unicode = translator_i.hir_assertion(&assertion_not_word_boundary_unicode).unwrap();",
                  "    let result_not_word_boundary_ascii = translator_i.hir_assertion(&assertion_not_word_boundary_ascii);",
                  "    assert_eq!(result_end_text.is_anchored_end(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::StartText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: None, }), allow_invalid_utf8: true, };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion_end_line = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary_unicode = ast::Assertion { span, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let assertion_not_word_boundary_ascii = ast::Assertion { span, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_i.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary_unicode = translator_i.hir_assertion(&assertion_not_word_boundary_unicode).unwrap();",
                  "    let result_not_word_boundary_ascii = translator_i.hir_assertion(&assertion_not_word_boundary_ascii);",
                  "    assert_eq!(result_word_boundary.is_match_empty(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::StartText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: None, }), allow_invalid_utf8: true, };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion_end_line = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary_unicode = ast::Assertion { span, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let assertion_not_word_boundary_ascii = ast::Assertion { span, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_i.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary_unicode = translator_i.hir_assertion(&assertion_not_word_boundary_unicode).unwrap();",
                  "    let result_not_word_boundary_ascii = translator_i.hir_assertion(&assertion_not_word_boundary_ascii);",
                  "    assert_eq!(result_not_word_boundary_unicode.is_match_empty(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::StartText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: None, }), allow_invalid_utf8: true, };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion_end_line = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let assertion_start_text = ast::Assertion { span, kind: ast::AssertionKind::StartText };",
                  "    let assertion_end_text = ast::Assertion { span, kind: ast::AssertionKind::EndText };",
                  "    let assertion_word_boundary = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let assertion_not_word_boundary_unicode = ast::Assertion { span, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let assertion_not_word_boundary_ascii = ast::Assertion { span, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line).unwrap();",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text).unwrap();",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text).unwrap();",
                  "    let result_word_boundary = translator_i.hir_assertion(&assertion_word_boundary).unwrap();",
                  "    let result_not_word_boundary_unicode = translator_i.hir_assertion(&assertion_not_word_boundary_unicode).unwrap();",
                  "    let result_not_word_boundary_ascii = translator_i.hir_assertion(&assertion_not_word_boundary_ascii);",
                  "    assert!(result_not_word_boundary_ascii.is_err());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:30\n     |\n2561 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:48\n     |\n2561 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:30\n     |\n2561 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:48\n     |\n2561 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:30\n     |\n2561 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:48\n     |\n2561 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:30\n     |\n2561 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:48\n     |\n2561 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:30\n     |\n2561 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:48\n     |\n2561 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:30\n     |\n2561 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2561:48\n     |\n2561 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: None,",
                "            multi_line: Some(false),",
                "            dot_matches_new_line: None,",
                "            swap_greed: None,",
                "            unicode: None,",
                "        }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "",
                "    let span = Span { start: Position(0), end: Position(0) };",
                "    let assertion = ast::Assertion {",
                "        span,",
                "        kind: ast::AssertionKind::StartLine,",
                "    };",
                "",
                "    let translator_i = TranslatorI::new(&translator, \"\");",
                "    let _result = translator_i.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::Anchor(hir::Anchor::EndLine));"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(translator_i.flags().multi_line().is_false());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(translator_i.trans().allow_invalid_utf8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::Anchor(hir::Anchor::EndLine));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(translator_i.flags().multi_line().is_false());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert!(translator_i.trans().allow_invalid_utf8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:30\n     |\n2571 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:48\n     |\n2571 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2579:36\n     |\n2579 |     assert_eq!(hir_result.kind(), &HirKind::Anchor(hir::Anchor::EndLine));\n     |                                    ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:30\n     |\n2571 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:48\n     |\n2571 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:30\n     |\n2571 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:48\n     |\n2571 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `is_false` found for type `bool` in the current scope\n    --> regex-syntax/src/hir/translate.rs:2579:47\n     |\n2579 |     assert!(translator_i.flags().multi_line().is_false());\n     |                                               ^^^^^^^^ method not found in `bool`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0599.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:30\n     |\n2571 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2571:48\n     |\n2571 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: None,",
                "            multi_line: Some(false),",
                "            dot_matches_new_line: None,",
                "            swap_greed: None,",
                "            unicode: None,",
                "        }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "",
                "    let span = Span { start: Position(0), end: Position(0) };",
                "    let assertion = ast::Assertion {",
                "        span,",
                "        kind: ast::AssertionKind::EndText,",
                "    };",
                "",
                "    let translator_i = TranslatorI::new(&translator, \"\");",
                "    let _result = translator_i.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::Anchor(hir::Anchor::EndLine));"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::Anchor(hir::Anchor::EndText));"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::Anchor(hir::Anchor::StartText));"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::AsciiNegate));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::Anchor(hir::Anchor::EndLine));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::Anchor(hir::Anchor::EndText));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::Anchor(hir::Anchor::StartText));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let _result = translator_i.hir_assertion(&assertion);",
                  "    let span = Span { start: Position(0), end: Position(0) };",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let assertion = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert_eq!(result.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::AsciiNegate));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:30\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:48\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2567:41\n     |\n2567 |     assert_eq!(result.unwrap().kind(), &HirKind::Anchor(hir::Anchor::EndLine));\n     |                                         ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:30\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:48\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:30\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:48\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2572:41\n     |\n2572 |     assert_eq!(result.unwrap().kind(), &HirKind::Anchor(hir::Anchor::EndText));\n     |                                         ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:30\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:48\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:30\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:48\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2577:41\n     |\n2577 |     assert_eq!(result.unwrap().kind(), &HirKind::Anchor(hir::Anchor::StartText));\n     |                                         ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:30\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:48\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:30\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:48\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2582:41\n     |\n2582 |     assert_eq!(result.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));\n     |                                         ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:30\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:48\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:30\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:48\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2587:41\n     |\n2587 |     assert_eq!(result.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::AsciiNegate));\n     |                                         ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:30\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2552:48\n     |\n2552 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:30\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2560:48\n     |\n2560 |     let span = Span { start: Position(0), end: Position(0) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 10,
      "prompt_conds": [
        "// constraint: asst.kind matches ast::AssertionKind::StartLine is true\n",
        "// constraint: asst.kind matches ast::AssertionKind::StartLine is true\n",
        "// constraint: multi_line is true\n",
        "// expected return value/type: Ok(match asst.kind {\n            ast::AssertionKind::StartLine => {\n                Hir::anchor(if multi_line {\n                    hir::Anchor::StartLine\n                } else {\n                    hir::Anchor::StartText\n                })\n            }\n            ast::AssertionKind::EndLine => {\n                Hir::anchor(if multi_line {\n                    hir::Anchor::EndLine\n                } else {\n                    hir::Anchor::EndText\n                })\n            }\n            ast::AssertionKind::StartText => {\n                Hir::anchor(hir::Anchor::StartText)\n            }\n            ast::AssertionKind::EndText => {\n                Hir::anchor(hir::Anchor::EndText)\n            }\n            ast::AssertionKind::WordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::Unicode\n                } else {\n                    hir::WordBoundary::Ascii\n                })\n            }\n            ast::AssertionKind::NotWordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::UnicodeNegate\n                } else {\n                    // It is possible for negated ASCII word boundaries to\n                    // match at invalid UTF-8 boundaries, even when searching\n                    // valid UTF-8.\n                    if !self.trans().allow_invalid_utf8 {\n                        return Err(self.error(\n                            asst.span, ErrorKind::InvalidUtf8));\n                    }\n                    hir::WordBoundary::AsciiNegate\n                })\n            }\n        })\n"
      ],
      "input_infer": "asst.kind = ast::AssertionKind::StartLine, multi_line = true, unicode = true, allow_invalid_utf8 = true, span.start = 0, span.end = 1\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(1) };",
                "    ",
                "    let asst = ast::Assertion {",
                "        span,",
                "        kind: ast::AssertionKind::StartLine,",
                "    };",
                "    ",
                "    let translator = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags {",
                "            multi_line: Some(true),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "",
                "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                "    let _ = translator_i.hir_assertion(&asst);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::StartLine };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::StartLine };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::StartLine));"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::StartLine };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_always_utf8());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::StartLine };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_all_assertions());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::StartLine };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_anchored_start());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::StartLine };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_anchored_end());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::StartLine };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_any_anchored_start());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::StartLine };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_any_anchored_end());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::StartLine };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_match_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::StartLine };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::StartLine };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::StartLine));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::StartLine };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_always_utf8());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::StartLine };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_all_assertions());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::StartLine };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_anchored_start());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::StartLine };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_anchored_end());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::StartLine };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_any_anchored_start());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::StartLine };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_any_anchored_end());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::StartLine };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_match_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2564:29\n     |\n2564 |     assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::StartLine));\n     |                             ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(1) };",
                "    ",
                "    let asst = ast::Assertion {",
                "        span,",
                "        kind: ast::AssertionKind::EndLine,",
                "    };",
                "    ",
                "    let translator = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags {",
                "            multi_line: Some(true),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "",
                "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                "    let _ = translator_i.hir_assertion(&asst);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::EndLine));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::EndLine };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::EndLine));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2564:29\n     |\n2564 |     assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::EndLine));\n     |                             ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(1) };",
                "    ",
                "    let asst = ast::Assertion {",
                "        span,",
                "        kind: ast::AssertionKind::StartText,",
                "    };",
                "    ",
                "    let translator = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags {",
                "            multi_line: Some(true),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "",
                "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                "    let _ = translator_i.hir_assertion(&asst);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::StartText };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::StartText };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::Anchor(hir::Anchor::StartText));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::StartText };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::StartText };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::Anchor(hir::Anchor::StartText));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2564:36\n     |\n2564 |     assert_eq!(hir_result.kind(), &HirKind::Anchor(hir::Anchor::StartText));\n     |                                    ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(1) };",
                "    ",
                "    let asst = ast::Assertion {",
                "        span,",
                "        kind: ast::AssertionKind::EndText,",
                "    };",
                "    ",
                "    let translator = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags {",
                "            multi_line: Some(true),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "",
                "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                "    let _ = translator_i.hir_assertion(&asst);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::EndText };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::EndText };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::EndText));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::EndText };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            multi_line: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::EndText };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { multi_line: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::EndText));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2564:29\n     |\n2564 |     assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::EndText));\n     |                             ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(1) };",
                "    ",
                "    let asst = ast::Assertion {",
                "        span,",
                "        kind: ast::AssertionKind::WordBoundary,",
                "    };",
                "    ",
                "    let translator = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(true),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "",
                "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                "    let _ = translator_i.hir_assertion(&asst);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::WordBoundary(hir::WordBoundary::Unicode));"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_always_utf8());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_all_assertions());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_anchored_start());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_anchored_end());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_any_anchored_start());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_any_anchored_end());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_match_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::WordBoundary(hir::WordBoundary::Unicode));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_always_utf8());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_all_assertions());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_anchored_start());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_anchored_end());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_any_anchored_start());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_any_anchored_end());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion { span, kind: ast::AssertionKind::WordBoundary };",
                  "    let translator = Translator { stack: RefCell::new(Vec::new()), flags: Cell::new(Flags { unicode: Some(true), ..Default::default() }), allow_invalid_utf8: true };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_match_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2564:29\n     |\n2564 |     assert_eq!(hir.kind(), &HirKind::WordBoundary(hir::WordBoundary::Unicode));\n     |                             ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let span = Span { start: Position(0), end: Position(1) };",
                "    ",
                "    let asst = ast::Assertion {",
                "        span,",
                "        kind: ast::AssertionKind::NotWordBoundary,",
                "    };",
                "    ",
                "    let translator = Translator {",
                "        stack: RefCell::new(Vec::new()),",
                "        flags: Cell::new(Flags {",
                "            unicode: Some(true),",
                "            ..Default::default()",
                "        }),",
                "        allow_invalid_utf8: true,",
                "    };",
                "",
                "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                "    let _ = translator_i.hir_assertion(&asst);",
                "}"
              ],
              "oracles": [
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::WordBoundary(hir::WordBoundary::UnicodeNegate));"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_always_utf8());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_anchored_start());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_anchored_end());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_any_anchored_start());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_any_anchored_end());"
                ],
                [
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_match_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::WordBoundary(hir::WordBoundary::UnicodeNegate));",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_always_utf8());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_anchored_start());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_anchored_end());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_any_anchored_start());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(!hir.is_any_anchored_end());",
                  "}"
                ],
                [
                  "{",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    ",
                  "    let asst = ast::Assertion {",
                  "        span,",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    ",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(Vec::new()),",
                  "        flags: Cell::new(Flags {",
                  "            unicode: Some(true),",
                  "            ..Default::default()",
                  "        }),",
                  "        allow_invalid_utf8: true,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let _ = translator_i.hir_assertion(&asst);",
                  "    let span = Span { start: Position(0), end: Position(1) };",
                  "    let asst = ast::Assertion {",
                  "    span,",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(Vec::new()),",
                  "    flags: Cell::new(Flags {",
                  "    unicode: Some(true),",
                  "    ..Default::default()",
                  "    }),",
                  "    allow_invalid_utf8: true,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"some_pattern\");",
                  "    let result = translator_i.hir_assertion(&asst);",
                  "    let hir = result.unwrap();",
                  "    assert!(hir.is_match_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2574:29\n     |\n2574 |     assert_eq!(hir.kind(), &HirKind::WordBoundary(hir::WordBoundary::UnicodeNegate));\n     |                             ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432, E0433.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:30\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2540:48\n     |\n2540 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:30\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                              ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Position` in this scope\n    --> regex-syntax/src/hir/translate.rs:2558:48\n     |\n2558 |     let span = Span { start: Position(0), end: Position(1) };\n     |                                                ^^^^^^^^ not found in this scope\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0425, E0432.\nFor more information about an error, try `rustc --explain E0425`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 11,
      "prompt_conds": [
        "// constraint: asst.kind matches ast::AssertionKind::StartLine is true\n",
        "// constraint: asst.kind matches ast::AssertionKind::StartLine is true\n",
        "// constraint: multi_line is false\n",
        "// expected return value/type: Ok(match asst.kind {\n            ast::AssertionKind::StartLine => {\n                Hir::anchor(if multi_line {\n                    hir::Anchor::StartLine\n                } else {\n                    hir::Anchor::StartText\n                })\n            }\n            ast::AssertionKind::EndLine => {\n                Hir::anchor(if multi_line {\n                    hir::Anchor::EndLine\n                } else {\n                    hir::Anchor::EndText\n                })\n            }\n            ast::AssertionKind::StartText => {\n                Hir::anchor(hir::Anchor::StartText)\n            }\n            ast::AssertionKind::EndText => {\n                Hir::anchor(hir::Anchor::EndText)\n            }\n            ast::AssertionKind::WordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::Unicode\n                } else {\n                    hir::WordBoundary::Ascii\n                })\n            }\n            ast::AssertionKind::NotWordBoundary => {\n                Hir::word_boundary(if unicode {\n                    hir::WordBoundary::UnicodeNegate\n                } else {\n                    // It is possible for negated ASCII word boundaries to\n                    // match at invalid UTF-8 boundaries, even when searching\n                    // valid UTF-8.\n                    if !self.trans().allow_invalid_utf8 {\n                        return Err(self.error(\n                            asst.span, ErrorKind::InvalidUtf8));\n                    }\n                    hir::WordBoundary::AsciiNegate\n                })\n            }\n        })\n"
      ],
      "input_infer": "asst.kind = AssertionKind::StartLine, multi_line = false\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: None,",
                "            multi_line: Some(false),",
                "            dot_matches_new_line: None,",
                "            swap_greed: None,",
                "            unicode: None,",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: 0, end: 1 },",
                "        kind: ast::AssertionKind::StartLine,",
                "    };",
                "",
                "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                "    let _ = translator_i.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: None, }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: 0, end: 1 }, kind: ast::AssertionKind::StartLine, };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: None, }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: 0, end: 1 }, kind: ast::AssertionKind::StartLine, };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::StartText));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: None, }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: 0, end: 1 }, kind: ast::AssertionKind::StartLine, };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 0, end: 1 },",
                  "        kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: None, }), allow_invalid_utf8: false, };",
                  "    let assertion = ast::Assertion { span: Span { start: 0, end: 1 }, kind: ast::AssertionKind::StartLine, };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::StartText));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:58\n     |\n2560 |     let assertion = ast::Assertion { span: Span { start: 0, end: 1 }, kind: ast::AssertionKind::StartLine, };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:66\n     |\n2560 |     let assertion = ast::Assertion { span: Span { start: 0, end: 1 }, kind: ast::AssertionKind::StartLine, };\n     |                                                                  ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2564:29\n     |\n2564 |     assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::StartText));\n     |                             ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 0, end: 1 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 0, end: 1 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:58\n     |\n2560 |     let assertion = ast::Assertion { span: Span { start: 0, end: 1 }, kind: ast::AssertionKind::StartLine, };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:66\n     |\n2560 |     let assertion = ast::Assertion { span: Span { start: 0, end: 1 }, kind: ast::AssertionKind::StartLine, };\n     |                                                                  ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: None,",
                "            multi_line: Some(false),",
                "            dot_matches_new_line: None,",
                "            swap_greed: None,",
                "            unicode: None,",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: 1, end: 2 },",
                "        kind: ast::AssertionKind::EndLine,",
                "    };",
                "",
                "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                "    let _ = translator_i.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let translator_i_start_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_start_line = translator_i_start_line.hir_assertion(&assertion_start_line);",
                  "    assert!(result_start_line.is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let translator_i_start_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_start_line = translator_i_start_line.hir_assertion(&assertion_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    assert_eq!(hir_start_line.kind(), &HirKind::Anchor(hir::Anchor::StartText));"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let translator_i_start_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_start_line = translator_i_start_line.hir_assertion(&assertion_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let translator_i_end_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_end_line = translator_i_end_line.hir_assertion(&assertion_end_line);",
                  "    assert!(result_end_line.is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let translator_i_start_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_start_line = translator_i_start_line.hir_assertion(&assertion_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let translator_i_end_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_end_line = translator_i_end_line.hir_assertion(&assertion_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    assert_eq!(hir_end_line.kind(), &HirKind::Anchor(hir::Anchor::EndText));"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let translator_i_start_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_start_line = translator_i_start_line.hir_assertion(&assertion_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let translator_i_end_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_end_line = translator_i_end_line.hir_assertion(&assertion_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    let translator_i_start_text = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_start_text = translator_i_start_text.hir_assertion(&assertion_start_text);",
                  "    assert!(result_start_text.is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let translator_i_start_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_start_line = translator_i_start_line.hir_assertion(&assertion_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let translator_i_end_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_end_line = translator_i_end_line.hir_assertion(&assertion_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    let translator_i_start_text = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_start_text = translator_i_start_text.hir_assertion(&assertion_start_text);",
                  "    let hir_start_text = result_start_text.unwrap();",
                  "    assert_eq!(hir_start_text.kind(), &HirKind::Anchor(hir::Anchor::StartText));"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let translator_i_start_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_start_line = translator_i_start_line.hir_assertion(&assertion_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let translator_i_end_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_end_line = translator_i_end_line.hir_assertion(&assertion_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    let translator_i_start_text = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_start_text = translator_i_start_text.hir_assertion(&assertion_start_text);",
                  "    let hir_start_text = result_start_text.unwrap();",
                  "    let translator_i_end_text = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_end_text = translator_i_end_text.hir_assertion(&assertion_end_text);",
                  "    assert!(result_end_text.is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let translator_i_start_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_start_line = translator_i_start_line.hir_assertion(&assertion_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let translator_i_end_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_end_line = translator_i_end_line.hir_assertion(&assertion_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    let translator_i_start_text = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_start_text = translator_i_start_text.hir_assertion(&assertion_start_text);",
                  "    let hir_start_text = result_start_text.unwrap();",
                  "    let translator_i_end_text = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_end_text = translator_i_end_text.hir_assertion(&assertion_end_text);",
                  "    let hir_end_text = result_end_text.unwrap();",
                  "    assert_eq!(hir_end_text.kind(), &HirKind::Anchor(hir::Anchor::EndText));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 1, end: 2 },",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let translator_i_start_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_start_line = translator_i_start_line.hir_assertion(&assertion_start_line);",
                  "    assert!(result_start_line.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 1, end: 2 },",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let translator_i_start_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_start_line = translator_i_start_line.hir_assertion(&assertion_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    assert_eq!(hir_start_line.kind(), &HirKind::Anchor(hir::Anchor::StartText));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 1, end: 2 },",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let translator_i_start_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_start_line = translator_i_start_line.hir_assertion(&assertion_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let translator_i_end_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_end_line = translator_i_end_line.hir_assertion(&assertion_end_line);",
                  "    assert!(result_end_line.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 1, end: 2 },",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let translator_i_start_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_start_line = translator_i_start_line.hir_assertion(&assertion_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let translator_i_end_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_end_line = translator_i_end_line.hir_assertion(&assertion_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    assert_eq!(hir_end_line.kind(), &HirKind::Anchor(hir::Anchor::EndText));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 1, end: 2 },",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let translator_i_start_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_start_line = translator_i_start_line.hir_assertion(&assertion_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let translator_i_end_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_end_line = translator_i_end_line.hir_assertion(&assertion_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    let translator_i_start_text = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_start_text = translator_i_start_text.hir_assertion(&assertion_start_text);",
                  "    assert!(result_start_text.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 1, end: 2 },",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let translator_i_start_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_start_line = translator_i_start_line.hir_assertion(&assertion_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let translator_i_end_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_end_line = translator_i_end_line.hir_assertion(&assertion_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    let translator_i_start_text = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_start_text = translator_i_start_text.hir_assertion(&assertion_start_text);",
                  "    let hir_start_text = result_start_text.unwrap();",
                  "    assert_eq!(hir_start_text.kind(), &HirKind::Anchor(hir::Anchor::StartText));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 1, end: 2 },",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let translator_i_start_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_start_line = translator_i_start_line.hir_assertion(&assertion_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let translator_i_end_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_end_line = translator_i_end_line.hir_assertion(&assertion_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    let translator_i_start_text = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_start_text = translator_i_start_text.hir_assertion(&assertion_start_text);",
                  "    let hir_start_text = result_start_text.unwrap();",
                  "    let translator_i_end_text = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_end_text = translator_i_end_text.hir_assertion(&assertion_end_text);",
                  "    assert!(result_end_text.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 1, end: 2 },",
                  "        kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let translator_i_start_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_start_line = translator_i_start_line.hir_assertion(&assertion_start_line);",
                  "    let hir_start_line = result_start_line.unwrap();",
                  "    let translator_i_end_line = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_end_line = translator_i_end_line.hir_assertion(&assertion_end_line);",
                  "    let hir_end_line = result_end_line.unwrap();",
                  "    let translator_i_start_text = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_start_text = translator_i_start_text.hir_assertion(&assertion_start_text);",
                  "    let hir_start_text = result_start_text.unwrap();",
                  "    let translator_i_end_text = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result_end_text = translator_i_end_text.hir_assertion(&assertion_end_text);",
                  "    let hir_end_text = result_end_text.unwrap();",
                  "    assert_eq!(hir_end_text.kind(), &HirKind::Anchor(hir::Anchor::EndText));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2575:25\n     |\n2575 |     span: Span { start: 1, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2575:33\n     |\n2575 |     span: Span { start: 1, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:25\n     |\n2579 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:33\n     |\n2579 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2583:25\n     |\n2583 |     span: Span { start: 3, end: 4 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2583:33\n     |\n2583 |     span: Span { start: 3, end: 4 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2589:40\n     |\n2589 |     assert_eq!(hir_start_line.kind(), &HirKind::Anchor(hir::Anchor::StartText));\n     |                                        ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2575:25\n     |\n2575 |     span: Span { start: 1, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2575:33\n     |\n2575 |     span: Span { start: 1, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:25\n     |\n2579 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:33\n     |\n2579 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2583:25\n     |\n2583 |     span: Span { start: 3, end: 4 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2583:33\n     |\n2583 |     span: Span { start: 3, end: 4 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2575:25\n     |\n2575 |     span: Span { start: 1, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2575:33\n     |\n2575 |     span: Span { start: 1, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:25\n     |\n2579 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:33\n     |\n2579 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2583:25\n     |\n2583 |     span: Span { start: 3, end: 4 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2583:33\n     |\n2583 |     span: Span { start: 3, end: 4 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2592:38\n     |\n2592 |     assert_eq!(hir_end_line.kind(), &HirKind::Anchor(hir::Anchor::EndText));\n     |                                      ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2575:25\n     |\n2575 |     span: Span { start: 1, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2575:33\n     |\n2575 |     span: Span { start: 1, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:25\n     |\n2579 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:33\n     |\n2579 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2583:25\n     |\n2583 |     span: Span { start: 3, end: 4 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2583:33\n     |\n2583 |     span: Span { start: 3, end: 4 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2575:25\n     |\n2575 |     span: Span { start: 1, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2575:33\n     |\n2575 |     span: Span { start: 1, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:25\n     |\n2579 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:33\n     |\n2579 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2583:25\n     |\n2583 |     span: Span { start: 3, end: 4 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2583:33\n     |\n2583 |     span: Span { start: 3, end: 4 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2595:40\n     |\n2595 |     assert_eq!(hir_start_text.kind(), &HirKind::Anchor(hir::Anchor::StartText));\n     |                                        ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2575:25\n     |\n2575 |     span: Span { start: 1, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2575:33\n     |\n2575 |     span: Span { start: 1, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:25\n     |\n2579 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:33\n     |\n2579 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2583:25\n     |\n2583 |     span: Span { start: 3, end: 4 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2583:33\n     |\n2583 |     span: Span { start: 3, end: 4 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2575:25\n     |\n2575 |     span: Span { start: 1, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2575:33\n     |\n2575 |     span: Span { start: 1, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:25\n     |\n2579 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:33\n     |\n2579 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2583:25\n     |\n2583 |     span: Span { start: 3, end: 4 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2583:33\n     |\n2583 |     span: Span { start: 3, end: 4 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2598:38\n     |\n2598 |     assert_eq!(hir_end_text.kind(), &HirKind::Anchor(hir::Anchor::EndText));\n     |                                      ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 1, end: 2 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 1, end: 2 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2575:25\n     |\n2575 |     span: Span { start: 1, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2575:33\n     |\n2575 |     span: Span { start: 1, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:25\n     |\n2579 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2579:33\n     |\n2579 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2583:25\n     |\n2583 |     span: Span { start: 3, end: 4 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2583:33\n     |\n2583 |     span: Span { start: 3, end: 4 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: None,",
                "            multi_line: Some(false),",
                "            dot_matches_new_line: None,",
                "            swap_greed: None,",
                "            unicode: None,",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: 2, end: 3 },",
                "        kind: ast::AssertionKind::StartText,",
                "    };",
                "",
                "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                "    let _ = translator_i.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let expected_start_line_result = Ok(Hir::anchor(hir::Anchor::StartText));",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    assert_eq!(result_start_line, expected_start_line_result);"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let expected_start_line_result = Ok(Hir::anchor(hir::Anchor::StartText));",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let expected_end_line_result = Ok(Hir::anchor(hir::Anchor::EndText));",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    assert_eq!(result_end_line, expected_end_line_result);"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let expected_start_line_result = Ok(Hir::anchor(hir::Anchor::StartText));",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let expected_end_line_result = Ok(Hir::anchor(hir::Anchor::EndText));",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let expected_start_text_result = Ok(Hir::anchor(hir::Anchor::StartText));",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text);",
                  "    assert_eq!(result_start_text, expected_start_text_result);"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let expected_start_line_result = Ok(Hir::anchor(hir::Anchor::StartText));",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let expected_end_line_result = Ok(Hir::anchor(hir::Anchor::EndText));",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let expected_start_text_result = Ok(Hir::anchor(hir::Anchor::StartText));",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text);",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let expected_end_text_result = Ok(Hir::anchor(hir::Anchor::EndText));",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text);",
                  "    assert_eq!(result_end_text, expected_end_text_result);"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let expected_start_line_result = Ok(Hir::anchor(hir::Anchor::StartText));",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let expected_end_line_result = Ok(Hir::anchor(hir::Anchor::EndText));",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let expected_start_text_result = Ok(Hir::anchor(hir::Anchor::StartText));",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text);",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let expected_end_text_result = Ok(Hir::anchor(hir::Anchor::EndText));",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text);",
                  "    let assertion_word_boundary = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let expected_word_boundary_result = Ok(Hir::word_boundary(hir::WordBoundary::Ascii));",
                  "    let result_word_boundary = translator_i.hir_assertion(&assertion_word_boundary);",
                  "    assert_eq!(result_word_boundary, expected_word_boundary_result);"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let expected_start_line_result = Ok(Hir::anchor(hir::Anchor::StartText));",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let expected_end_line_result = Ok(Hir::anchor(hir::Anchor::EndText));",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let expected_start_text_result = Ok(Hir::anchor(hir::Anchor::StartText));",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text);",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let expected_end_text_result = Ok(Hir::anchor(hir::Anchor::EndText));",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text);",
                  "    let assertion_word_boundary = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let expected_word_boundary_result = Ok(Hir::word_boundary(hir::WordBoundary::Ascii));",
                  "    let result_word_boundary = translator_i.hir_assertion(&assertion_word_boundary);",
                  "    let assertion_not_word_boundary = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let expected_not_word_boundary_result = Ok(Hir::word_boundary(hir::WordBoundary::AsciiNegate));",
                  "    let result_not_word_boundary = translator_i.hir_assertion(&assertion_not_word_boundary);",
                  "    assert_eq!(result_not_word_boundary, expected_not_word_boundary_result);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 2, end: 3 },",
                  "        kind: ast::AssertionKind::StartText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let expected_start_line_result = Ok(Hir::anchor(hir::Anchor::StartText));",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    assert_eq!(result_start_line, expected_start_line_result);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 2, end: 3 },",
                  "        kind: ast::AssertionKind::StartText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let expected_start_line_result = Ok(Hir::anchor(hir::Anchor::StartText));",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let expected_end_line_result = Ok(Hir::anchor(hir::Anchor::EndText));",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    assert_eq!(result_end_line, expected_end_line_result);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 2, end: 3 },",
                  "        kind: ast::AssertionKind::StartText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let expected_start_line_result = Ok(Hir::anchor(hir::Anchor::StartText));",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let expected_end_line_result = Ok(Hir::anchor(hir::Anchor::EndText));",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let expected_start_text_result = Ok(Hir::anchor(hir::Anchor::StartText));",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text);",
                  "    assert_eq!(result_start_text, expected_start_text_result);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 2, end: 3 },",
                  "        kind: ast::AssertionKind::StartText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let expected_start_line_result = Ok(Hir::anchor(hir::Anchor::StartText));",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let expected_end_line_result = Ok(Hir::anchor(hir::Anchor::EndText));",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let expected_start_text_result = Ok(Hir::anchor(hir::Anchor::StartText));",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text);",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let expected_end_text_result = Ok(Hir::anchor(hir::Anchor::EndText));",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text);",
                  "    assert_eq!(result_end_text, expected_end_text_result);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 2, end: 3 },",
                  "        kind: ast::AssertionKind::StartText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let expected_start_line_result = Ok(Hir::anchor(hir::Anchor::StartText));",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let expected_end_line_result = Ok(Hir::anchor(hir::Anchor::EndText));",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let expected_start_text_result = Ok(Hir::anchor(hir::Anchor::StartText));",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text);",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let expected_end_text_result = Ok(Hir::anchor(hir::Anchor::EndText));",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text);",
                  "    let assertion_word_boundary = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let expected_word_boundary_result = Ok(Hir::word_boundary(hir::WordBoundary::Ascii));",
                  "    let result_word_boundary = translator_i.hir_assertion(&assertion_word_boundary);",
                  "    assert_eq!(result_word_boundary, expected_word_boundary_result);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 2, end: 3 },",
                  "        kind: ast::AssertionKind::StartText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let expected_start_line_result = Ok(Hir::anchor(hir::Anchor::StartText));",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let expected_end_line_result = Ok(Hir::anchor(hir::Anchor::EndText));",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let expected_start_text_result = Ok(Hir::anchor(hir::Anchor::StartText));",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text);",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let expected_end_text_result = Ok(Hir::anchor(hir::Anchor::EndText));",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text);",
                  "    let assertion_word_boundary = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let expected_word_boundary_result = Ok(Hir::word_boundary(hir::WordBoundary::Ascii));",
                  "    let result_word_boundary = translator_i.hir_assertion(&assertion_word_boundary);",
                  "    let assertion_not_word_boundary = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let expected_not_word_boundary_result = Ok(Hir::word_boundary(hir::WordBoundary::AsciiNegate));",
                  "    let result_not_word_boundary = translator_i.hir_assertion(&assertion_not_word_boundary);",
                  "    assert_eq!(result_not_word_boundary, expected_not_word_boundary_result);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 2, end: 3 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 2, end: 3 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 2, end: 3 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 2, end: 3 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2577:25\n     |\n2577 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2577:33\n     |\n2577 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 2, end: 3 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 2, end: 3 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2577:25\n     |\n2577 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2577:33\n     |\n2577 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2583:25\n     |\n2583 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2583:33\n     |\n2583 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 2, end: 3 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 2, end: 3 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2577:25\n     |\n2577 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2577:33\n     |\n2577 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2583:25\n     |\n2583 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2583:33\n     |\n2583 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2589:25\n     |\n2589 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2589:33\n     |\n2589 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 2, end: 3 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 2, end: 3 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2577:25\n     |\n2577 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2577:33\n     |\n2577 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2583:25\n     |\n2583 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2583:33\n     |\n2583 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2589:25\n     |\n2589 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2589:33\n     |\n2589 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2595:25\n     |\n2595 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2595:33\n     |\n2595 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 2, end: 3 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 2, end: 3 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2577:25\n     |\n2577 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2577:33\n     |\n2577 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2583:25\n     |\n2583 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2583:33\n     |\n2583 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2589:25\n     |\n2589 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2589:33\n     |\n2589 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2595:25\n     |\n2595 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2595:33\n     |\n2595 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2601:25\n     |\n2601 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2601:33\n     |\n2601 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: None,",
                "            multi_line: Some(false),",
                "            dot_matches_new_line: None,",
                "            swap_greed: None,",
                "            unicode: None,",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: 3, end: 4 },",
                "        kind: ast::AssertionKind::EndText,",
                "    };",
                "",
                "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                "    let _ = translator_i.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.is_always_utf8(), true);"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.is_all_assertions(), true);"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.is_anchored_start(), false);"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.is_anchored_end(), false);"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.is_any_anchored_start(), false);"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.is_any_anchored_end(), false);"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.is_match_empty(), true);"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::StartText));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 3, end: 4 },",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 3, end: 4 },",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.is_always_utf8(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 3, end: 4 },",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.is_all_assertions(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 3, end: 4 },",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.is_anchored_start(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 3, end: 4 },",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.is_anchored_end(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 3, end: 4 },",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.is_any_anchored_start(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 3, end: 4 },",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.is_any_anchored_end(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 3, end: 4 },",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.is_match_empty(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: None,",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 3, end: 4 },",
                  "        kind: ast::AssertionKind::EndText,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: None,",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir = result.unwrap();",
                  "    assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::StartText));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 3, end: 4 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 3, end: 4 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 3, end: 4 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 3, end: 4 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 3, end: 4 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 3, end: 4 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 3, end: 4 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 3, end: 4 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 3, end: 4 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 3, end: 4 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 3, end: 4 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 3, end: 4 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 3, end: 4 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 3, end: 4 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 3, end: 4 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 3, end: 4 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 3, end: 4 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 3, end: 4 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 3, end: 4 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 3, end: 4 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 3, end: 4 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 3, end: 4 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 3, end: 4 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 3, end: 4 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 3, end: 4 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 3, end: 4 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 3, end: 4 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 3, end: 4 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 3, end: 4 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 3, end: 4 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 3, end: 4 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 3, end: 4 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2577:29\n     |\n2577 |     assert_eq!(hir.kind(), &HirKind::Anchor(hir::Anchor::StartText));\n     |                             ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 3, end: 4 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 3, end: 4 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 3, end: 4 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 3, end: 4 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: None,",
                "            multi_line: Some(false),",
                "            dot_matches_new_line: None,",
                "            swap_greed: None,",
                "            unicode: Some(true),",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: 4, end: 5 },",
                "        kind: ast::AssertionKind::WordBoundary,",
                "    };",
                "",
                "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                "    let _ = translator_i.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: Some(true) }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: Some(true) }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::Anchor(hir::Anchor::StartText));"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: Some(true) }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::EndLine };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: Some(true) }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::EndLine };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::Anchor(hir::Anchor::EndText));"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: Some(true) }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::EndLine };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::WordBoundary };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: Some(true) }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::EndLine };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::WordBoundary };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::Unicode));"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: Some(true) }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::EndLine };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::WordBoundary };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());"
                ],
                [
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: Some(true) }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::EndLine };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::WordBoundary };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::UnicodeNegate));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 4, end: 5 },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: Some(true) }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 4, end: 5 },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: Some(true) }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::Anchor(hir::Anchor::StartText));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 4, end: 5 },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: Some(true) }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::EndLine };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 4, end: 5 },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: Some(true) }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::EndLine };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::Anchor(hir::Anchor::EndText));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 4, end: 5 },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: Some(true) }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::EndLine };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::WordBoundary };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 4, end: 5 },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: Some(true) }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::EndLine };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::WordBoundary };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::Unicode));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 4, end: 5 },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: Some(true) }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::EndLine };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::WordBoundary };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    assert!(result.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(true),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 4, end: 5 },",
                  "        kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator { stack: RefCell::new(vec![]), flags: Cell::new(Flags { case_insensitive: None, multi_line: Some(false), dot_matches_new_line: None, swap_greed: None, unicode: Some(true) }), allow_invalid_utf8: false };",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::EndLine };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::WordBoundary };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::NotWordBoundary };",
                  "    let result = translator_i.hir_assertion(&assertion);",
                  "    let hir_result = result.unwrap();",
                  "    assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::UnicodeNegate));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 4, end: 5 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 4, end: 5 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:58\n     |\n2560 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:66\n     |\n2560 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };\n     |                                                                  ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2564:36\n     |\n2564 |     assert_eq!(hir_result.kind(), &HirKind::Anchor(hir::Anchor::StartText));\n     |                                    ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 4, end: 5 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 4, end: 5 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:58\n     |\n2560 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:66\n     |\n2560 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };\n     |                                                                  ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 4, end: 5 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 4, end: 5 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:58\n     |\n2560 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:66\n     |\n2560 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };\n     |                                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:58\n     |\n2564 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::EndLine };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:66\n     |\n2564 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::EndLine };\n     |                                                                  ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2567:36\n     |\n2567 |     assert_eq!(hir_result.kind(), &HirKind::Anchor(hir::Anchor::EndText));\n     |                                    ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 4, end: 5 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 4, end: 5 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:58\n     |\n2560 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:66\n     |\n2560 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };\n     |                                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:58\n     |\n2564 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::EndLine };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:66\n     |\n2564 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::EndLine };\n     |                                                                  ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 4, end: 5 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 4, end: 5 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:58\n     |\n2560 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:66\n     |\n2560 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };\n     |                                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:58\n     |\n2564 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::EndLine };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:66\n     |\n2564 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::EndLine };\n     |                                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2567:58\n     |\n2567 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::WordBoundary };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2567:66\n     |\n2567 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                  ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2570:36\n     |\n2570 |     assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::Unicode));\n     |                                    ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 4, end: 5 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 4, end: 5 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:58\n     |\n2560 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:66\n     |\n2560 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };\n     |                                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:58\n     |\n2564 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::EndLine };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:66\n     |\n2564 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::EndLine };\n     |                                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2567:58\n     |\n2567 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::WordBoundary };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2567:66\n     |\n2567 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                  ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 4, end: 5 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 4, end: 5 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:58\n     |\n2560 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:66\n     |\n2560 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };\n     |                                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:58\n     |\n2564 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::EndLine };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:66\n     |\n2564 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::EndLine };\n     |                                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2567:58\n     |\n2567 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::WordBoundary };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2567:66\n     |\n2567 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2570:58\n     |\n2570 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::NotWordBoundary };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2570:66\n     |\n2570 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::NotWordBoundary };\n     |                                                                  ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2573:36\n     |\n2573 |     assert_eq!(hir_result.kind(), &HirKind::WordBoundary(hir::WordBoundary::UnicodeNegate));\n     |                                    ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 4, end: 5 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 4, end: 5 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:58\n     |\n2560 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2560:66\n     |\n2560 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::StartLine };\n     |                                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:58\n     |\n2564 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::EndLine };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2564:66\n     |\n2564 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::EndLine };\n     |                                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2567:58\n     |\n2567 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::WordBoundary };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2567:66\n     |\n2567 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::WordBoundary };\n     |                                                                  ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2570:58\n     |\n2570 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::NotWordBoundary };\n     |                                                          ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2570:66\n     |\n2570 |     let assertion = ast::Assertion { span: Span { start: 4, end: 5 }, kind: ast::AssertionKind::NotWordBoundary };\n     |                                                                  ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let translator = Translator {",
                "        stack: RefCell::new(vec![]),",
                "        flags: Cell::new(Flags {",
                "            case_insensitive: None,",
                "            multi_line: Some(false),",
                "            dot_matches_new_line: None,",
                "            swap_greed: None,",
                "            unicode: Some(false),",
                "        }),",
                "        allow_invalid_utf8: false,",
                "    };",
                "",
                "    let assertion = ast::Assertion {",
                "        span: Span { start: 5, end: 6 },",
                "        kind: ast::AssertionKind::NotWordBoundary,",
                "    };",
                "",
                "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                "    let _ = translator_i.hir_assertion(&assertion);",
                "}"
              ],
              "oracles": [
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    assert!(result_start_line.is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    assert_eq!(result_start_line.unwrap().kind(), &HirKind::Anchor(hir::Anchor::StartText));"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    assert!(result_end_line.is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    assert_eq!(result_end_line.unwrap().kind(), &HirKind::Anchor(hir::Anchor::EndText));"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text);",
                  "    assert!(result_start_text.is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text);",
                  "    assert_eq!(result_start_text.unwrap().kind(), &HirKind::Anchor(hir::Anchor::StartText));"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text);",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text);",
                  "    assert!(result_end_text.is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text);",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text);",
                  "    assert_eq!(result_end_text.unwrap().kind(), &HirKind::Anchor(hir::Anchor::EndText));"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text);",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text);",
                  "    let assertion_word_boundary = ast::Assertion {",
                  "    span: Span { start: 4, end: 5 },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result_word_boundary = translator_i.hir_assertion(&assertion_word_boundary);",
                  "    assert!(result_word_boundary.is_ok());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text);",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text);",
                  "    let assertion_word_boundary = ast::Assertion {",
                  "    span: Span { start: 4, end: 5 },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result_word_boundary = translator_i.hir_assertion(&assertion_word_boundary);",
                  "    assert_eq!(result_word_boundary.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text);",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text);",
                  "    let assertion_word_boundary = ast::Assertion {",
                  "    span: Span { start: 4, end: 5 },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result_word_boundary = translator_i.hir_assertion(&assertion_word_boundary);",
                  "    let assertion_not_word_boundary = ast::Assertion {",
                  "    span: Span { start: 5, end: 6 },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let result_not_word_boundary = translator_i.hir_assertion(&assertion_not_word_boundary);",
                  "    assert!(result_not_word_boundary.is_err());"
                ],
                [
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text);",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text);",
                  "    let assertion_word_boundary = ast::Assertion {",
                  "    span: Span { start: 4, end: 5 },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result_word_boundary = translator_i.hir_assertion(&assertion_word_boundary);",
                  "    let assertion_not_word_boundary = ast::Assertion {",
                  "    span: Span { start: 5, end: 6 },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let result_not_word_boundary = translator_i.hir_assertion(&assertion_not_word_boundary);",
                  "    assert_eq!(result_not_word_boundary.unwrap_err().kind, ErrorKind::InvalidUtf8);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 5, end: 6 },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    assert!(result_start_line.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 5, end: 6 },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    assert_eq!(result_start_line.unwrap().kind(), &HirKind::Anchor(hir::Anchor::StartText));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 5, end: 6 },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    assert!(result_end_line.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 5, end: 6 },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    assert_eq!(result_end_line.unwrap().kind(), &HirKind::Anchor(hir::Anchor::EndText));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 5, end: 6 },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text);",
                  "    assert!(result_start_text.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 5, end: 6 },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text);",
                  "    assert_eq!(result_start_text.unwrap().kind(), &HirKind::Anchor(hir::Anchor::StartText));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 5, end: 6 },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text);",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text);",
                  "    assert!(result_end_text.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 5, end: 6 },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text);",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text);",
                  "    assert_eq!(result_end_text.unwrap().kind(), &HirKind::Anchor(hir::Anchor::EndText));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 5, end: 6 },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text);",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text);",
                  "    let assertion_word_boundary = ast::Assertion {",
                  "    span: Span { start: 4, end: 5 },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result_word_boundary = translator_i.hir_assertion(&assertion_word_boundary);",
                  "    assert!(result_word_boundary.is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 5, end: 6 },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text);",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text);",
                  "    let assertion_word_boundary = ast::Assertion {",
                  "    span: Span { start: 4, end: 5 },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result_word_boundary = translator_i.hir_assertion(&assertion_word_boundary);",
                  "    assert_eq!(result_word_boundary.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 5, end: 6 },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text);",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text);",
                  "    let assertion_word_boundary = ast::Assertion {",
                  "    span: Span { start: 4, end: 5 },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result_word_boundary = translator_i.hir_assertion(&assertion_word_boundary);",
                  "    let assertion_not_word_boundary = ast::Assertion {",
                  "    span: Span { start: 5, end: 6 },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let result_not_word_boundary = translator_i.hir_assertion(&assertion_not_word_boundary);",
                  "    assert!(result_not_word_boundary.is_err());",
                  "}"
                ],
                [
                  "{",
                  "    let translator = Translator {",
                  "        stack: RefCell::new(vec![]),",
                  "        flags: Cell::new(Flags {",
                  "            case_insensitive: None,",
                  "            multi_line: Some(false),",
                  "            dot_matches_new_line: None,",
                  "            swap_greed: None,",
                  "            unicode: Some(false),",
                  "        }),",
                  "        allow_invalid_utf8: false,",
                  "    };",
                  "",
                  "    let assertion = ast::Assertion {",
                  "        span: Span { start: 5, end: 6 },",
                  "        kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "",
                  "    let translator_i = TranslatorI::new(&translator, \"test pattern\");",
                  "    let _ = translator_i.hir_assertion(&assertion);",
                  "    let translator = Translator {",
                  "    stack: RefCell::new(vec![]),",
                  "    flags: Cell::new(Flags {",
                  "    case_insensitive: None,",
                  "    multi_line: Some(false),",
                  "    dot_matches_new_line: None,",
                  "    swap_greed: None,",
                  "    unicode: Some(false),",
                  "    }),",
                  "    allow_invalid_utf8: false,",
                  "    };",
                  "    let assertion_start_line = ast::Assertion {",
                  "    span: Span { start: 0, end: 1 },",
                  "    kind: ast::AssertionKind::StartLine,",
                  "    };",
                  "    let result_start_line = translator_i.hir_assertion(&assertion_start_line);",
                  "    let assertion_end_line = ast::Assertion {",
                  "    span: Span { start: 1, end: 2 },",
                  "    kind: ast::AssertionKind::EndLine,",
                  "    };",
                  "    let result_end_line = translator_i.hir_assertion(&assertion_end_line);",
                  "    let assertion_start_text = ast::Assertion {",
                  "    span: Span { start: 2, end: 3 },",
                  "    kind: ast::AssertionKind::StartText,",
                  "    };",
                  "    let result_start_text = translator_i.hir_assertion(&assertion_start_text);",
                  "    let assertion_end_text = ast::Assertion {",
                  "    span: Span { start: 3, end: 4 },",
                  "    kind: ast::AssertionKind::EndText,",
                  "    };",
                  "    let result_end_text = translator_i.hir_assertion(&assertion_end_text);",
                  "    let assertion_word_boundary = ast::Assertion {",
                  "    span: Span { start: 4, end: 5 },",
                  "    kind: ast::AssertionKind::WordBoundary,",
                  "    };",
                  "    let result_word_boundary = translator_i.hir_assertion(&assertion_word_boundary);",
                  "    let assertion_not_word_boundary = ast::Assertion {",
                  "    span: Span { start: 5, end: 6 },",
                  "    kind: ast::AssertionKind::NotWordBoundary,",
                  "    };",
                  "    let result_not_word_boundary = translator_i.hir_assertion(&assertion_not_word_boundary);",
                  "    assert_eq!(result_not_word_boundary.unwrap_err().kind, ErrorKind::InvalidUtf8);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 5, end: 6 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 5, end: 6 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2575:52\n     |\n2575 |     assert_eq!(result_start_line.unwrap().kind(), &HirKind::Anchor(hir::Anchor::StartText));\n     |                                                    ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 5, end: 6 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 5, end: 6 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 5, end: 6 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 5, end: 6 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2576:25\n     |\n2576 |     span: Span { start: 1, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2576:33\n     |\n2576 |     span: Span { start: 1, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2580:50\n     |\n2580 |     assert_eq!(result_end_line.unwrap().kind(), &HirKind::Anchor(hir::Anchor::EndText));\n     |                                                  ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 5, end: 6 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 5, end: 6 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2576:25\n     |\n2576 |     span: Span { start: 1, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2576:33\n     |\n2576 |     span: Span { start: 1, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 5, end: 6 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 5, end: 6 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2576:25\n     |\n2576 |     span: Span { start: 1, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2576:33\n     |\n2576 |     span: Span { start: 1, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:25\n     |\n2581 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:33\n     |\n2581 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2585:52\n     |\n2585 |     assert_eq!(result_start_text.unwrap().kind(), &HirKind::Anchor(hir::Anchor::StartText));\n     |                                                    ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 5, end: 6 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 5, end: 6 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2576:25\n     |\n2576 |     span: Span { start: 1, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2576:33\n     |\n2576 |     span: Span { start: 1, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:25\n     |\n2581 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:33\n     |\n2581 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 10 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 5, end: 6 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 5, end: 6 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2576:25\n     |\n2576 |     span: Span { start: 1, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2576:33\n     |\n2576 |     span: Span { start: 1, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:25\n     |\n2581 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:33\n     |\n2581 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2586:25\n     |\n2586 |     span: Span { start: 3, end: 4 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2586:33\n     |\n2586 |     span: Span { start: 3, end: 4 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2590:50\n     |\n2590 |     assert_eq!(result_end_text.unwrap().kind(), &HirKind::Anchor(hir::Anchor::EndText));\n     |                                                  ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 5, end: 6 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 5, end: 6 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2576:25\n     |\n2576 |     span: Span { start: 1, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2576:33\n     |\n2576 |     span: Span { start: 1, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:25\n     |\n2581 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:33\n     |\n2581 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2586:25\n     |\n2586 |     span: Span { start: 3, end: 4 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2586:33\n     |\n2586 |     span: Span { start: 3, end: 4 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 5, end: 6 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 5, end: 6 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2576:25\n     |\n2576 |     span: Span { start: 1, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2576:33\n     |\n2576 |     span: Span { start: 1, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:25\n     |\n2581 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:33\n     |\n2581 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2586:25\n     |\n2586 |     span: Span { start: 3, end: 4 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2586:33\n     |\n2586 |     span: Span { start: 3, end: 4 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2591:25\n     |\n2591 |     span: Span { start: 4, end: 5 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2591:33\n     |\n2591 |     span: Span { start: 4, end: 5 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirKind`\n    --> regex-syntax/src/hir/translate.rs:2595:55\n     |\n2595 |     assert_eq!(result_word_boundary.unwrap().kind(), &HirKind::WordBoundary(hir::WordBoundary::Ascii));\n     |                                                       ^^^^^^^ use of undeclared type `HirKind`\n     |\nhelp: consider importing this enum\n     |\n2535 +    use hir::HirKind;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 5, end: 6 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 5, end: 6 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2576:25\n     |\n2576 |     span: Span { start: 1, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2576:33\n     |\n2576 |     span: Span { start: 1, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:25\n     |\n2581 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:33\n     |\n2581 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2586:25\n     |\n2586 |     span: Span { start: 3, end: 4 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2586:33\n     |\n2586 |     span: Span { start: 3, end: 4 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2591:25\n     |\n2591 |     span: Span { start: 4, end: 5 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2591:33\n     |\n2591 |     span: Span { start: 4, end: 5 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 5, end: 6 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 5, end: 6 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2576:25\n     |\n2576 |     span: Span { start: 1, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2576:33\n     |\n2576 |     span: Span { start: 1, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:25\n     |\n2581 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:33\n     |\n2581 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2586:25\n     |\n2586 |     span: Span { start: 3, end: 4 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2586:33\n     |\n2586 |     span: Span { start: 3, end: 4 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2591:25\n     |\n2591 |     span: Span { start: 4, end: 5 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2591:33\n     |\n2591 |     span: Span { start: 4, end: 5 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2596:25\n     |\n2596 |     span: Span { start: 5, end: 6 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2596:33\n     |\n2596 |     span: Span { start: 5, end: 6 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/translate.rs:2536:8\n     |\n2536 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:29\n     |\n2553 |         span: Span { start: 5, end: 6 },\n     |                             ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2553:37\n     |\n2553 |         span: Span { start: 5, end: 6 },\n     |                                     ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:25\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2571:33\n     |\n2571 |     span: Span { start: 0, end: 1 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2576:25\n     |\n2576 |     span: Span { start: 1, end: 2 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2576:33\n     |\n2576 |     span: Span { start: 1, end: 2 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:25\n     |\n2581 |     span: Span { start: 2, end: 3 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2581:33\n     |\n2581 |     span: Span { start: 2, end: 3 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2586:25\n     |\n2586 |     span: Span { start: 3, end: 4 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2586:33\n     |\n2586 |     span: Span { start: 3, end: 4 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2591:25\n     |\n2591 |     span: Span { start: 4, end: 5 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2591:33\n     |\n2591 |     span: Span { start: 4, end: 5 },\n     |                                 ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2596:25\n     |\n2596 |     span: Span { start: 5, end: 6 },\n     |                         ^ expected `Position`, found integer\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/translate.rs:2596:33\n     |\n2596 |     span: Span { start: 5, end: 6 },\n     |                                 ^ expected `Position`, found integer\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}