{
  "name": "regex_syntax::hir::literal::alternate_literals",
  "name_with_impl": "regex_syntax::hir::literal::alternate_literals",
  "mod_info": {
    "name": "hir::literal",
    "loc": "regex-syntax/src/hir/mod.rs:27:1:27:17"
  },
  "visible": false,
  "loc": "regex-syntax/src/hir/literal/mod.rs:845:1:867:2",
  "fn_tests": [
    {
      "chain_id": 1,
      "prompt_conds": [
        "// constraint: e in es is true\n",
        "// constraint: lits3.is_empty() is true\n"
      ],
      "input_infer": "0 <= es.len() <= 100, 0 <= lits.limit_size() <= 1000, 0 <= lits3.len() <= 200, 0 <= lits2.len() <= 200\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let es: Vec<Hir> = Vec::new(); // empty input for es",
                "    let mut lits = Literals::empty(); // initialize Literals",
                "    let mut func = |_: &Hir, _: &mut Literals| {};",
                "    alternate_literals(&es, &mut lits, func);",
                "}"
              ],
              "oracles": [
                [
                  "    let es: Vec<Hir> = Vec::new();",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(lits.is_empty());"
                ],
                [
                  "    let es: Vec<Hir> = Vec::new();",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(lits.all_complete());"
                ],
                [
                  "    let es: Vec<Hir> = Vec::new();",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert_eq!(lits.limit_size(), 0);"
                ],
                [
                  "    let es: Vec<Hir> = Vec::new();",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert_eq!(lits.limit_class(), 0);"
                ],
                [
                  "    let es: Vec<Hir> = Vec::new();",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert_eq!(lits.literals().len(), 0);"
                ],
                [
                  "    let es: Vec<Hir> = Vec::new();",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(lits.contains_empty());"
                ],
                [
                  "    let es: Vec<Hir> = Vec::new();",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(lits.to_empty().is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let es: Vec<Hir> = Vec::new(); // empty input for es",
                  "    let mut lits = Literals::empty(); // initialize Literals",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es: Vec<Hir> = Vec::new();",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let es: Vec<Hir> = Vec::new(); // empty input for es",
                  "    let mut lits = Literals::empty(); // initialize Literals",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es: Vec<Hir> = Vec::new();",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(lits.all_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let es: Vec<Hir> = Vec::new(); // empty input for es",
                  "    let mut lits = Literals::empty(); // initialize Literals",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es: Vec<Hir> = Vec::new();",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert_eq!(lits.limit_size(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let es: Vec<Hir> = Vec::new(); // empty input for es",
                  "    let mut lits = Literals::empty(); // initialize Literals",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es: Vec<Hir> = Vec::new();",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert_eq!(lits.limit_class(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let es: Vec<Hir> = Vec::new(); // empty input for es",
                  "    let mut lits = Literals::empty(); // initialize Literals",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es: Vec<Hir> = Vec::new();",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert_eq!(lits.literals().len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let es: Vec<Hir> = Vec::new(); // empty input for es",
                  "    let mut lits = Literals::empty(); // initialize Literals",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es: Vec<Hir> = Vec::new();",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(lits.contains_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let es: Vec<Hir> = Vec::new(); // empty input for es",
                  "    let mut lits = Literals::empty(); // initialize Literals",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es: Vec<Hir> = Vec::new();",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(lits.to_empty().is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                },
                {
                  "Ok": null
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }]; // single Hir with default values",
                "    let mut lits = Literals::empty().set_limit_size(0); // limit_size set to zero",
                "    let mut func = |_: &Hir, _: &mut Literals| {};",
                "    alternate_literals(&es, &mut lits, func);",
                "}"
              ],
              "oracles": [
                [
                  "    let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(0);",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(lits.is_empty());"
                ],
                [
                  "    let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(0);",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert_eq!(lits.limit_size(), 0);"
                ],
                [
                  "    let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(0);",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(lits.literals().is_empty());"
                ],
                [
                  "    let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(0);",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(!lits.any_complete());"
                ],
                [
                  "    let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(0);",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(lits.all_complete());"
                ],
                [
                  "    let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(0);",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(lits.contains_empty());"
                ],
                [
                  "    let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(0);",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(lits.to_empty().is_empty());"
                ],
                [
                  "    let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(0);",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert_eq!(lits.min_len(), None);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }]; // single Hir with default values",
                  "    let mut lits = Literals::empty().set_limit_size(0); // limit_size set to zero",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(0);",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }]; // single Hir with default values",
                  "    let mut lits = Literals::empty().set_limit_size(0); // limit_size set to zero",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(0);",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert_eq!(lits.limit_size(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }]; // single Hir with default values",
                  "    let mut lits = Literals::empty().set_limit_size(0); // limit_size set to zero",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(0);",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(lits.literals().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }]; // single Hir with default values",
                  "    let mut lits = Literals::empty().set_limit_size(0); // limit_size set to zero",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(0);",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(!lits.any_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }]; // single Hir with default values",
                  "    let mut lits = Literals::empty().set_limit_size(0); // limit_size set to zero",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(0);",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(lits.all_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }]; // single Hir with default values",
                  "    let mut lits = Literals::empty().set_limit_size(0); // limit_size set to zero",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(0);",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(lits.contains_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }]; // single Hir with default values",
                  "    let mut lits = Literals::empty().set_limit_size(0); // limit_size set to zero",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(0);",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(lits.to_empty().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }]; // single Hir with default values",
                  "    let mut lits = Literals::empty().set_limit_size(0); // limit_size set to zero",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(0);",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert_eq!(lits.min_len(), None);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:53\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }]; // single Hir with default values\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:53\n     |\n1567 |     let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }];\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:53\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }]; // single Hir with default values\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:53\n     |\n1567 |     let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }];\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:53\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }]; // single Hir with default values\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:53\n     |\n1567 |     let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }];\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:53\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }]; // single Hir with default values\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:53\n     |\n1567 |     let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }];\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:53\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }]; // single Hir with default values\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:53\n     |\n1567 |     let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }];\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:53\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }]; // single Hir with default values\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:53\n     |\n1567 |     let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }];\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:53\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }]; // single Hir with default values\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:53\n     |\n1567 |     let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }];\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:53\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }]; // single Hir with default values\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:53\n     |\n1567 |     let es = vec![Hir { kind: HirKind::Empty, info: HirInfo::default() }];\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let es = vec![",
                "        Hir { kind: HirKind::Literal(b'a'.into()), info: HirInfo::default() },",
                "        Hir { kind: HirKind::Literal(b'b'.into()), info: HirInfo::default() }",
                "    ]; // multiple Hirs",
                "    let mut lits = Literals::empty().set_limit_size(100); // limit_size with valid value",
                "    let mut func = |_: &Hir, _: &mut Literals| {};",
                "    alternate_literals(&es, &mut lits, func);",
                "}"
              ],
              "oracles": [
                [
                  "    let es = vec![Hir { kind: HirKind::Literal(b'a'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'b'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(100);",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    assert_eq!(lits.limit_size(), 100);"
                ],
                [
                  "    let es = vec![Hir { kind: HirKind::Literal(b'a'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'b'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(100);",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    assert!(lits.is_empty());"
                ],
                [
                  "    let es = vec![Hir { kind: HirKind::Literal(b'a'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'b'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(100);",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    assert_eq!(lits.literals().len(), 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let es = vec![",
                  "        Hir { kind: HirKind::Literal(b'a'.into()), info: HirInfo::default() },",
                  "        Hir { kind: HirKind::Literal(b'b'.into()), info: HirInfo::default() }",
                  "    ]; // multiple Hirs",
                  "    let mut lits = Literals::empty().set_limit_size(100); // limit_size with valid value",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'a'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'b'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(100);",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    assert_eq!(lits.limit_size(), 100);",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![",
                  "        Hir { kind: HirKind::Literal(b'a'.into()), info: HirInfo::default() },",
                  "        Hir { kind: HirKind::Literal(b'b'.into()), info: HirInfo::default() }",
                  "    ]; // multiple Hirs",
                  "    let mut lits = Literals::empty().set_limit_size(100); // limit_size with valid value",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'a'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'b'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(100);",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    assert!(lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![",
                  "        Hir { kind: HirKind::Literal(b'a'.into()), info: HirInfo::default() },",
                  "        Hir { kind: HirKind::Literal(b'b'.into()), info: HirInfo::default() }",
                  "    ]; // multiple Hirs",
                  "    let mut lits = Literals::empty().set_limit_size(100); // limit_size with valid value",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'a'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'b'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(100);",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    assert_eq!(lits.literals().len(), 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n1564 |         Hir { kind: HirKind::Literal(b'a'.into()), info: HirInfo::default() },\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:58\n     |\n1565 |         Hir { kind: HirKind::Literal(b'b'.into()), info: HirInfo::default() }\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:68\n     |\n1570 |     let es = vec![Hir { kind: HirKind::Literal(b'a'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'b'.into()), info:...\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:139\n     |\n1570 | ...r { kind: HirKind::Literal(b'b'.into()), info: HirInfo::default() }];\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:43\n     |\n1564 |         Hir { kind: HirKind::Literal(b'a'.into()), info: HirInfo::default() },\n     |                                           ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:43\n     |\n1565 |         Hir { kind: HirKind::Literal(b'b'.into()), info: HirInfo::default() }\n     |                                           ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:53\n     |\n1570 | ...nd::Literal(b'a'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'b'.into()), info: HirInfo::default() }];\n     |                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:124\n     |\n1570 | ...nd::Literal(b'b'.into()), info: HirInfo::default() }];\n     |                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n1564 |         Hir { kind: HirKind::Literal(b'a'.into()), info: HirInfo::default() },\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:58\n     |\n1565 |         Hir { kind: HirKind::Literal(b'b'.into()), info: HirInfo::default() }\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:68\n     |\n1570 |     let es = vec![Hir { kind: HirKind::Literal(b'a'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'b'.into()), info:...\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:139\n     |\n1570 | ...r { kind: HirKind::Literal(b'b'.into()), info: HirInfo::default() }];\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:43\n     |\n1564 |         Hir { kind: HirKind::Literal(b'a'.into()), info: HirInfo::default() },\n     |                                           ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:43\n     |\n1565 |         Hir { kind: HirKind::Literal(b'b'.into()), info: HirInfo::default() }\n     |                                           ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:53\n     |\n1570 | ...nd::Literal(b'a'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'b'.into()), info: HirInfo::default() }];\n     |                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:124\n     |\n1570 | ...nd::Literal(b'b'.into()), info: HirInfo::default() }];\n     |                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n1564 |         Hir { kind: HirKind::Literal(b'a'.into()), info: HirInfo::default() },\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:58\n     |\n1565 |         Hir { kind: HirKind::Literal(b'b'.into()), info: HirInfo::default() }\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:68\n     |\n1570 |     let es = vec![Hir { kind: HirKind::Literal(b'a'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'b'.into()), info:...\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:139\n     |\n1570 | ...r { kind: HirKind::Literal(b'b'.into()), info: HirInfo::default() }];\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:43\n     |\n1564 |         Hir { kind: HirKind::Literal(b'a'.into()), info: HirInfo::default() },\n     |                                           ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:43\n     |\n1565 |         Hir { kind: HirKind::Literal(b'b'.into()), info: HirInfo::default() }\n     |                                           ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:53\n     |\n1570 | ...nd::Literal(b'a'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'b'.into()), info: HirInfo::default() }];\n     |                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:124\n     |\n1570 | ...nd::Literal(b'b'.into()), info: HirInfo::default() }];\n     |                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let es = vec![",
                "        Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() },",
                "        Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }",
                "    ]; // non-empty Hirs",
                "    let mut lits = Literals::empty(); // initializing Literals ",
                "    let mut func = |_: &Hir, _: &mut Literals| {}; ",
                "    alternate_literals(&es, &mut lits, func);",
                "}"
              ],
              "oracles": [
                [
                  "    let es = vec![Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    assert!(lits.is_empty());"
                ],
                [
                  "    let es = vec![Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    assert_eq!(lits.limit_size(), 0);"
                ],
                [
                  "    let es = vec![Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    assert_eq!(lits.limit_class(), 0);"
                ],
                [
                  "    let es = vec![Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    assert!(lits.literals().is_empty());"
                ],
                [
                  "    let es = vec![Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    assert!(!lits.any_complete());"
                ],
                [
                  "    let es = vec![Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    assert!(!lits.all_complete());"
                ],
                [
                  "    let es = vec![Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    assert!(!lits.contains_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let es = vec![",
                  "        Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() },",
                  "        Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }",
                  "    ]; // non-empty Hirs",
                  "    let mut lits = Literals::empty(); // initializing Literals ",
                  "    let mut func = |_: &Hir, _: &mut Literals| {}; ",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    assert!(lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![",
                  "        Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() },",
                  "        Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }",
                  "    ]; // non-empty Hirs",
                  "    let mut lits = Literals::empty(); // initializing Literals ",
                  "    let mut func = |_: &Hir, _: &mut Literals| {}; ",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    assert_eq!(lits.limit_size(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![",
                  "        Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() },",
                  "        Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }",
                  "    ]; // non-empty Hirs",
                  "    let mut lits = Literals::empty(); // initializing Literals ",
                  "    let mut func = |_: &Hir, _: &mut Literals| {}; ",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    assert_eq!(lits.limit_class(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![",
                  "        Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() },",
                  "        Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }",
                  "    ]; // non-empty Hirs",
                  "    let mut lits = Literals::empty(); // initializing Literals ",
                  "    let mut func = |_: &Hir, _: &mut Literals| {}; ",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    assert!(lits.literals().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![",
                  "        Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() },",
                  "        Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }",
                  "    ]; // non-empty Hirs",
                  "    let mut lits = Literals::empty(); // initializing Literals ",
                  "    let mut func = |_: &Hir, _: &mut Literals| {}; ",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    assert!(!lits.any_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![",
                  "        Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() },",
                  "        Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }",
                  "    ]; // non-empty Hirs",
                  "    let mut lits = Literals::empty(); // initializing Literals ",
                  "    let mut func = |_: &Hir, _: &mut Literals| {}; ",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    assert!(!lits.all_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![",
                  "        Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() },",
                  "        Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }",
                  "    ]; // non-empty Hirs",
                  "    let mut lits = Literals::empty(); // initializing Literals ",
                  "    let mut func = |_: &Hir, _: &mut Literals| {}; ",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty();",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    assert!(!lits.contains_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n1564 |         Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() },\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:58\n     |\n1565 |         Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:68\n     |\n1570 |     let es = vec![Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info:...\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:139\n     |\n1570 | ...r { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:43\n     |\n1564 |         Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() },\n     |                                           ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:43\n     |\n1565 |         Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }\n     |                                           ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:53\n     |\n1570 | ...nd::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];\n     |                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:124\n     |\n1570 | ...nd::Literal(b'd'.into()), info: HirInfo::default() }];\n     |                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n1564 |         Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() },\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:58\n     |\n1565 |         Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:68\n     |\n1570 |     let es = vec![Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info:...\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:139\n     |\n1570 | ...r { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:43\n     |\n1564 |         Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() },\n     |                                           ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:43\n     |\n1565 |         Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }\n     |                                           ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:53\n     |\n1570 | ...nd::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];\n     |                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:124\n     |\n1570 | ...nd::Literal(b'd'.into()), info: HirInfo::default() }];\n     |                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n1564 |         Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() },\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:58\n     |\n1565 |         Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:68\n     |\n1570 |     let es = vec![Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info:...\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:139\n     |\n1570 | ...r { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:43\n     |\n1564 |         Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() },\n     |                                           ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:43\n     |\n1565 |         Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }\n     |                                           ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:53\n     |\n1570 | ...nd::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];\n     |                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:124\n     |\n1570 | ...nd::Literal(b'd'.into()), info: HirInfo::default() }];\n     |                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n1564 |         Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() },\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:58\n     |\n1565 |         Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:68\n     |\n1570 |     let es = vec![Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info:...\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:139\n     |\n1570 | ...r { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:43\n     |\n1564 |         Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() },\n     |                                           ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:43\n     |\n1565 |         Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }\n     |                                           ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:53\n     |\n1570 | ...nd::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];\n     |                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:124\n     |\n1570 | ...nd::Literal(b'd'.into()), info: HirInfo::default() }];\n     |                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n1564 |         Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() },\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:58\n     |\n1565 |         Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:68\n     |\n1570 |     let es = vec![Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info:...\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:139\n     |\n1570 | ...r { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:43\n     |\n1564 |         Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() },\n     |                                           ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:43\n     |\n1565 |         Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }\n     |                                           ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:53\n     |\n1570 | ...nd::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];\n     |                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:124\n     |\n1570 | ...nd::Literal(b'd'.into()), info: HirInfo::default() }];\n     |                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n1564 |         Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() },\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:58\n     |\n1565 |         Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:68\n     |\n1570 |     let es = vec![Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info:...\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:139\n     |\n1570 | ...r { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:43\n     |\n1564 |         Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() },\n     |                                           ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:43\n     |\n1565 |         Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }\n     |                                           ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:53\n     |\n1570 | ...nd::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];\n     |                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:124\n     |\n1570 | ...nd::Literal(b'd'.into()), info: HirInfo::default() }];\n     |                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n1564 |         Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() },\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:58\n     |\n1565 |         Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:68\n     |\n1570 |     let es = vec![Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info:...\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1570:139\n     |\n1570 | ...r { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];\n     |                                                   ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1564:43\n     |\n1564 |         Hir { kind: HirKind::Literal(b'c'.into()), info: HirInfo::default() },\n     |                                           ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1565:43\n     |\n1565 |         Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }\n     |                                           ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:53\n     |\n1570 | ...nd::Literal(b'c'.into()), info: HirInfo::default() }, Hir { kind: HirKind::Literal(b'd'.into()), info: HirInfo::default() }];\n     |                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1570:124\n     |\n1570 | ...nd::Literal(b'd'.into()), info: HirInfo::default() }];\n     |                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }]; // single Hir input",
                "    let mut lits = Literals::empty().set_limit_size(5); // limit_size set low",
                "    let mut func = |_: &Hir, _: &mut Literals| {};",
                "    alternate_literals(&es, &mut lits, func);",
                "}"
              ],
              "oracles": [
                [
                  "    let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(5);",
                  "    assert_eq!(lits.is_empty(), true);"
                ],
                [
                  "    let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(5);",
                  "    assert_eq!(lits.limit_size(), 5);"
                ],
                [
                  "    let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(5);",
                  "    assert_eq!(lits.literals().len(), 0);"
                ],
                [
                  "    let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(5);",
                  "    assert_eq!(lits.any_complete(), false);"
                ],
                [
                  "    let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(5);",
                  "    assert_eq!(lits.all_complete(), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }]; // single Hir input",
                  "    let mut lits = Literals::empty().set_limit_size(5); // limit_size set low",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(5);",
                  "    assert_eq!(lits.is_empty(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }]; // single Hir input",
                  "    let mut lits = Literals::empty().set_limit_size(5); // limit_size set low",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(5);",
                  "    assert_eq!(lits.limit_size(), 5);",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }]; // single Hir input",
                  "    let mut lits = Literals::empty().set_limit_size(5); // limit_size set low",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(5);",
                  "    assert_eq!(lits.literals().len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }]; // single Hir input",
                  "    let mut lits = Literals::empty().set_limit_size(5); // limit_size set low",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(5);",
                  "    assert_eq!(lits.any_complete(), false);",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }]; // single Hir input",
                  "    let mut lits = Literals::empty().set_limit_size(5); // limit_size set low",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }];",
                  "    let mut lits = Literals::empty().set_limit_size(5);",
                  "    assert_eq!(lits.all_complete(), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:68\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:68\n     |\n1567 |     let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }];\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:53\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1567:53\n     |\n1567 |     let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }];\n     |                                                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:68\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:68\n     |\n1567 |     let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }];\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:53\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1567:53\n     |\n1567 |     let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }];\n     |                                                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:68\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:68\n     |\n1567 |     let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }];\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:53\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1567:53\n     |\n1567 |     let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }];\n     |                                                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:68\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:68\n     |\n1567 |     let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }];\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:53\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1567:53\n     |\n1567 |     let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }];\n     |                                                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:68\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:68\n     |\n1567 |     let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }];\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:53\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1567:53\n     |\n1567 |     let es = vec![Hir { kind: HirKind::Literal(b'e'.into()), info: HirInfo::default() }];\n     |                                                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>(); // max elements in es",
                "    let mut lits = Literals::empty().set_limit_size(1000); // maximum limit_size",
                "    let mut func = |_: &Hir, _: &mut Literals| {};",
                "    alternate_literals(&es, &mut lits, func);",
                "}"
              ],
              "oracles": [
                [
                  "    let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();",
                  "    let mut lits = Literals::empty().set_limit_size(1000);",
                  "    assert_eq!(lits.limit_size(), 1000);"
                ],
                [
                  "    let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();",
                  "    let mut lits = Literals::empty().set_limit_size(1000);",
                  "    assert!(lits.is_empty());"
                ],
                [
                  "    let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();",
                  "    let mut lits = Literals::empty().set_limit_size(1000);",
                  "    assert_eq!(lits.literals().len(), 0);"
                ],
                [
                  "    let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();",
                  "    let mut lits = Literals::empty().set_limit_size(1000);",
                  "    assert_eq!(lits.min_len(), None);"
                ],
                [
                  "    let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();",
                  "    let mut lits = Literals::empty().set_limit_size(1000);",
                  "    assert!(!lits.all_complete());"
                ],
                [
                  "    let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();",
                  "    let mut lits = Literals::empty().set_limit_size(1000);",
                  "    assert!(!lits.any_complete());"
                ],
                [
                  "    let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();",
                  "    let mut lits = Literals::empty().set_limit_size(1000);",
                  "    assert!(!lits.contains_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>(); // max elements in es",
                  "    let mut lits = Literals::empty().set_limit_size(1000); // maximum limit_size",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();",
                  "    let mut lits = Literals::empty().set_limit_size(1000);",
                  "    assert_eq!(lits.limit_size(), 1000);",
                  "}"
                ],
                [
                  "{",
                  "    let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>(); // max elements in es",
                  "    let mut lits = Literals::empty().set_limit_size(1000); // maximum limit_size",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();",
                  "    let mut lits = Literals::empty().set_limit_size(1000);",
                  "    assert!(lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>(); // max elements in es",
                  "    let mut lits = Literals::empty().set_limit_size(1000); // maximum limit_size",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();",
                  "    let mut lits = Literals::empty().set_limit_size(1000);",
                  "    assert_eq!(lits.literals().len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>(); // max elements in es",
                  "    let mut lits = Literals::empty().set_limit_size(1000); // maximum limit_size",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();",
                  "    let mut lits = Literals::empty().set_limit_size(1000);",
                  "    assert_eq!(lits.min_len(), None);",
                  "}"
                ],
                [
                  "{",
                  "    let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>(); // max elements in es",
                  "    let mut lits = Literals::empty().set_limit_size(1000); // maximum limit_size",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();",
                  "    let mut lits = Literals::empty().set_limit_size(1000);",
                  "    assert!(!lits.all_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>(); // max elements in es",
                  "    let mut lits = Literals::empty().set_limit_size(1000); // maximum limit_size",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();",
                  "    let mut lits = Literals::empty().set_limit_size(1000);",
                  "    assert!(!lits.any_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>(); // max elements in es",
                  "    let mut lits = Literals::empty().set_limit_size(1000); // maximum limit_size",
                  "    let mut func = |_: &Hir, _: &mut Literals| {};",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();",
                  "    let mut lits = Literals::empty().set_limit_size(1000);",
                  "    assert!(!lits.contains_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:82\n     |\n1563 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>(); // max elem...\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:82\n     |\n1567 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1563:60\n     |\n1563 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>(); // max elem...\n     |                                           ---------------- ^^^^^^^^^^^^^ expected `Literal`, found `Vec<u8>`\n     |                                           |\n     |                                           arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::Literal`\n              found struct `Vec<u8>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1567:60\n     |\n1567 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();\n     |                                           ---------------- ^^^^^^^^^^^^^ expected `Literal`, found `Vec<u8>`\n     |                                           |\n     |                                           arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::Literal`\n              found struct `Vec<u8>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:82\n     |\n1563 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>(); // max elem...\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:82\n     |\n1567 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1563:60\n     |\n1563 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>(); // max elem...\n     |                                           ---------------- ^^^^^^^^^^^^^ expected `Literal`, found `Vec<u8>`\n     |                                           |\n     |                                           arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::Literal`\n              found struct `Vec<u8>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1567:60\n     |\n1567 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();\n     |                                           ---------------- ^^^^^^^^^^^^^ expected `Literal`, found `Vec<u8>`\n     |                                           |\n     |                                           arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::Literal`\n              found struct `Vec<u8>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:82\n     |\n1563 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>(); // max elem...\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:82\n     |\n1567 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1563:60\n     |\n1563 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>(); // max elem...\n     |                                           ---------------- ^^^^^^^^^^^^^ expected `Literal`, found `Vec<u8>`\n     |                                           |\n     |                                           arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::Literal`\n              found struct `Vec<u8>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1567:60\n     |\n1567 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();\n     |                                           ---------------- ^^^^^^^^^^^^^ expected `Literal`, found `Vec<u8>`\n     |                                           |\n     |                                           arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::Literal`\n              found struct `Vec<u8>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:82\n     |\n1563 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>(); // max elem...\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:82\n     |\n1567 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1563:60\n     |\n1563 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>(); // max elem...\n     |                                           ---------------- ^^^^^^^^^^^^^ expected `Literal`, found `Vec<u8>`\n     |                                           |\n     |                                           arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::Literal`\n              found struct `Vec<u8>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1567:60\n     |\n1567 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();\n     |                                           ---------------- ^^^^^^^^^^^^^ expected `Literal`, found `Vec<u8>`\n     |                                           |\n     |                                           arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::Literal`\n              found struct `Vec<u8>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:82\n     |\n1563 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>(); // max elem...\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:82\n     |\n1567 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1563:60\n     |\n1563 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>(); // max elem...\n     |                                           ---------------- ^^^^^^^^^^^^^ expected `Literal`, found `Vec<u8>`\n     |                                           |\n     |                                           arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::Literal`\n              found struct `Vec<u8>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1567:60\n     |\n1567 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();\n     |                                           ---------------- ^^^^^^^^^^^^^ expected `Literal`, found `Vec<u8>`\n     |                                           |\n     |                                           arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::Literal`\n              found struct `Vec<u8>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:82\n     |\n1563 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>(); // max elem...\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:82\n     |\n1567 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1563:60\n     |\n1563 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>(); // max elem...\n     |                                           ---------------- ^^^^^^^^^^^^^ expected `Literal`, found `Vec<u8>`\n     |                                           |\n     |                                           arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::Literal`\n              found struct `Vec<u8>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1567:60\n     |\n1567 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();\n     |                                           ---------------- ^^^^^^^^^^^^^ expected `Literal`, found `Vec<u8>`\n     |                                           |\n     |                                           arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::Literal`\n              found struct `Vec<u8>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:82\n     |\n1563 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>(); // max elem...\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:82\n     |\n1567 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();\n     |                                                                                  ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1563:60\n     |\n1563 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>(); // max elem...\n     |                                           ---------------- ^^^^^^^^^^^^^ expected `Literal`, found `Vec<u8>`\n     |                                           |\n     |                                           arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::Literal`\n              found struct `Vec<u8>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1567:60\n     |\n1567 |     let es = (0..100).map(|i| Hir { kind: HirKind::Literal(vec![i as u8]), info: HirInfo::default() }).collect::<Vec<Hir>>();\n     |                                           ---------------- ^^^^^^^^^^^^^ expected `Literal`, found `Vec<u8>`\n     |                                           |\n     |                                           arguments to this enum variant are incorrect\n     |\n     = note: expected enum `hir::Literal`\n              found struct `Vec<u8>`\nnote: tuple variant defined here\n    --> regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input",
                "    let mut lits = Literals::empty().set_limit_size(500); // high limit_size",
                "    let mut func = |_: &Hir, _: &mut Literals| {",
                "        // Making lits3 empty for testing purpose",
                "    };",
                "    alternate_literals(&es, &mut lits, func);",
                "}"
              ],
              "oracles": [
                [
                  "    assert_eq!(lits.limit_size(), 500);"
                ],
                [
                  "    assert!(lits.is_empty());"
                ],
                [
                  "    assert_eq!(lits2.limit_size(), 100);"
                ],
                [
                  "    assert!(lits2.is_empty());"
                ],
                [
                  "    assert!(lits.cross_product(&lits2).is_ok());"
                ],
                [
                  "    assert!(lits2.union(lits3).is_ok());"
                ],
                [
                  "    assert!(lits.contains_empty());"
                ],
                [
                  "    assert!(!lits.any_complete());"
                ],
                [
                  "    assert!(lits.all_complete());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input",
                  "    let mut lits = Literals::empty().set_limit_size(500); // high limit_size",
                  "    let mut func = |_: &Hir, _: &mut Literals| {",
                  "        // Making lits3 empty for testing purpose",
                  "    };",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert_eq!(lits.limit_size(), 500);",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input",
                  "    let mut lits = Literals::empty().set_limit_size(500); // high limit_size",
                  "    let mut func = |_: &Hir, _: &mut Literals| {",
                  "        // Making lits3 empty for testing purpose",
                  "    };",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input",
                  "    let mut lits = Literals::empty().set_limit_size(500); // high limit_size",
                  "    let mut func = |_: &Hir, _: &mut Literals| {",
                  "        // Making lits3 empty for testing purpose",
                  "    };",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert_eq!(lits2.limit_size(), 100);",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input",
                  "    let mut lits = Literals::empty().set_limit_size(500); // high limit_size",
                  "    let mut func = |_: &Hir, _: &mut Literals| {",
                  "        // Making lits3 empty for testing purpose",
                  "    };",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(lits2.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input",
                  "    let mut lits = Literals::empty().set_limit_size(500); // high limit_size",
                  "    let mut func = |_: &Hir, _: &mut Literals| {",
                  "        // Making lits3 empty for testing purpose",
                  "    };",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(lits.cross_product(&lits2).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input",
                  "    let mut lits = Literals::empty().set_limit_size(500); // high limit_size",
                  "    let mut func = |_: &Hir, _: &mut Literals| {",
                  "        // Making lits3 empty for testing purpose",
                  "    };",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(lits2.union(lits3).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input",
                  "    let mut lits = Literals::empty().set_limit_size(500); // high limit_size",
                  "    let mut func = |_: &Hir, _: &mut Literals| {",
                  "        // Making lits3 empty for testing purpose",
                  "    };",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(lits.contains_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input",
                  "    let mut lits = Literals::empty().set_limit_size(500); // high limit_size",
                  "    let mut func = |_: &Hir, _: &mut Literals| {",
                  "        // Making lits3 empty for testing purpose",
                  "    };",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(!lits.any_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input",
                  "    let mut lits = Literals::empty().set_limit_size(500); // high limit_size",
                  "    let mut func = |_: &Hir, _: &mut Literals| {",
                  "        // Making lits3 empty for testing purpose",
                  "    };",
                  "    alternate_literals(&es, &mut lits, func);",
                  "    assert!(lits.all_complete());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:68\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:53\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:68\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:53\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:68\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits2` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:16\n     |\n1569 |     assert_eq!(lits2.limit_size(), 100);\n     |                ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:53\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0425, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:68\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits2` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:13\n     |\n1569 |     assert!(lits2.is_empty());\n     |             ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:53\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0425, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 3 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:68\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits2` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:33\n     |\n1569 |     assert!(lits.cross_product(&lits2).is_ok());\n     |                                 ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:53\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nerror[E0599]: no method named `is_ok` found for type `bool` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:40\n     |\n1569 |     assert!(lits.cross_product(&lits2).is_ok());\n     |                                        ^^^^^ method not found in `bool`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0425, E0433, E0599.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:68\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits2` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:13\n     |\n1569 |     assert!(lits2.union(lits3).is_ok());\n     |             ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1569:25\n     |\n1569 |     assert!(lits2.union(lits3).is_ok());\n     |                         ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:53\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0425, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:68\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:53\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:68\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:53\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1563:68\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1555 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0277]: the trait bound `hir::Literal: From<u8>` is not satisfied\n    --> regex-syntax/src/hir/literal/mod.rs:1563:53\n     |\n1563 |     let es = vec![Hir { kind: HirKind::Literal(b'f'.into()), info: HirInfo::default() }]; // single Hir input\n     |                                                     ^^^^ the trait `From<u8>` is not implemented for `hir::Literal`, which is required by `u8: Into<_>`\n     |\n     = note: required for `u8` to implement `Into<hir::Literal>`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 2 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 3,
      "prompt_conds": [
        "// constraint: e in es is true\n",
        "// constraint: lits3.is_empty() is false\n",
        "// constraint: lits2.union(lits3) is true\n",
        "// constraint: e in es is false\n",
        "// constraint: lits.cross_product(&lits2) is false\n"
      ],
      "input_infer": "test input ranges: es: [1..10], lits: Literals with limit_size: [1..50], limit_class: [1..20], lits3: non-empty Literals, union: true, cross_product: false\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut lits = Literals {",
                "        lits: vec![Literal::empty()],",
                "        limit_size: 50,",
                "        limit_class: 10,",
                "    };",
                "",
                "    let es = vec![Hir {}; 5]; // 5 Hir instances",
                "",
                "    alternate_literals(&es, &mut lits, |_, lits3| {",
                "        lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });",
                "    });",
                "}"
              ],
              "oracles": [
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    assert_eq!(lits.limit_size(), 50);"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    assert_eq!(lits.limit_class(), 10);"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    assert!(lits.is_empty());"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    assert_eq!(lits.limit_size(), 100);"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    lits.set_limit_class(20);",
                  "    assert_eq!(lits.limit_class(), 20);"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    lits.set_limit_class(20);",
                  "    assert!(!lits.union(Literals::empty()));"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    lits.set_limit_class(20);",
                  "    assert!(lits.union(Literals { lits: vec![Literal::empty()], limit_size: 50, limit_class: 10 }));"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    lits.set_limit_class(20);",
                  "    assert!(lits.cross_product(&Literals { lits: vec![Literal::empty()], limit_size: 50, limit_class: 10 }));"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    lits.set_limit_class(20);",
                  "    assert!(!lits.cross_product(&Literals { lits: vec![], limit_size: 50, limit_class: 10 }));"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    lits.set_limit_class(20);",
                  "    assert!(lits.any_complete());"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    lits.set_limit_class(20);",
                  "    assert!(lits.all_complete());"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    lits.set_limit_class(20);",
                  "    assert!(!lits.contains_empty());"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    lits.set_limit_class(20);",
                  "    lits.lits.push(Literal::empty());",
                  "    assert!(lits.contains_empty());"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    lits.set_limit_class(20);",
                  "    lits.lits.push(Literal::empty());",
                  "    assert!(lits.literals().len() > 0);"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    lits.set_limit_class(20);",
                  "    lits.lits.push(Literal::empty());",
                  "    assert!(!lits.is_empty());"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    lits.set_limit_class(20);",
                  "    lits.lits.push(Literal::empty());",
                  "    lits.clear();",
                  "    assert!(lits.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 5]; // 5 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    assert_eq!(lits.limit_size(), 50);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 5]; // 5 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    assert_eq!(lits.limit_class(), 10);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 5]; // 5 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    assert!(lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 5]; // 5 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    assert_eq!(lits.limit_size(), 100);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 5]; // 5 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    lits.set_limit_class(20);",
                  "    assert_eq!(lits.limit_class(), 20);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 5]; // 5 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    lits.set_limit_class(20);",
                  "    assert!(!lits.union(Literals::empty()));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 5]; // 5 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    lits.set_limit_class(20);",
                  "    assert!(lits.union(Literals { lits: vec![Literal::empty()], limit_size: 50, limit_class: 10 }));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 5]; // 5 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    lits.set_limit_class(20);",
                  "    assert!(lits.cross_product(&Literals { lits: vec![Literal::empty()], limit_size: 50, limit_class: 10 }));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 5]; // 5 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    lits.set_limit_class(20);",
                  "    assert!(!lits.cross_product(&Literals { lits: vec![], limit_size: 50, limit_class: 10 }));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 5]; // 5 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    lits.set_limit_class(20);",
                  "    assert!(lits.any_complete());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 5]; // 5 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    lits.set_limit_class(20);",
                  "    assert!(lits.all_complete());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 5]; // 5 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    lits.set_limit_class(20);",
                  "    assert!(!lits.contains_empty());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 5]; // 5 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    lits.set_limit_class(20);",
                  "    lits.lits.push(Literal::empty());",
                  "    assert!(lits.contains_empty());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 5]; // 5 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    lits.set_limit_class(20);",
                  "    lits.lits.push(Literal::empty());",
                  "    assert!(lits.literals().len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 5]; // 5 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    lits.set_limit_class(20);",
                  "    lits.lits.push(Literal::empty());",
                  "    assert!(!lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 5]; // 5 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 5];",
                  "    lits.set_limit_size(100);",
                  "    lits.set_limit_class(20);",
                  "    lits.lits.push(Literal::empty());",
                  "    lits.clear();",
                  "    assert!(lits.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1598:20\n     |\n1598 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:25\n     |\n1606 |         lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1605:24\n     |\n1605 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1609:16\n     |\n1609 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1598:20\n     |\n1598 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:25\n     |\n1606 |         lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1605:24\n     |\n1605 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1609:16\n     |\n1609 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1598:20\n     |\n1598 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:25\n     |\n1606 |         lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1605:24\n     |\n1605 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1609:16\n     |\n1609 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1598:20\n     |\n1598 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:25\n     |\n1606 |         lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1605:24\n     |\n1605 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1609:16\n     |\n1609 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1598:20\n     |\n1598 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:25\n     |\n1606 |         lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1605:24\n     |\n1605 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1609:16\n     |\n1609 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1598:20\n     |\n1598 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:25\n     |\n1606 |         lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1605:24\n     |\n1605 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1609:16\n     |\n1609 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1598:20\n     |\n1598 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:25\n     |\n1606 |         lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1605:24\n     |\n1605 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1609:16\n     |\n1609 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1616:46\n     |\n1616 |     assert!(lits.union(Literals { lits: vec![Literal::empty()], limit_size: 50, limit_class: 10 }));\n     |                                              ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1598:20\n     |\n1598 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:25\n     |\n1606 |         lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1605:24\n     |\n1605 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1609:16\n     |\n1609 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1616:55\n     |\n1616 |     assert!(lits.cross_product(&Literals { lits: vec![Literal::empty()], limit_size: 50, limit_class: 10 }));\n     |                                                       ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1598:20\n     |\n1598 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:25\n     |\n1606 |         lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1605:24\n     |\n1605 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1609:16\n     |\n1609 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1598:20\n     |\n1598 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:25\n     |\n1606 |         lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1605:24\n     |\n1605 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1609:16\n     |\n1609 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1598:20\n     |\n1598 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:25\n     |\n1606 |         lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1605:24\n     |\n1605 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1609:16\n     |\n1609 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1598:20\n     |\n1598 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:25\n     |\n1606 |         lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1605:24\n     |\n1605 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1609:16\n     |\n1609 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1598:20\n     |\n1598 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:25\n     |\n1606 |         lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1605:24\n     |\n1605 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1609:16\n     |\n1609 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1616:20\n     |\n1616 |     lits.lits.push(Literal::empty());\n     |               ---- ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |               |\n     |               arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1598:20\n     |\n1598 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:25\n     |\n1606 |         lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1605:24\n     |\n1605 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1609:16\n     |\n1609 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1616:20\n     |\n1616 |     lits.lits.push(Literal::empty());\n     |               ---- ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |               |\n     |               arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1598:20\n     |\n1598 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:25\n     |\n1606 |         lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1605:24\n     |\n1605 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1609:16\n     |\n1609 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1616:20\n     |\n1616 |     lits.lits.push(Literal::empty());\n     |               ---- ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |               |\n     |               arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1598:20\n     |\n1598 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:25\n     |\n1606 |         lits3.lits.push(Literal { cut: false, content: vec![1, 2, 3] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1605:24\n     |\n1605 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1609:16\n     |\n1609 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1616:20\n     |\n1616 |     lits.lits.push(Literal::empty());\n     |               ---- ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |               |\n     |               arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut lits = Literals {",
                "        lits: vec![Literal::empty()],",
                "        limit_size: 50,",
                "        limit_class: 10,",
                "    };",
                "",
                "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                "",
                "    alternate_literals(&es, &mut lits, |_, lits3| {",
                "        lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                "    });",
                "}"
              ],
              "oracles": [
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    assert!(result);"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let empty_lits = lits.to_empty();",
                  "    assert!(empty_lits.is_empty());"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let empty_lits = lits.to_empty();",
                  "    let limit_size = lits.limit_size();",
                  "    assert_eq!(limit_size, 50);"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let empty_lits = lits.to_empty();",
                  "    let limit_size = lits.limit_size();",
                  "    let new_size_lits = lits.set_limit_size(30);",
                  "    assert_eq!(new_size_lits.limit_size(), 30);"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let empty_lits = lits.to_empty();",
                  "    let limit_size = lits.limit_size();",
                  "    let new_size_lits = lits.set_limit_size(30);",
                  "    let union_result = lits.union(Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    assert!(union_result);"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let empty_lits = lits.to_empty();",
                  "    let limit_size = lits.limit_size();",
                  "    let new_size_lits = lits.set_limit_size(30);",
                  "    let union_result = lits.union(Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    assert!(!lits.is_empty());"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let empty_lits = lits.to_empty();",
                  "    let limit_size = lits.limit_size();",
                  "    let new_size_lits = lits.set_limit_size(30);",
                  "    let union_result = lits.union(Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    let cross_product_result = lits.cross_product(&Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![7, 8] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    assert!(cross_product_result);"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let empty_lits = lits.to_empty();",
                  "    let limit_size = lits.limit_size();",
                  "    let new_size_lits = lits.set_limit_size(30);",
                  "    let union_result = lits.union(Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    let cross_product_result = lits.cross_product(&Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![7, 8] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    lits.cut();",
                  "    assert!(lits.all_complete());"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let empty_lits = lits.to_empty();",
                  "    let limit_size = lits.limit_size();",
                  "    let new_size_lits = lits.set_limit_size(30);",
                  "    let union_result = lits.union(Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    let cross_product_result = lits.cross_product(&Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![7, 8] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    lits.cut();",
                  "    lits.clear();",
                  "    assert!(lits.is_empty());"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let empty_lits = lits.to_empty();",
                  "    let limit_size = lits.limit_size();",
                  "    let new_size_lits = lits.set_limit_size(30);",
                  "    let union_result = lits.union(Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    let cross_product_result = lits.cross_product(&Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![7, 8] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    lits.cut();",
                  "    lits.clear();",
                  "    let min_length = lits.min_len();",
                  "    assert!(min_length.is_none());"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let empty_lits = lits.to_empty();",
                  "    let limit_size = lits.limit_size();",
                  "    let new_size_lits = lits.set_limit_size(30);",
                  "    let union_result = lits.union(Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    let cross_product_result = lits.cross_product(&Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![7, 8] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    lits.cut();",
                  "    lits.clear();",
                  "    let min_length = lits.min_len();",
                  "    let contains_empty = lits.contains_empty();",
                  "    assert!(!contains_empty);"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let empty_lits = lits.to_empty();",
                  "    let limit_size = lits.limit_size();",
                  "    let new_size_lits = lits.set_limit_size(30);",
                  "    let union_result = lits.union(Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    let cross_product_result = lits.cross_product(&Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![7, 8] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    lits.cut();",
                  "    lits.clear();",
                  "    let min_length = lits.min_len();",
                  "    let contains_empty = lits.contains_empty();",
                  "    let any_complete_check = lits.any_complete();",
                  "    assert!(!any_complete_check);"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let empty_lits = lits.to_empty();",
                  "    let limit_size = lits.limit_size();",
                  "    let new_size_lits = lits.set_limit_size(30);",
                  "    let union_result = lits.union(Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    let cross_product_result = lits.cross_product(&Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![7, 8] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    lits.cut();",
                  "    lits.clear();",
                  "    let min_length = lits.min_len();",
                  "    let contains_empty = lits.contains_empty();",
                  "    let any_complete_check = lits.any_complete();",
                  "    let limit_class = lits.limit_class();",
                  "    assert_eq!(limit_class, 10);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    assert!(result);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let empty_lits = lits.to_empty();",
                  "    assert!(empty_lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let empty_lits = lits.to_empty();",
                  "    let limit_size = lits.limit_size();",
                  "    assert_eq!(limit_size, 50);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let empty_lits = lits.to_empty();",
                  "    let limit_size = lits.limit_size();",
                  "    let new_size_lits = lits.set_limit_size(30);",
                  "    assert_eq!(new_size_lits.limit_size(), 30);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let empty_lits = lits.to_empty();",
                  "    let limit_size = lits.limit_size();",
                  "    let new_size_lits = lits.set_limit_size(30);",
                  "    let union_result = lits.union(Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    assert!(union_result);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let empty_lits = lits.to_empty();",
                  "    let limit_size = lits.limit_size();",
                  "    let new_size_lits = lits.set_limit_size(30);",
                  "    let union_result = lits.union(Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    assert!(!lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let empty_lits = lits.to_empty();",
                  "    let limit_size = lits.limit_size();",
                  "    let new_size_lits = lits.set_limit_size(30);",
                  "    let union_result = lits.union(Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    let cross_product_result = lits.cross_product(&Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![7, 8] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    assert!(cross_product_result);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let empty_lits = lits.to_empty();",
                  "    let limit_size = lits.limit_size();",
                  "    let new_size_lits = lits.set_limit_size(30);",
                  "    let union_result = lits.union(Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    let cross_product_result = lits.cross_product(&Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![7, 8] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    lits.cut();",
                  "    assert!(lits.all_complete());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let empty_lits = lits.to_empty();",
                  "    let limit_size = lits.limit_size();",
                  "    let new_size_lits = lits.set_limit_size(30);",
                  "    let union_result = lits.union(Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    let cross_product_result = lits.cross_product(&Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![7, 8] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    lits.cut();",
                  "    lits.clear();",
                  "    assert!(lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let empty_lits = lits.to_empty();",
                  "    let limit_size = lits.limit_size();",
                  "    let new_size_lits = lits.set_limit_size(30);",
                  "    let union_result = lits.union(Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    let cross_product_result = lits.cross_product(&Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![7, 8] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    lits.cut();",
                  "    lits.clear();",
                  "    let min_length = lits.min_len();",
                  "    assert!(min_length.is_none());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let empty_lits = lits.to_empty();",
                  "    let limit_size = lits.limit_size();",
                  "    let new_size_lits = lits.set_limit_size(30);",
                  "    let union_result = lits.union(Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    let cross_product_result = lits.cross_product(&Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![7, 8] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    lits.cut();",
                  "    lits.clear();",
                  "    let min_length = lits.min_len();",
                  "    let contains_empty = lits.contains_empty();",
                  "    assert!(!contains_empty);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let empty_lits = lits.to_empty();",
                  "    let limit_size = lits.limit_size();",
                  "    let new_size_lits = lits.set_limit_size(30);",
                  "    let union_result = lits.union(Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    let cross_product_result = lits.cross_product(&Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![7, 8] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    lits.cut();",
                  "    lits.clear();",
                  "    let min_length = lits.min_len();",
                  "    let contains_empty = lits.contains_empty();",
                  "    let any_complete_check = lits.any_complete();",
                  "    assert!(!any_complete_check);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 3]; // 3 Hir instances",
                  "    let result = alternate_literals(&es, &mut lits, |_, lits3| {",
                  "    lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });",
                  "    });",
                  "    let empty_lits = lits.to_empty();",
                  "    let limit_size = lits.limit_size();",
                  "    let new_size_lits = lits.set_limit_size(30);",
                  "    let union_result = lits.union(Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    let cross_product_result = lits.cross_product(&Literals {",
                  "    lits: vec![Literal { cut: false, content: vec![7, 8] }],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    });",
                  "    lits.cut();",
                  "    lits.clear();",
                  "    let min_length = lits.min_len();",
                  "    let contains_empty = lits.contains_empty();",
                  "    let any_complete_check = lits.any_complete();",
                  "    let limit_class = lits.limit_class();",
                  "    assert_eq!(limit_class, 10);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1598:20\n     |\n1598 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:25\n     |\n1606 |         lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1605:24\n     |\n1605 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1609:16\n     |\n1609 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1615:21\n     |\n1615 |     lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                |\n     |                arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1614:37\n     |\n1614 |     let result = alternate_literals(&es, &mut lits, |_, lits3| {\n     |                  ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |                  |\n     |                  arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0600]: cannot apply unary operator `!` to type `()`\n    --> regex-syntax/src/hir/literal/mod.rs:1617:5\n     |\n1617 |     assert!(result);\n     |     ^^^^^^^^^^^^^^^ cannot apply unary operator `!`\n     |\n     = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0600.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1598:20\n     |\n1598 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:25\n     |\n1606 |         lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1605:24\n     |\n1605 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1609:16\n     |\n1609 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1615:21\n     |\n1615 |     lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                |\n     |                arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1614:37\n     |\n1614 |     let result = alternate_literals(&es, &mut lits, |_, lits3| {\n     |                  ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |                  |\n     |                  arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1598:20\n     |\n1598 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:25\n     |\n1606 |         lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1605:24\n     |\n1605 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1609:16\n     |\n1609 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1615:21\n     |\n1615 |     lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                |\n     |                arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1614:37\n     |\n1614 |     let result = alternate_literals(&es, &mut lits, |_, lits3| {\n     |                  ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |                  |\n     |                  arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1598:20\n     |\n1598 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:25\n     |\n1606 |         lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1605:24\n     |\n1605 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1609:16\n     |\n1609 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1615:21\n     |\n1615 |     lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                |\n     |                arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1614:37\n     |\n1614 |     let result = alternate_literals(&es, &mut lits, |_, lits3| {\n     |                  ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |                  |\n     |                  arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1598:20\n     |\n1598 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:25\n     |\n1606 |         lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1605:24\n     |\n1605 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1609:16\n     |\n1609 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1615:21\n     |\n1615 |     lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                |\n     |                arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1614:37\n     |\n1614 |     let result = alternate_literals(&es, &mut lits, |_, lits3| {\n     |                  ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |                  |\n     |                  arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1621:16\n     |\n1621 |     lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1598:20\n     |\n1598 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:25\n     |\n1606 |         lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1605:24\n     |\n1605 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1609:16\n     |\n1609 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1615:21\n     |\n1615 |     lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                |\n     |                arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1614:37\n     |\n1614 |     let result = alternate_literals(&es, &mut lits, |_, lits3| {\n     |                  ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |                  |\n     |                  arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1621:16\n     |\n1621 |     lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1598:20\n     |\n1598 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:25\n     |\n1606 |         lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1605:24\n     |\n1605 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1609:16\n     |\n1609 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1615:21\n     |\n1615 |     lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                |\n     |                arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1614:37\n     |\n1614 |     let result = alternate_literals(&es, &mut lits, |_, lits3| {\n     |                  ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |                  |\n     |                  arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1621:16\n     |\n1621 |     lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1626:16\n     |\n1626 |     lits: vec![Literal { cut: false, content: vec![7, 8] }],\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/abezbm/rust-utgen-test-crates-new/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/abezbm/rust-utgen-test-crates-new/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/abezbm/rust-utgen-test-crates-new/regex/regex-syntax)\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1598:20\n     |\n1598 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:25\n     |\n1606 |         lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1605:24\n     |\n1605 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1609:16\n     |\n1609 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1615:21\n     |\n1615 |     lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |                |\n     |                arguments to this method are incorrect\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /home/abezbm/.rustup/toolchains/nightly-2024-07-21-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:1997:12\n     |\n1997 |     pub fn push(&mut self, value: T) {\n     |            ^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1614:37\n     |\n1614 |     let result = alternate_literals(&es, &mut lits, |_, lits3| {\n     |                  ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |                  |\n     |                  arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<ntest_callback::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1621:16\n     |\n1621 |     lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1626:16\n     |\n1626 |     lits: vec![Literal { cut: false, content: vec![7, 8] }],\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `ntest_callback::Literal`\n     |\n     = note: `ntest_callback::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `ntest_callback::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1564:1\n     |\n1564 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nFor more information about this error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:16\n     |\n1606 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1612:21\n     |\n1612 |     lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                |\n     |                arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1611:37\n     |\n1611 |     let result = alternate_literals(&es, &mut lits, |_, lits3| {\n     |                  ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |                  |\n     |                  arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1618:16\n     |\n1618 |     lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1623:16\n     |\n1623 |     lits: vec![Literal { cut: false, content: vec![7, 8] }],\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:16\n     |\n1606 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1612:21\n     |\n1612 |     lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                |\n     |                arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1611:37\n     |\n1611 |     let result = alternate_literals(&es, &mut lits, |_, lits3| {\n     |                  ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |                  |\n     |                  arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1618:16\n     |\n1618 |     lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1623:16\n     |\n1623 |     lits: vec![Literal { cut: false, content: vec![7, 8] }],\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:16\n     |\n1606 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1612:21\n     |\n1612 |     lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                |\n     |                arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1611:37\n     |\n1611 |     let result = alternate_literals(&es, &mut lits, |_, lits3| {\n     |                  ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |                  |\n     |                  arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1618:16\n     |\n1618 |     lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1623:16\n     |\n1623 |     lits: vec![Literal { cut: false, content: vec![7, 8] }],\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:16\n     |\n1606 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1612:21\n     |\n1612 |     lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                |\n     |                arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1611:37\n     |\n1611 |     let result = alternate_literals(&es, &mut lits, |_, lits3| {\n     |                  ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |                  |\n     |                  arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1618:16\n     |\n1618 |     lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1623:16\n     |\n1623 |     lits: vec![Literal { cut: false, content: vec![7, 8] }],\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:16\n     |\n1606 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1612:21\n     |\n1612 |     lits3.lits.push(Literal { cut: false, content: vec![4, 5, 6] });\n     |                ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                |\n     |                arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1611:37\n     |\n1611 |     let result = alternate_literals(&es, &mut lits, |_, lits3| {\n     |                  ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |                  |\n     |                  arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1618:16\n     |\n1618 |     lits: vec![Literal { cut: false, content: vec![1, 2, 3] }],\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1623:16\n     |\n1623 |     lits: vec![Literal { cut: false, content: vec![7, 8] }],\n     |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                true,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut lits = Literals {",
                "        lits: vec![Literal::empty()],",
                "        limit_size: 50,",
                "        limit_class: 10,",
                "    };",
                "",
                "    let es = vec![Hir {}; 7]; // 7 Hir instances",
                "",
                "    alternate_literals(&es, &mut lits, |_, lits3| {",
                "        lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });",
                "    });",
                "}"
              ],
              "oracles": [
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert_eq!(lits.limit_size(), 50);"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert_eq!(lits.limit_class, 10);"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert!(lits.is_empty());"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert!(!lits.lits[0].is_cut());"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert!(lits.lits[0].is_empty());"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 7];",
                  "    assert_eq!(es.len(), 7);"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 7];",
                  "    assert!(alternate_literals(&es, &mut lits, |_, lits3| { lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] }); true }));"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 7];",
                  "    assert!(!lits.is_empty());"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 7];",
                  "    assert_eq!(lits.lits.len(), 1);"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 7];",
                  "    assert_eq!(lits.lits[0].len(), 0);"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 7];",
                  "    lits.cross_product(&lits);",
                  "    assert!(lits.lits[0].is_cut());"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 7];",
                  "    lits.cross_product(&lits);",
                  "    lits.union(Literals { lits: vec![Literal { cut: true, content: vec![1, 2, 3] }], limit_size: 50, limit_class: 10 });",
                  "    assert_eq!(lits.lits.len(), 2);"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 7];",
                  "    lits.cross_product(&lits);",
                  "    lits.union(Literals { lits: vec![Literal { cut: true, content: vec![1, 2, 3] }], limit_size: 50, limit_class: 10 });",
                  "    lits.cut();",
                  "    assert!(lits.lits[0].is_cut());"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 7];",
                  "    lits.cross_product(&lits);",
                  "    lits.union(Literals { lits: vec![Literal { cut: true, content: vec![1, 2, 3] }], limit_size: 50, limit_class: 10 });",
                  "    lits.cut();",
                  "    assert!(lits.lits[1].is_cut());"
                ],
                [
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 7];",
                  "    lits.cross_product(&lits);",
                  "    lits.union(Literals { lits: vec![Literal { cut: true, content: vec![1, 2, 3] }], limit_size: 50, limit_class: 10 });",
                  "    lits.cut();",
                  "    assert!(lits.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 7]; // 7 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert_eq!(lits.limit_size(), 50);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 7]; // 7 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert_eq!(lits.limit_class, 10);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 7]; // 7 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert!(lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 7]; // 7 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert!(!lits.lits[0].is_cut());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 7]; // 7 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert!(lits.lits[0].is_empty());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 7]; // 7 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 7];",
                  "    assert_eq!(es.len(), 7);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 7]; // 7 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 7];",
                  "    assert!(alternate_literals(&es, &mut lits, |_, lits3| { lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] }); true }));",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 7]; // 7 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 7];",
                  "    assert!(!lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 7]; // 7 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 7];",
                  "    assert_eq!(lits.lits.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 7]; // 7 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 7];",
                  "    assert_eq!(lits.lits[0].len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 7]; // 7 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 7];",
                  "    lits.cross_product(&lits);",
                  "    assert!(lits.lits[0].is_cut());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 7]; // 7 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 7];",
                  "    lits.cross_product(&lits);",
                  "    lits.union(Literals { lits: vec![Literal { cut: true, content: vec![1, 2, 3] }], limit_size: 50, limit_class: 10 });",
                  "    assert_eq!(lits.lits.len(), 2);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 7]; // 7 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 7];",
                  "    lits.cross_product(&lits);",
                  "    lits.union(Literals { lits: vec![Literal { cut: true, content: vec![1, 2, 3] }], limit_size: 50, limit_class: 10 });",
                  "    lits.cut();",
                  "    assert!(lits.lits[0].is_cut());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 7]; // 7 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 7];",
                  "    lits.cross_product(&lits);",
                  "    lits.union(Literals { lits: vec![Literal { cut: true, content: vec![1, 2, 3] }], limit_size: 50, limit_class: 10 });",
                  "    lits.cut();",
                  "    assert!(lits.lits[1].is_cut());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 7]; // 7 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });",
                  "    });",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::empty()],",
                  "    limit_size: 50,",
                  "    limit_class: 10,",
                  "    };",
                  "    let es = vec![Hir {}; 7];",
                  "    lits.cross_product(&lits);",
                  "    lits.union(Literals { lits: vec![Literal { cut: true, content: vec![1, 2, 3] }], limit_size: 50, limit_class: 10 });",
                  "    lits.cut();",
                  "    assert!(lits.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:16\n     |\n1606 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:16\n     |\n1606 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:16\n     |\n1606 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:16\n     |\n1606 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:16\n     |\n1606 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:16\n     |\n1606 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:16\n     |\n1606 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1611:77\n     |\n1611 |     assert!(alternate_literals(&es, &mut lits, |_, lits3| { lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] }); true }));\n     |                                                                        ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                                                                        |\n     |                                                                        arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1611:126\n     |\n1611 |     assert!(alternate_literals(&es, &mut lits, |_, lits3| { lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] }); true }));\n     |                                                          - help: try adding a return type: `-> bool`                         ^^^^ expected `()`, found `bool`\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1611:32\n     |\n1611 |     assert!(alternate_literals(&es, &mut lits, |_, lits3| { lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] }); true }));\n     |             ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |             |\n     |             arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0600]: cannot apply unary operator `!` to type `()`\n    --> regex-syntax/src/hir/literal/mod.rs:1611:5\n     |\n1611 |     assert!(alternate_literals(&es, &mut lits, |_, lits3| { lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] }); true }));\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot apply unary operator `!`\n     |\n     = note: this error originates in the macro `assert` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0600.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:16\n     |\n1606 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:16\n     |\n1606 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:16\n     |\n1606 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:16\n     |\n1606 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:16\n     |\n1606 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1612:38\n     |\n1612 |     lits.union(Literals { lits: vec![Literal { cut: true, content: vec![1, 2, 3] }], limit_size: 50, limit_class: 10 });\n     |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:16\n     |\n1606 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1612:38\n     |\n1612 |     lits.union(Literals { lits: vec![Literal { cut: true, content: vec![1, 2, 3] }], limit_size: 50, limit_class: 10 });\n     |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:16\n     |\n1606 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1612:38\n     |\n1612 |     lits.union(Literals { lits: vec![Literal { cut: true, content: vec![1, 2, 3] }], limit_size: 50, limit_class: 10 });\n     |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![7, 8, 9] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1606:16\n     |\n1606 |     lits: vec![Literal::empty()],\n     |                ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1612:38\n     |\n1612 |     lits.union(Literals { lits: vec![Literal { cut: true, content: vec![1, 2, 3] }], limit_size: 50, limit_class: 10 });\n     |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let mut lits = Literals {",
                "        lits: vec![Literal::empty()],",
                "        limit_size: 50,",
                "        limit_class: 10,",
                "    };",
                "",
                "    let es = vec![Hir {}; 9]; // 9 Hir instances",
                "",
                "    alternate_literals(&es, &mut lits, |_, lits3| {",
                "        lits3.lits.push(Literal { cut: false, content: vec![10, 11] });",
                "    });",
                "}"
              ],
              "oracles": [
                [
                  "    lits.cut();",
                  "    assert!(lits.is_empty());"
                ],
                [
                  "    lits.cut();",
                  "    assert_eq!(lits.limit_size(), 50);"
                ],
                [
                  "    lits.cut();",
                  "    assert_eq!(lits.limit_class(), 10);"
                ],
                [
                  "    lits.cut();",
                  "    assert_eq!(lits.literals().len(), 0);"
                ],
                [
                  "    lits.cut();",
                  "    assert!(lits.any_complete());"
                ],
                [
                  "    lits.cut();",
                  "    assert!(!lits.all_complete());"
                ],
                [
                  "    lits.cut();",
                  "    assert!(!lits.contains_empty());"
                ],
                [
                  "    lits.cut();",
                  "    assert_eq!(lits.min_len(), None);"
                ],
                [
                  "    lits.cut();",
                  "    assert!(lits.to_empty().is_empty());"
                ],
                [
                  "    lits.cut();",
                  "    assert_eq!(lits.longest_common_prefix().len(), 0);"
                ],
                [
                  "    lits.cut();",
                  "    assert_eq!(lits.longest_common_suffix().len(), 0);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 9]; // 9 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![10, 11] });",
                  "    });",
                  "    lits.cut();",
                  "    assert!(lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 9]; // 9 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![10, 11] });",
                  "    });",
                  "    lits.cut();",
                  "    assert_eq!(lits.limit_size(), 50);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 9]; // 9 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![10, 11] });",
                  "    });",
                  "    lits.cut();",
                  "    assert_eq!(lits.limit_class(), 10);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 9]; // 9 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![10, 11] });",
                  "    });",
                  "    lits.cut();",
                  "    assert_eq!(lits.literals().len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 9]; // 9 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![10, 11] });",
                  "    });",
                  "    lits.cut();",
                  "    assert!(lits.any_complete());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 9]; // 9 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![10, 11] });",
                  "    });",
                  "    lits.cut();",
                  "    assert!(!lits.all_complete());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 9]; // 9 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![10, 11] });",
                  "    });",
                  "    lits.cut();",
                  "    assert!(!lits.contains_empty());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 9]; // 9 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![10, 11] });",
                  "    });",
                  "    lits.cut();",
                  "    assert_eq!(lits.min_len(), None);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 9]; // 9 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![10, 11] });",
                  "    });",
                  "    lits.cut();",
                  "    assert!(lits.to_empty().is_empty());",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 9]; // 9 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![10, 11] });",
                  "    });",
                  "    lits.cut();",
                  "    assert_eq!(lits.longest_common_prefix().len(), 0);",
                  "}"
                ],
                [
                  "{",
                  "#[derive(Clone)]",
                  "struct Literal {",
                  "    cut: bool,",
                  "    content: Vec<u8>,",
                  "}",
                  "",
                  "impl Literal {",
                  "    fn empty() -> Literal {",
                  "        Literal { cut: false, content: vec![] }",
                  "    }",
                  "",
                  "    fn len(&self) -> usize {",
                  "        self.content.len()",
                  "    }",
                  "",
                  "    fn is_empty(&self) -> bool {",
                  "        self.content.is_empty()",
                  "    }",
                  "",
                  "    fn is_cut(&self) -> bool {",
                  "        self.cut",
                  "    }",
                  "",
                  "    fn extend(&mut self, other: &[u8]) {",
                  "        self.content.extend_from_slice(other);",
                  "    }",
                  "",
                  "    fn cut(&mut self) {",
                  "        self.cut = true;",
                  "    }",
                  "}",
                  "",
                  "#[derive(Clone)]",
                  "struct Hir {}",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::empty()],",
                  "        limit_size: 50,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    let es = vec![Hir {}; 9]; // 9 Hir instances",
                  "",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.lits.push(Literal { cut: false, content: vec![10, 11] });",
                  "    });",
                  "    lits.cut();",
                  "    assert_eq!(lits.longest_common_suffix().len(), 0);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![10, 11] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![10, 11] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![10, 11] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![10, 11] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![10, 11] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![10, 11] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![10, 11] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![10, 11] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![10, 11] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![10, 11] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1595:20\n     |\n1595 |         lits: vec![Literal::empty()],\n     |                    ^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1603:25\n     |\n1603 |         lits3.lits.push(Literal { cut: false, content: vec![10, 11] });\n     |                    ---- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `literal::Literal`, found `llmtests::Literal`\n     |                    |\n     |                    arguments to this method are incorrect\n     |\n     = note: `llmtests::Literal` and `literal::Literal` have similar names, but are actually distinct types\nnote: `llmtests::Literal` is defined in module `crate::hir::literal::llmtests` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:1557:1\n     |\n1557 | struct Literal {\n     | ^^^^^^^^^^^^^^\nnote: `literal::Literal` is defined in module `crate::hir::literal` of the current crate\n    --> regex-syntax/src/hir/literal/mod.rs:56:1\n     |\n56   | pub struct Literal {\n     | ^^^^^^^^^^^^^^^^^^\nnote: method defined here\n    --> /rustc/5069856495870486134dd2ca0b0e2516308c5c2a/library/alloc/src/vec/mod.rs:1997:12\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1602:24\n     |\n1602 |     alternate_literals(&es, &mut lits, |_, lits3| {\n     |     ------------------ ^^^ expected `&[Hir]`, found `&Vec<Hir>`\n     |     |\n     |     arguments to this function are incorrect\n     |\n     = note: expected reference `&[hir::Hir]`\n                found reference `&Vec<llmtests::Hir>`\nnote: function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:845:4\n     |\n845  | fn alternate_literals<F: FnMut(&Hir, &mut Literals)>(\n     |    ^^^^^^^^^^^^^^^^^^\n846  |     es: &[Hir],\n     |     ----------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 4 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 4,
      "prompt_conds": [
        "// constraint: e in es is true\n",
        "// constraint: lits3.is_empty() is false\n",
        "// constraint: lits2.union(lits3) is false\n"
      ],
      "input_infer": "es: [Hir] with length 1 to 5, lits: Literals with limit_size > 0, limit_class > 0, lits3: Literals with limit_size = 1 to (limit_size / 5 - 1), `lits2.union(lits3) return false` cases ensure presence of incompatible Literals in lits2 and lits3.\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let hir = Hir {",
                "        kind: HirKind::SomeKind, // Replace with an actual kind",
                "        info: HirInfo::new(), // Assuming you have a way to create this",
                "    };",
                "    let mut lits = Literals {",
                "        lits: vec![Literal::new(b\"a\")], // Assuming you have a way to create this",
                "        limit_size: 10,",
                "        limit_class: 10,",
                "    };",
                "    let es = vec![hir.clone()];",
                "    ",
                "    alternate_literals(&es, &mut lits, |_, lits3| {",
                "        lits3.set_limit_size(1);",
                "        // This ensures that lits3 is not empty.",
                "        lits3.union(Literals {",
                "            lits: vec![Literal::new(b\"b\")],",
                "            limit_size: 1,",
                "            limit_class: 1,",
                "        });",
                "    });",
                "}"
              ],
              "oracles": [
                [
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };",
                  "    let es = vec![hir.clone()];",
                  "    assert_eq!(lits.limit_size(), 10);"
                ],
                [
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };",
                  "    let es = vec![hir.clone()];",
                  "    assert_eq!(lits.limit_class, 10);"
                ],
                [
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };",
                  "    let es = vec![hir.clone()];",
                  "    assert!(!lits.is_empty());"
                ],
                [
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };",
                  "    let es = vec![hir.clone()];",
                  "    assert!(lits.literals().contains(&Literal::new(b\"a\")));"
                ],
                [
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };",
                  "    let es = vec![hir.clone()];",
                  "    assert_eq!(lits.lits.len(), 1);"
                ],
                [
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };",
                  "    let es = vec![hir.clone()];",
                  "    assert_eq!(lits.lits[0].len(), 1);"
                ],
                [
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };",
                  "    let es = vec![hir.clone()];",
                  "    assert!(lits.union(Literals { lits: vec![Literal::new(b\"b\")], limit_size: 1, limit_class: 1 }));"
                ],
                [
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };",
                  "    let es = vec![hir.clone()];",
                  "    let mut lits3 = lits.to_empty();",
                  "    lits3.set_limit_size(1);",
                  "    assert!(!lits3.is_empty());"
                ],
                [
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };",
                  "    let es = vec![hir.clone()];",
                  "    let mut lits3 = lits.to_empty();",
                  "    lits3.set_limit_size(1);",
                  "    assert_eq!(lits3.limit_size(), 1);"
                ],
                [
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };",
                  "    let es = vec![hir.clone()];",
                  "    let mut lits3 = lits.to_empty();",
                  "    lits3.set_limit_size(1);",
                  "    assert!(lits3.union(Literals { lits: vec![Literal::new(b\"b\")], limit_size: 1, limit_class: 1 }));"
                ],
                [
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };",
                  "    let es = vec![hir.clone()];",
                  "    let mut lits3 = lits.to_empty();",
                  "    lits3.set_limit_size(1);",
                  "    assert!(lits.cross_product(&lits3));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let hir = Hir {",
                  "        kind: HirKind::SomeKind, // Replace with an actual kind",
                  "        info: HirInfo::new(), // Assuming you have a way to create this",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"a\")], // Assuming you have a way to create this",
                  "        limit_size: 10,",
                  "        limit_class: 10,",
                  "    };",
                  "    let es = vec![hir.clone()];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(1);",
                  "        // This ensures that lits3 is not empty.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"b\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "    });",
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };",
                  "    let es = vec![hir.clone()];",
                  "    assert_eq!(lits.limit_size(), 10);",
                  "}"
                ],
                [
                  "{",
                  "    let hir = Hir {",
                  "        kind: HirKind::SomeKind, // Replace with an actual kind",
                  "        info: HirInfo::new(), // Assuming you have a way to create this",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"a\")], // Assuming you have a way to create this",
                  "        limit_size: 10,",
                  "        limit_class: 10,",
                  "    };",
                  "    let es = vec![hir.clone()];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(1);",
                  "        // This ensures that lits3 is not empty.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"b\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "    });",
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };",
                  "    let es = vec![hir.clone()];",
                  "    assert_eq!(lits.limit_class, 10);",
                  "}"
                ],
                [
                  "{",
                  "    let hir = Hir {",
                  "        kind: HirKind::SomeKind, // Replace with an actual kind",
                  "        info: HirInfo::new(), // Assuming you have a way to create this",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"a\")], // Assuming you have a way to create this",
                  "        limit_size: 10,",
                  "        limit_class: 10,",
                  "    };",
                  "    let es = vec![hir.clone()];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(1);",
                  "        // This ensures that lits3 is not empty.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"b\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "    });",
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };",
                  "    let es = vec![hir.clone()];",
                  "    assert!(!lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let hir = Hir {",
                  "        kind: HirKind::SomeKind, // Replace with an actual kind",
                  "        info: HirInfo::new(), // Assuming you have a way to create this",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"a\")], // Assuming you have a way to create this",
                  "        limit_size: 10,",
                  "        limit_class: 10,",
                  "    };",
                  "    let es = vec![hir.clone()];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(1);",
                  "        // This ensures that lits3 is not empty.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"b\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "    });",
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };",
                  "    let es = vec![hir.clone()];",
                  "    assert!(lits.literals().contains(&Literal::new(b\"a\")));",
                  "}"
                ],
                [
                  "{",
                  "    let hir = Hir {",
                  "        kind: HirKind::SomeKind, // Replace with an actual kind",
                  "        info: HirInfo::new(), // Assuming you have a way to create this",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"a\")], // Assuming you have a way to create this",
                  "        limit_size: 10,",
                  "        limit_class: 10,",
                  "    };",
                  "    let es = vec![hir.clone()];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(1);",
                  "        // This ensures that lits3 is not empty.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"b\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "    });",
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };",
                  "    let es = vec![hir.clone()];",
                  "    assert_eq!(lits.lits.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let hir = Hir {",
                  "        kind: HirKind::SomeKind, // Replace with an actual kind",
                  "        info: HirInfo::new(), // Assuming you have a way to create this",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"a\")], // Assuming you have a way to create this",
                  "        limit_size: 10,",
                  "        limit_class: 10,",
                  "    };",
                  "    let es = vec![hir.clone()];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(1);",
                  "        // This ensures that lits3 is not empty.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"b\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "    });",
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };",
                  "    let es = vec![hir.clone()];",
                  "    assert_eq!(lits.lits[0].len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let hir = Hir {",
                  "        kind: HirKind::SomeKind, // Replace with an actual kind",
                  "        info: HirInfo::new(), // Assuming you have a way to create this",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"a\")], // Assuming you have a way to create this",
                  "        limit_size: 10,",
                  "        limit_class: 10,",
                  "    };",
                  "    let es = vec![hir.clone()];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(1);",
                  "        // This ensures that lits3 is not empty.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"b\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "    });",
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };",
                  "    let es = vec![hir.clone()];",
                  "    assert!(lits.union(Literals { lits: vec![Literal::new(b\"b\")], limit_size: 1, limit_class: 1 }));",
                  "}"
                ],
                [
                  "{",
                  "    let hir = Hir {",
                  "        kind: HirKind::SomeKind, // Replace with an actual kind",
                  "        info: HirInfo::new(), // Assuming you have a way to create this",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"a\")], // Assuming you have a way to create this",
                  "        limit_size: 10,",
                  "        limit_class: 10,",
                  "    };",
                  "    let es = vec![hir.clone()];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(1);",
                  "        // This ensures that lits3 is not empty.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"b\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "    });",
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };",
                  "    let es = vec![hir.clone()];",
                  "    let mut lits3 = lits.to_empty();",
                  "    lits3.set_limit_size(1);",
                  "    assert!(!lits3.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let hir = Hir {",
                  "        kind: HirKind::SomeKind, // Replace with an actual kind",
                  "        info: HirInfo::new(), // Assuming you have a way to create this",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"a\")], // Assuming you have a way to create this",
                  "        limit_size: 10,",
                  "        limit_class: 10,",
                  "    };",
                  "    let es = vec![hir.clone()];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(1);",
                  "        // This ensures that lits3 is not empty.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"b\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "    });",
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };",
                  "    let es = vec![hir.clone()];",
                  "    let mut lits3 = lits.to_empty();",
                  "    lits3.set_limit_size(1);",
                  "    assert_eq!(lits3.limit_size(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let hir = Hir {",
                  "        kind: HirKind::SomeKind, // Replace with an actual kind",
                  "        info: HirInfo::new(), // Assuming you have a way to create this",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"a\")], // Assuming you have a way to create this",
                  "        limit_size: 10,",
                  "        limit_class: 10,",
                  "    };",
                  "    let es = vec![hir.clone()];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(1);",
                  "        // This ensures that lits3 is not empty.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"b\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "    });",
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };",
                  "    let es = vec![hir.clone()];",
                  "    let mut lits3 = lits.to_empty();",
                  "    lits3.set_limit_size(1);",
                  "    assert!(lits3.union(Literals { lits: vec![Literal::new(b\"b\")], limit_size: 1, limit_class: 1 }));",
                  "}"
                ],
                [
                  "{",
                  "    let hir = Hir {",
                  "        kind: HirKind::SomeKind, // Replace with an actual kind",
                  "        info: HirInfo::new(), // Assuming you have a way to create this",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"a\")], // Assuming you have a way to create this",
                  "        limit_size: 10,",
                  "        limit_class: 10,",
                  "    };",
                  "    let es = vec![hir.clone()];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(1);",
                  "        // This ensures that lits3 is not empty.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"b\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "    });",
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };",
                  "    let es = vec![hir.clone()];",
                  "    let mut lits3 = lits.to_empty();",
                  "    lits3.set_limit_size(1);",
                  "    assert!(lits.cross_product(&lits3));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(), // Assuming you have a way to create this\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind, // Replace with an actual kind\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n1564 |         lits: vec![Literal::new(b\"a\")], // Assuming you have a way to create this\n     |                    ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |             lits: vec![Literal::new(b\"b\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:36\n     |\n1579 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                    ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1580:55\n     |\n1580 |     let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };\n     |                                          ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(), // Assuming you have a way to create this\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind, // Replace with an actual kind\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n1564 |         lits: vec![Literal::new(b\"a\")], // Assuming you have a way to create this\n     |                    ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |             lits: vec![Literal::new(b\"b\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:36\n     |\n1579 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                    ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1580:55\n     |\n1580 |     let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };\n     |                                          ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(), // Assuming you have a way to create this\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind, // Replace with an actual kind\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n1564 |         lits: vec![Literal::new(b\"a\")], // Assuming you have a way to create this\n     |                    ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |             lits: vec![Literal::new(b\"b\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:36\n     |\n1579 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                    ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1580:55\n     |\n1580 |     let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };\n     |                                          ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(), // Assuming you have a way to create this\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind, // Replace with an actual kind\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n1564 |         lits: vec![Literal::new(b\"a\")], // Assuming you have a way to create this\n     |                    ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |             lits: vec![Literal::new(b\"b\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:36\n     |\n1579 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                    ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1580:55\n     |\n1580 |     let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };\n     |                                          ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1582:52\n     |\n1582 |     assert!(lits.literals().contains(&Literal::new(b\"a\")));\n     |                                       ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                       |            |\n     |                                       |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                       arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(), // Assuming you have a way to create this\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind, // Replace with an actual kind\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n1564 |         lits: vec![Literal::new(b\"a\")], // Assuming you have a way to create this\n     |                    ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |             lits: vec![Literal::new(b\"b\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:36\n     |\n1579 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                    ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1580:55\n     |\n1580 |     let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };\n     |                                          ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(), // Assuming you have a way to create this\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind, // Replace with an actual kind\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n1564 |         lits: vec![Literal::new(b\"a\")], // Assuming you have a way to create this\n     |                    ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |             lits: vec![Literal::new(b\"b\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:36\n     |\n1579 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                    ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1580:55\n     |\n1580 |     let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };\n     |                                          ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(), // Assuming you have a way to create this\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind, // Replace with an actual kind\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n1564 |         lits: vec![Literal::new(b\"a\")], // Assuming you have a way to create this\n     |                    ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |             lits: vec![Literal::new(b\"b\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:36\n     |\n1579 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                    ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1580:55\n     |\n1580 |     let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };\n     |                                          ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1582:59\n     |\n1582 |     assert!(lits.union(Literals { lits: vec![Literal::new(b\"b\")], limit_size: 1, limit_class: 1 }));\n     |                                              ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                              |            |\n     |                                              |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                              arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(), // Assuming you have a way to create this\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind, // Replace with an actual kind\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n1564 |         lits: vec![Literal::new(b\"a\")], // Assuming you have a way to create this\n     |                    ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |             lits: vec![Literal::new(b\"b\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:36\n     |\n1579 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                    ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1580:55\n     |\n1580 |     let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };\n     |                                          ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(), // Assuming you have a way to create this\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind, // Replace with an actual kind\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n1564 |         lits: vec![Literal::new(b\"a\")], // Assuming you have a way to create this\n     |                    ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |             lits: vec![Literal::new(b\"b\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:36\n     |\n1579 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                    ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1580:55\n     |\n1580 |     let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };\n     |                                          ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(), // Assuming you have a way to create this\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind, // Replace with an actual kind\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n1564 |         lits: vec![Literal::new(b\"a\")], // Assuming you have a way to create this\n     |                    ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |             lits: vec![Literal::new(b\"b\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:36\n     |\n1579 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                    ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1580:55\n     |\n1580 |     let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };\n     |                                          ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1584:60\n     |\n1584 |     assert!(lits3.union(Literals { lits: vec![Literal::new(b\"b\")], limit_size: 1, limit_class: 1 }));\n     |                                               ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                               |            |\n     |                                               |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                               arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 9 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(), // Assuming you have a way to create this\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1579:52\n     |\n1579 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind, // Replace with an actual kind\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n1564 |         lits: vec![Literal::new(b\"a\")], // Assuming you have a way to create this\n     |                    ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |             lits: vec![Literal::new(b\"b\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1579:36\n     |\n1579 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                    ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1580:55\n     |\n1580 |     let mut lits = Literals { lits: vec![Literal::new(b\"a\")], limit_size: 10, limit_class: 10 };\n     |                                          ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 8 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let hir = Hir {",
                "        kind: HirKind::SomeKind, // Replace with an actual kind",
                "        info: HirInfo::new(), // Assuming you have a way to create this",
                "    };",
                "    let mut lits = Literals {",
                "        lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")],",
                "        limit_size: 5,",
                "        limit_class: 5,",
                "    };",
                "    let es = vec![hir.clone(), hir];",
                "    ",
                "    alternate_literals(&es, &mut lits, |_, lits3| {",
                "        lits3.set_limit_size(1);",
                "        // Ensures non-empty lits3.",
                "        lits3.union(Literals {",
                "            lits: vec![Literal::new(b\"z\")],",
                "            limit_size: 1,",
                "            limit_class: 1,",
                "        });",
                "        // This should lead to a situation where lits2.union(lits3) returns false.",
                "        lits3.union(Literals {",
                "            lits: vec![Literal::new(b\"w\")],",
                "            limit_size: 1,",
                "            limit_class: 1,",
                "        });",
                "    });",
                "}"
              ],
              "oracles": [
                [
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };",
                  "    let es = vec![hir.clone(), hir];",
                  "    lits.cut();",
                  "    assert!(lits.is_empty());"
                ],
                [
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };",
                  "    let es = vec![hir.clone(), hir];",
                  "    lits.cut();",
                  "    assert!(lits.limit_size() == 5);"
                ],
                [
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };",
                  "    let es = vec![hir.clone(), hir];",
                  "    lits.cut();",
                  "    assert!(lits.limit_class() == 5);"
                ],
                [
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };",
                  "    let es = vec![hir.clone(), hir];",
                  "    lits.cut();",
                  "    assert!(lits.literals().len() == 2);"
                ],
                [
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };",
                  "    let es = vec![hir.clone(), hir];",
                  "    lits.cut();",
                  "    assert!(lits.union(Literals { lits: vec![Literal::new(b\"z\")], limit_size: 1, limit_class: 1 }));"
                ],
                [
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };",
                  "    let es = vec![hir.clone(), hir];",
                  "    lits.cut();",
                  "    assert!(!lits.union(Literals { lits: vec![Literal::new(b\"w\")], limit_size: 1, limit_class: 1 }));"
                ],
                [
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };",
                  "    let es = vec![hir.clone(), hir];",
                  "    lits.cut();",
                  "    assert!(lits2.union(lits3) == false);"
                ],
                [
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };",
                  "    let es = vec![hir.clone(), hir];",
                  "    lits.cut();",
                  "    assert!(!lits.cross_product(&lits2));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let hir = Hir {",
                  "        kind: HirKind::SomeKind, // Replace with an actual kind",
                  "        info: HirInfo::new(), // Assuming you have a way to create this",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")],",
                  "        limit_size: 5,",
                  "        limit_class: 5,",
                  "    };",
                  "    let es = vec![hir.clone(), hir];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(1);",
                  "        // Ensures non-empty lits3.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"z\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "        // This should lead to a situation where lits2.union(lits3) returns false.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"w\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "    });",
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };",
                  "    let es = vec![hir.clone(), hir];",
                  "    lits.cut();",
                  "    assert!(lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let hir = Hir {",
                  "        kind: HirKind::SomeKind, // Replace with an actual kind",
                  "        info: HirInfo::new(), // Assuming you have a way to create this",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")],",
                  "        limit_size: 5,",
                  "        limit_class: 5,",
                  "    };",
                  "    let es = vec![hir.clone(), hir];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(1);",
                  "        // Ensures non-empty lits3.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"z\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "        // This should lead to a situation where lits2.union(lits3) returns false.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"w\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "    });",
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };",
                  "    let es = vec![hir.clone(), hir];",
                  "    lits.cut();",
                  "    assert!(lits.limit_size() == 5);",
                  "}"
                ],
                [
                  "{",
                  "    let hir = Hir {",
                  "        kind: HirKind::SomeKind, // Replace with an actual kind",
                  "        info: HirInfo::new(), // Assuming you have a way to create this",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")],",
                  "        limit_size: 5,",
                  "        limit_class: 5,",
                  "    };",
                  "    let es = vec![hir.clone(), hir];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(1);",
                  "        // Ensures non-empty lits3.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"z\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "        // This should lead to a situation where lits2.union(lits3) returns false.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"w\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "    });",
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };",
                  "    let es = vec![hir.clone(), hir];",
                  "    lits.cut();",
                  "    assert!(lits.limit_class() == 5);",
                  "}"
                ],
                [
                  "{",
                  "    let hir = Hir {",
                  "        kind: HirKind::SomeKind, // Replace with an actual kind",
                  "        info: HirInfo::new(), // Assuming you have a way to create this",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")],",
                  "        limit_size: 5,",
                  "        limit_class: 5,",
                  "    };",
                  "    let es = vec![hir.clone(), hir];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(1);",
                  "        // Ensures non-empty lits3.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"z\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "        // This should lead to a situation where lits2.union(lits3) returns false.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"w\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "    });",
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };",
                  "    let es = vec![hir.clone(), hir];",
                  "    lits.cut();",
                  "    assert!(lits.literals().len() == 2);",
                  "}"
                ],
                [
                  "{",
                  "    let hir = Hir {",
                  "        kind: HirKind::SomeKind, // Replace with an actual kind",
                  "        info: HirInfo::new(), // Assuming you have a way to create this",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")],",
                  "        limit_size: 5,",
                  "        limit_class: 5,",
                  "    };",
                  "    let es = vec![hir.clone(), hir];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(1);",
                  "        // Ensures non-empty lits3.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"z\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "        // This should lead to a situation where lits2.union(lits3) returns false.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"w\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "    });",
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };",
                  "    let es = vec![hir.clone(), hir];",
                  "    lits.cut();",
                  "    assert!(lits.union(Literals { lits: vec![Literal::new(b\"z\")], limit_size: 1, limit_class: 1 }));",
                  "}"
                ],
                [
                  "{",
                  "    let hir = Hir {",
                  "        kind: HirKind::SomeKind, // Replace with an actual kind",
                  "        info: HirInfo::new(), // Assuming you have a way to create this",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")],",
                  "        limit_size: 5,",
                  "        limit_class: 5,",
                  "    };",
                  "    let es = vec![hir.clone(), hir];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(1);",
                  "        // Ensures non-empty lits3.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"z\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "        // This should lead to a situation where lits2.union(lits3) returns false.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"w\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "    });",
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };",
                  "    let es = vec![hir.clone(), hir];",
                  "    lits.cut();",
                  "    assert!(!lits.union(Literals { lits: vec![Literal::new(b\"w\")], limit_size: 1, limit_class: 1 }));",
                  "}"
                ],
                [
                  "{",
                  "    let hir = Hir {",
                  "        kind: HirKind::SomeKind, // Replace with an actual kind",
                  "        info: HirInfo::new(), // Assuming you have a way to create this",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")],",
                  "        limit_size: 5,",
                  "        limit_class: 5,",
                  "    };",
                  "    let es = vec![hir.clone(), hir];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(1);",
                  "        // Ensures non-empty lits3.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"z\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "        // This should lead to a situation where lits2.union(lits3) returns false.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"w\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "    });",
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };",
                  "    let es = vec![hir.clone(), hir];",
                  "    lits.cut();",
                  "    assert!(lits2.union(lits3) == false);",
                  "}"
                ],
                [
                  "{",
                  "    let hir = Hir {",
                  "        kind: HirKind::SomeKind, // Replace with an actual kind",
                  "        info: HirInfo::new(), // Assuming you have a way to create this",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")],",
                  "        limit_size: 5,",
                  "        limit_class: 5,",
                  "    };",
                  "    let es = vec![hir.clone(), hir];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(1);",
                  "        // Ensures non-empty lits3.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"z\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "        // This should lead to a situation where lits2.union(lits3) returns false.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"w\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "    });",
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };",
                  "    let es = vec![hir.clone(), hir];",
                  "    lits.cut();",
                  "    assert!(!lits.cross_product(&lits2));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(), // Assuming you have a way to create this\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1585:52\n     |\n1585 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind, // Replace with an actual kind\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n1564 |         lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")],\n     |                    ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:53\n     |\n1564 |         lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")],\n     |                                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                        |            |\n     |                                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |             lits: vec![Literal::new(b\"z\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1580:37\n     |\n1580 |             lits: vec![Literal::new(b\"w\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1585:36\n     |\n1585 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                    ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1586:55\n     |\n1586 |     let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };\n     |                                          ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1586:75\n     |\n1586 |     let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };\n     |                                                              ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                                              |            |\n     |                                                              |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                                              arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(), // Assuming you have a way to create this\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1585:52\n     |\n1585 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind, // Replace with an actual kind\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n1564 |         lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")],\n     |                    ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:53\n     |\n1564 |         lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")],\n     |                                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                        |            |\n     |                                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |             lits: vec![Literal::new(b\"z\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1580:37\n     |\n1580 |             lits: vec![Literal::new(b\"w\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1585:36\n     |\n1585 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                    ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1586:55\n     |\n1586 |     let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };\n     |                                          ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1586:75\n     |\n1586 |     let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };\n     |                                                              ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                                              |            |\n     |                                                              |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                                              arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(), // Assuming you have a way to create this\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1585:52\n     |\n1585 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind, // Replace with an actual kind\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n1564 |         lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")],\n     |                    ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:53\n     |\n1564 |         lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")],\n     |                                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                        |            |\n     |                                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |             lits: vec![Literal::new(b\"z\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1580:37\n     |\n1580 |             lits: vec![Literal::new(b\"w\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1585:36\n     |\n1585 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                    ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1586:55\n     |\n1586 |     let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };\n     |                                          ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1586:75\n     |\n1586 |     let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };\n     |                                                              ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                                              |            |\n     |                                                              |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                                              arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(), // Assuming you have a way to create this\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1585:52\n     |\n1585 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind, // Replace with an actual kind\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n1564 |         lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")],\n     |                    ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:53\n     |\n1564 |         lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")],\n     |                                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                        |            |\n     |                                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |             lits: vec![Literal::new(b\"z\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1580:37\n     |\n1580 |             lits: vec![Literal::new(b\"w\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1585:36\n     |\n1585 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                    ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1586:55\n     |\n1586 |     let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };\n     |                                          ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1586:75\n     |\n1586 |     let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };\n     |                                                              ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                                              |            |\n     |                                                              |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                                              arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 11 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(), // Assuming you have a way to create this\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1585:52\n     |\n1585 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind, // Replace with an actual kind\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n1564 |         lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")],\n     |                    ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:53\n     |\n1564 |         lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")],\n     |                                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                        |            |\n     |                                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |             lits: vec![Literal::new(b\"z\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1580:37\n     |\n1580 |             lits: vec![Literal::new(b\"w\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1585:36\n     |\n1585 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                    ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1586:55\n     |\n1586 |     let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };\n     |                                          ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1586:75\n     |\n1586 |     let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };\n     |                                                              ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                                              |            |\n     |                                                              |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                                              arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1589:59\n     |\n1589 |     assert!(lits.union(Literals { lits: vec![Literal::new(b\"z\")], limit_size: 1, limit_class: 1 }));\n     |                                              ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                              |            |\n     |                                              |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                              arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(), // Assuming you have a way to create this\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1585:52\n     |\n1585 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind, // Replace with an actual kind\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n1564 |         lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")],\n     |                    ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:53\n     |\n1564 |         lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")],\n     |                                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                        |            |\n     |                                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |             lits: vec![Literal::new(b\"z\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1580:37\n     |\n1580 |             lits: vec![Literal::new(b\"w\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1585:36\n     |\n1585 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                    ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1586:55\n     |\n1586 |     let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };\n     |                                          ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1586:75\n     |\n1586 |     let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };\n     |                                                              ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                                              |            |\n     |                                                              |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                                              arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1589:60\n     |\n1589 |     assert!(!lits.union(Literals { lits: vec![Literal::new(b\"w\")], limit_size: 1, limit_class: 1 }));\n     |                                               ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                               |            |\n     |                                               |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                               arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(), // Assuming you have a way to create this\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1585:52\n     |\n1585 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits2` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:13\n     |\n1589 |     assert!(lits2.union(lits3) == false);\n     |             ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:25\n     |\n1589 |     assert!(lits2.union(lits3) == false);\n     |                         ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind, // Replace with an actual kind\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n1564 |         lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")],\n     |                    ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:53\n     |\n1564 |         lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")],\n     |                                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                        |            |\n     |                                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |             lits: vec![Literal::new(b\"z\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1580:37\n     |\n1580 |             lits: vec![Literal::new(b\"w\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1585:36\n     |\n1585 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                    ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1586:55\n     |\n1586 |     let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };\n     |                                          ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1586:75\n     |\n1586 |     let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };\n     |                                                              ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                                              |            |\n     |                                                              |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                                              arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(), // Assuming you have a way to create this\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1585:52\n     |\n1585 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits2` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:34\n     |\n1589 |     assert!(!lits.cross_product(&lits2));\n     |                                  ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind, // Replace with an actual kind\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n1564 |         lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")],\n     |                    ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:53\n     |\n1564 |         lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")],\n     |                                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                        |            |\n     |                                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |             lits: vec![Literal::new(b\"z\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1580:37\n     |\n1580 |             lits: vec![Literal::new(b\"w\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1585:36\n     |\n1585 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                    ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1586:55\n     |\n1586 |     let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };\n     |                                          ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1586:75\n     |\n1586 |     let mut lits = Literals { lits: vec![Literal::new(b\"x\"), Literal::new(b\"y\")], limit_size: 5, limit_class: 5 };\n     |                                                              ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                                              |            |\n     |                                                              |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                                              arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 12 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let hir1 = Hir {",
                "        kind: HirKind::SomeKind,",
                "        info: HirInfo::new(),",
                "    };",
                "    let hir2 = Hir {",
                "        kind: HirKind::OtherKind, // Different kinds to ensure incompatibility",
                "        info: HirInfo::new(),",
                "    };",
                "    let mut lits = Literals {",
                "        lits: vec![Literal::new(b\"test\")],",
                "        limit_size: 15,",
                "        limit_class: 10,",
                "    };",
                "    let es = vec![hir1, hir2];",
                "    ",
                "    alternate_literals(&es, &mut lits, |_, lits3| {",
                "        lits3.set_limit_size(3);",
                "        // This ensures that lits3 is not empty.",
                "        lits3.union(Literals {",
                "            lits: vec![Literal::new(b\"123\")],",
                "            limit_size: 3,",
                "            limit_class: 3,",
                "        });",
                "        // Different limit should ensure union fails.",
                "        lits3.union(Literals {",
                "            lits: vec![Literal::new(b\"abc\")],",
                "            limit_size: 2,",
                "            limit_class: 2,",
                "        });",
                "    });",
                "}"
              ],
              "oracles": [
                [
                  "    let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };",
                  "    let es = vec![hir1, hir2];",
                  "    lits.cut();",
                  "    assert!(lits.lits.is_empty());"
                ],
                [
                  "    let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };",
                  "    let es = vec![hir1, hir2];",
                  "    lits.cut();",
                  "    assert_eq!(lits.limit_size(), 15);"
                ],
                [
                  "    let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };",
                  "    let es = vec![hir1, hir2];",
                  "    lits.cut();",
                  "    assert_eq!(lits.limit_class, 10);"
                ],
                [
                  "    let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };",
                  "    let es = vec![hir1, hir2];",
                  "    lits.cut();",
                  "    assert!(lits.is_empty());"
                ],
                [
                  "    let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };",
                  "    let es = vec![hir1, hir2];",
                  "    lits.cut();",
                  "    assert!(!lits.all_complete());"
                ],
                [
                  "    let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };",
                  "    let es = vec![hir1, hir2];",
                  "    lits.cut();",
                  "    assert!(!lits.any_complete());"
                ],
                [
                  "    let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };",
                  "    let es = vec![hir1, hir2];",
                  "    lits.cut();",
                  "    assert!(!lits.contains_empty());"
                ],
                [
                  "    let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };",
                  "    let es = vec![hir1, hir2];",
                  "    lits.cut();",
                  "    assert_eq!(lits.longest_common_prefix(), &[]);"
                ],
                [
                  "    let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };",
                  "    let es = vec![hir1, hir2];",
                  "    lits.cut();",
                  "    assert_eq!(lits.longest_common_suffix(), &[]);"
                ],
                [
                  "    let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };",
                  "    let es = vec![hir1, hir2];",
                  "    lits.cut();",
                  "    assert_eq!(lits.min_len(), None);"
                ],
                [
                  "    let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };",
                  "    let es = vec![hir1, hir2];",
                  "    lits.cut();",
                  "    assert_eq!(lits.union_prefixes(&hir1), false);"
                ],
                [
                  "    let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };",
                  "    let es = vec![hir1, hir2];",
                  "    lits.cut();",
                  "    assert_eq!(lits.union_suffixes(&hir2), false);"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let hir1 = Hir {",
                  "        kind: HirKind::SomeKind,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let hir2 = Hir {",
                  "        kind: HirKind::OtherKind, // Different kinds to ensure incompatibility",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"test\")],",
                  "        limit_size: 15,",
                  "        limit_class: 10,",
                  "    };",
                  "    let es = vec![hir1, hir2];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // This ensures that lits3 is not empty.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"123\")],",
                  "            limit_size: 3,",
                  "            limit_class: 3,",
                  "        });",
                  "        // Different limit should ensure union fails.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"abc\")],",
                  "            limit_size: 2,",
                  "            limit_class: 2,",
                  "        });",
                  "    });",
                  "    let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };",
                  "    let es = vec![hir1, hir2];",
                  "    lits.cut();",
                  "    assert!(lits.lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let hir1 = Hir {",
                  "        kind: HirKind::SomeKind,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let hir2 = Hir {",
                  "        kind: HirKind::OtherKind, // Different kinds to ensure incompatibility",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"test\")],",
                  "        limit_size: 15,",
                  "        limit_class: 10,",
                  "    };",
                  "    let es = vec![hir1, hir2];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // This ensures that lits3 is not empty.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"123\")],",
                  "            limit_size: 3,",
                  "            limit_class: 3,",
                  "        });",
                  "        // Different limit should ensure union fails.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"abc\")],",
                  "            limit_size: 2,",
                  "            limit_class: 2,",
                  "        });",
                  "    });",
                  "    let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };",
                  "    let es = vec![hir1, hir2];",
                  "    lits.cut();",
                  "    assert_eq!(lits.limit_size(), 15);",
                  "}"
                ],
                [
                  "{",
                  "    let hir1 = Hir {",
                  "        kind: HirKind::SomeKind,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let hir2 = Hir {",
                  "        kind: HirKind::OtherKind, // Different kinds to ensure incompatibility",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"test\")],",
                  "        limit_size: 15,",
                  "        limit_class: 10,",
                  "    };",
                  "    let es = vec![hir1, hir2];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // This ensures that lits3 is not empty.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"123\")],",
                  "            limit_size: 3,",
                  "            limit_class: 3,",
                  "        });",
                  "        // Different limit should ensure union fails.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"abc\")],",
                  "            limit_size: 2,",
                  "            limit_class: 2,",
                  "        });",
                  "    });",
                  "    let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };",
                  "    let es = vec![hir1, hir2];",
                  "    lits.cut();",
                  "    assert_eq!(lits.limit_class, 10);",
                  "}"
                ],
                [
                  "{",
                  "    let hir1 = Hir {",
                  "        kind: HirKind::SomeKind,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let hir2 = Hir {",
                  "        kind: HirKind::OtherKind, // Different kinds to ensure incompatibility",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"test\")],",
                  "        limit_size: 15,",
                  "        limit_class: 10,",
                  "    };",
                  "    let es = vec![hir1, hir2];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // This ensures that lits3 is not empty.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"123\")],",
                  "            limit_size: 3,",
                  "            limit_class: 3,",
                  "        });",
                  "        // Different limit should ensure union fails.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"abc\")],",
                  "            limit_size: 2,",
                  "            limit_class: 2,",
                  "        });",
                  "    });",
                  "    let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };",
                  "    let es = vec![hir1, hir2];",
                  "    lits.cut();",
                  "    assert!(lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let hir1 = Hir {",
                  "        kind: HirKind::SomeKind,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let hir2 = Hir {",
                  "        kind: HirKind::OtherKind, // Different kinds to ensure incompatibility",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"test\")],",
                  "        limit_size: 15,",
                  "        limit_class: 10,",
                  "    };",
                  "    let es = vec![hir1, hir2];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // This ensures that lits3 is not empty.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"123\")],",
                  "            limit_size: 3,",
                  "            limit_class: 3,",
                  "        });",
                  "        // Different limit should ensure union fails.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"abc\")],",
                  "            limit_size: 2,",
                  "            limit_class: 2,",
                  "        });",
                  "    });",
                  "    let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };",
                  "    let es = vec![hir1, hir2];",
                  "    lits.cut();",
                  "    assert!(!lits.all_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let hir1 = Hir {",
                  "        kind: HirKind::SomeKind,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let hir2 = Hir {",
                  "        kind: HirKind::OtherKind, // Different kinds to ensure incompatibility",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"test\")],",
                  "        limit_size: 15,",
                  "        limit_class: 10,",
                  "    };",
                  "    let es = vec![hir1, hir2];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // This ensures that lits3 is not empty.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"123\")],",
                  "            limit_size: 3,",
                  "            limit_class: 3,",
                  "        });",
                  "        // Different limit should ensure union fails.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"abc\")],",
                  "            limit_size: 2,",
                  "            limit_class: 2,",
                  "        });",
                  "    });",
                  "    let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };",
                  "    let es = vec![hir1, hir2];",
                  "    lits.cut();",
                  "    assert!(!lits.any_complete());",
                  "}"
                ],
                [
                  "{",
                  "    let hir1 = Hir {",
                  "        kind: HirKind::SomeKind,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let hir2 = Hir {",
                  "        kind: HirKind::OtherKind, // Different kinds to ensure incompatibility",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"test\")],",
                  "        limit_size: 15,",
                  "        limit_class: 10,",
                  "    };",
                  "    let es = vec![hir1, hir2];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // This ensures that lits3 is not empty.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"123\")],",
                  "            limit_size: 3,",
                  "            limit_class: 3,",
                  "        });",
                  "        // Different limit should ensure union fails.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"abc\")],",
                  "            limit_size: 2,",
                  "            limit_class: 2,",
                  "        });",
                  "    });",
                  "    let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };",
                  "    let es = vec![hir1, hir2];",
                  "    lits.cut();",
                  "    assert!(!lits.contains_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let hir1 = Hir {",
                  "        kind: HirKind::SomeKind,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let hir2 = Hir {",
                  "        kind: HirKind::OtherKind, // Different kinds to ensure incompatibility",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"test\")],",
                  "        limit_size: 15,",
                  "        limit_class: 10,",
                  "    };",
                  "    let es = vec![hir1, hir2];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // This ensures that lits3 is not empty.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"123\")],",
                  "            limit_size: 3,",
                  "            limit_class: 3,",
                  "        });",
                  "        // Different limit should ensure union fails.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"abc\")],",
                  "            limit_size: 2,",
                  "            limit_class: 2,",
                  "        });",
                  "    });",
                  "    let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };",
                  "    let es = vec![hir1, hir2];",
                  "    lits.cut();",
                  "    assert_eq!(lits.longest_common_prefix(), &[]);",
                  "}"
                ],
                [
                  "{",
                  "    let hir1 = Hir {",
                  "        kind: HirKind::SomeKind,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let hir2 = Hir {",
                  "        kind: HirKind::OtherKind, // Different kinds to ensure incompatibility",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"test\")],",
                  "        limit_size: 15,",
                  "        limit_class: 10,",
                  "    };",
                  "    let es = vec![hir1, hir2];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // This ensures that lits3 is not empty.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"123\")],",
                  "            limit_size: 3,",
                  "            limit_class: 3,",
                  "        });",
                  "        // Different limit should ensure union fails.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"abc\")],",
                  "            limit_size: 2,",
                  "            limit_class: 2,",
                  "        });",
                  "    });",
                  "    let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };",
                  "    let es = vec![hir1, hir2];",
                  "    lits.cut();",
                  "    assert_eq!(lits.longest_common_suffix(), &[]);",
                  "}"
                ],
                [
                  "{",
                  "    let hir1 = Hir {",
                  "        kind: HirKind::SomeKind,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let hir2 = Hir {",
                  "        kind: HirKind::OtherKind, // Different kinds to ensure incompatibility",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"test\")],",
                  "        limit_size: 15,",
                  "        limit_class: 10,",
                  "    };",
                  "    let es = vec![hir1, hir2];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // This ensures that lits3 is not empty.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"123\")],",
                  "            limit_size: 3,",
                  "            limit_class: 3,",
                  "        });",
                  "        // Different limit should ensure union fails.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"abc\")],",
                  "            limit_size: 2,",
                  "            limit_class: 2,",
                  "        });",
                  "    });",
                  "    let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };",
                  "    let es = vec![hir1, hir2];",
                  "    lits.cut();",
                  "    assert_eq!(lits.min_len(), None);",
                  "}"
                ],
                [
                  "{",
                  "    let hir1 = Hir {",
                  "        kind: HirKind::SomeKind,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let hir2 = Hir {",
                  "        kind: HirKind::OtherKind, // Different kinds to ensure incompatibility",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"test\")],",
                  "        limit_size: 15,",
                  "        limit_class: 10,",
                  "    };",
                  "    let es = vec![hir1, hir2];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // This ensures that lits3 is not empty.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"123\")],",
                  "            limit_size: 3,",
                  "            limit_class: 3,",
                  "        });",
                  "        // Different limit should ensure union fails.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"abc\")],",
                  "            limit_size: 2,",
                  "            limit_class: 2,",
                  "        });",
                  "    });",
                  "    let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };",
                  "    let es = vec![hir1, hir2];",
                  "    lits.cut();",
                  "    assert_eq!(lits.union_prefixes(&hir1), false);",
                  "}"
                ],
                [
                  "{",
                  "    let hir1 = Hir {",
                  "        kind: HirKind::SomeKind,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let hir2 = Hir {",
                  "        kind: HirKind::OtherKind, // Different kinds to ensure incompatibility",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"test\")],",
                  "        limit_size: 15,",
                  "        limit_class: 10,",
                  "    };",
                  "    let es = vec![hir1, hir2];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(3);",
                  "        // This ensures that lits3 is not empty.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"123\")],",
                  "            limit_size: 3,",
                  "            limit_class: 3,",
                  "        });",
                  "        // Different limit should ensure union fails.",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"abc\")],",
                  "            limit_size: 2,",
                  "            limit_class: 2,",
                  "        });",
                  "    });",
                  "    let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };",
                  "    let es = vec![hir1, hir2];",
                  "    lits.cut();",
                  "    assert_eq!(lits.union_suffixes(&hir2), false);",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1589:53\n     |\n1589 |     let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1590:54\n     |\n1590 |     let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };\n     |                                                      ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind,\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0599]: no variant or associated item named `OtherKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:24\n     |\n1564 |         kind: HirKind::OtherKind, // Different kinds to ensure incompatibility\n     |                        ^^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `OtherKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1568:33\n     |\n1568 |         lits: vec![Literal::new(b\"test\")],\n     |                    ------------ ^^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 4]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 4]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1578:37\n     |\n1578 |             lits: vec![Literal::new(b\"123\")],\n     |                        ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1584:37\n     |\n1584 |             lits: vec![Literal::new(b\"abc\")],\n     |                        ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:37\n     |\n1589 |     let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                     ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0599]: no variant or associated item named `OtherKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1590:37\n     |\n1590 |     let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };\n     |                                     ^^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `OtherKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1591:55\n     |\n1591 |     let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };\n     |                                          ------------ ^^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 4]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 4]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1589:53\n     |\n1589 |     let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1590:54\n     |\n1590 |     let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };\n     |                                                      ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind,\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0599]: no variant or associated item named `OtherKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:24\n     |\n1564 |         kind: HirKind::OtherKind, // Different kinds to ensure incompatibility\n     |                        ^^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `OtherKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1568:33\n     |\n1568 |         lits: vec![Literal::new(b\"test\")],\n     |                    ------------ ^^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 4]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 4]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1578:37\n     |\n1578 |             lits: vec![Literal::new(b\"123\")],\n     |                        ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1584:37\n     |\n1584 |             lits: vec![Literal::new(b\"abc\")],\n     |                        ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:37\n     |\n1589 |     let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                     ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0599]: no variant or associated item named `OtherKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1590:37\n     |\n1590 |     let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };\n     |                                     ^^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `OtherKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1591:55\n     |\n1591 |     let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };\n     |                                          ------------ ^^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 4]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 4]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1589:53\n     |\n1589 |     let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1590:54\n     |\n1590 |     let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };\n     |                                                      ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind,\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0599]: no variant or associated item named `OtherKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:24\n     |\n1564 |         kind: HirKind::OtherKind, // Different kinds to ensure incompatibility\n     |                        ^^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `OtherKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1568:33\n     |\n1568 |         lits: vec![Literal::new(b\"test\")],\n     |                    ------------ ^^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 4]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 4]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1578:37\n     |\n1578 |             lits: vec![Literal::new(b\"123\")],\n     |                        ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1584:37\n     |\n1584 |             lits: vec![Literal::new(b\"abc\")],\n     |                        ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:37\n     |\n1589 |     let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                     ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0599]: no variant or associated item named `OtherKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1590:37\n     |\n1590 |     let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };\n     |                                     ^^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `OtherKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1591:55\n     |\n1591 |     let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };\n     |                                          ------------ ^^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 4]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 4]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1589:53\n     |\n1589 |     let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1590:54\n     |\n1590 |     let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };\n     |                                                      ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind,\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0599]: no variant or associated item named `OtherKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:24\n     |\n1564 |         kind: HirKind::OtherKind, // Different kinds to ensure incompatibility\n     |                        ^^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `OtherKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1568:33\n     |\n1568 |         lits: vec![Literal::new(b\"test\")],\n     |                    ------------ ^^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 4]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 4]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1578:37\n     |\n1578 |             lits: vec![Literal::new(b\"123\")],\n     |                        ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1584:37\n     |\n1584 |             lits: vec![Literal::new(b\"abc\")],\n     |                        ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:37\n     |\n1589 |     let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                     ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0599]: no variant or associated item named `OtherKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1590:37\n     |\n1590 |     let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };\n     |                                     ^^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `OtherKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1591:55\n     |\n1591 |     let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };\n     |                                          ------------ ^^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 4]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 4]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1589:53\n     |\n1589 |     let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1590:54\n     |\n1590 |     let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };\n     |                                                      ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind,\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0599]: no variant or associated item named `OtherKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:24\n     |\n1564 |         kind: HirKind::OtherKind, // Different kinds to ensure incompatibility\n     |                        ^^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `OtherKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1568:33\n     |\n1568 |         lits: vec![Literal::new(b\"test\")],\n     |                    ------------ ^^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 4]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 4]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1578:37\n     |\n1578 |             lits: vec![Literal::new(b\"123\")],\n     |                        ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1584:37\n     |\n1584 |             lits: vec![Literal::new(b\"abc\")],\n     |                        ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:37\n     |\n1589 |     let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                     ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0599]: no variant or associated item named `OtherKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1590:37\n     |\n1590 |     let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };\n     |                                     ^^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `OtherKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1591:55\n     |\n1591 |     let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };\n     |                                          ------------ ^^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 4]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 4]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1589:53\n     |\n1589 |     let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1590:54\n     |\n1590 |     let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };\n     |                                                      ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind,\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0599]: no variant or associated item named `OtherKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:24\n     |\n1564 |         kind: HirKind::OtherKind, // Different kinds to ensure incompatibility\n     |                        ^^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `OtherKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1568:33\n     |\n1568 |         lits: vec![Literal::new(b\"test\")],\n     |                    ------------ ^^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 4]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 4]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1578:37\n     |\n1578 |             lits: vec![Literal::new(b\"123\")],\n     |                        ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1584:37\n     |\n1584 |             lits: vec![Literal::new(b\"abc\")],\n     |                        ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:37\n     |\n1589 |     let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                     ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0599]: no variant or associated item named `OtherKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1590:37\n     |\n1590 |     let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };\n     |                                     ^^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `OtherKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1591:55\n     |\n1591 |     let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };\n     |                                          ------------ ^^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 4]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 4]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1589:53\n     |\n1589 |     let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1590:54\n     |\n1590 |     let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };\n     |                                                      ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind,\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0599]: no variant or associated item named `OtherKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:24\n     |\n1564 |         kind: HirKind::OtherKind, // Different kinds to ensure incompatibility\n     |                        ^^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `OtherKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1568:33\n     |\n1568 |         lits: vec![Literal::new(b\"test\")],\n     |                    ------------ ^^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 4]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 4]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1578:37\n     |\n1578 |             lits: vec![Literal::new(b\"123\")],\n     |                        ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1584:37\n     |\n1584 |             lits: vec![Literal::new(b\"abc\")],\n     |                        ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:37\n     |\n1589 |     let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                     ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0599]: no variant or associated item named `OtherKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1590:37\n     |\n1590 |     let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };\n     |                                     ^^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `OtherKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1591:55\n     |\n1591 |     let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };\n     |                                          ------------ ^^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 4]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 4]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1589:53\n     |\n1589 |     let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1590:54\n     |\n1590 |     let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };\n     |                                                      ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind,\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0599]: no variant or associated item named `OtherKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:24\n     |\n1564 |         kind: HirKind::OtherKind, // Different kinds to ensure incompatibility\n     |                        ^^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `OtherKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1568:33\n     |\n1568 |         lits: vec![Literal::new(b\"test\")],\n     |                    ------------ ^^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 4]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 4]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1578:37\n     |\n1578 |             lits: vec![Literal::new(b\"123\")],\n     |                        ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1584:37\n     |\n1584 |             lits: vec![Literal::new(b\"abc\")],\n     |                        ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:37\n     |\n1589 |     let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                     ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0599]: no variant or associated item named `OtherKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1590:37\n     |\n1590 |     let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };\n     |                                     ^^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `OtherKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1591:55\n     |\n1591 |     let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };\n     |                                          ------------ ^^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 4]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 4]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1589:53\n     |\n1589 |     let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1590:54\n     |\n1590 |     let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };\n     |                                                      ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind,\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0599]: no variant or associated item named `OtherKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:24\n     |\n1564 |         kind: HirKind::OtherKind, // Different kinds to ensure incompatibility\n     |                        ^^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `OtherKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1568:33\n     |\n1568 |         lits: vec![Literal::new(b\"test\")],\n     |                    ------------ ^^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 4]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 4]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1578:37\n     |\n1578 |             lits: vec![Literal::new(b\"123\")],\n     |                        ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1584:37\n     |\n1584 |             lits: vec![Literal::new(b\"abc\")],\n     |                        ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:37\n     |\n1589 |     let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                     ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0599]: no variant or associated item named `OtherKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1590:37\n     |\n1590 |     let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };\n     |                                     ^^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `OtherKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1591:55\n     |\n1591 |     let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };\n     |                                          ------------ ^^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 4]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 4]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1589:53\n     |\n1589 |     let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1590:54\n     |\n1590 |     let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };\n     |                                                      ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind,\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0599]: no variant or associated item named `OtherKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:24\n     |\n1564 |         kind: HirKind::OtherKind, // Different kinds to ensure incompatibility\n     |                        ^^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `OtherKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1568:33\n     |\n1568 |         lits: vec![Literal::new(b\"test\")],\n     |                    ------------ ^^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 4]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 4]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1578:37\n     |\n1578 |             lits: vec![Literal::new(b\"123\")],\n     |                        ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1584:37\n     |\n1584 |             lits: vec![Literal::new(b\"abc\")],\n     |                        ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:37\n     |\n1589 |     let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                     ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0599]: no variant or associated item named `OtherKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1590:37\n     |\n1590 |     let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };\n     |                                     ^^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `OtherKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1591:55\n     |\n1591 |     let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };\n     |                                          ------------ ^^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 4]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 4]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1589:53\n     |\n1589 |     let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1590:54\n     |\n1590 |     let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };\n     |                                                      ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind,\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0599]: no variant or associated item named `OtherKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:24\n     |\n1564 |         kind: HirKind::OtherKind, // Different kinds to ensure incompatibility\n     |                        ^^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `OtherKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1568:33\n     |\n1568 |         lits: vec![Literal::new(b\"test\")],\n     |                    ------------ ^^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 4]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 4]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1578:37\n     |\n1578 |             lits: vec![Literal::new(b\"123\")],\n     |                        ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1584:37\n     |\n1584 |             lits: vec![Literal::new(b\"abc\")],\n     |                        ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:37\n     |\n1589 |     let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                     ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0599]: no variant or associated item named `OtherKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1590:37\n     |\n1590 |     let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };\n     |                                     ^^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `OtherKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1591:55\n     |\n1591 |     let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };\n     |                                          ------------ ^^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 4]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 4]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1565:15\n     |\n1565 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1589:53\n     |\n1589 |     let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1590:54\n     |\n1590 |     let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };\n     |                                                      ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind,\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0599]: no variant or associated item named `OtherKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:24\n     |\n1564 |         kind: HirKind::OtherKind, // Different kinds to ensure incompatibility\n     |                        ^^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `OtherKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1568:33\n     |\n1568 |         lits: vec![Literal::new(b\"test\")],\n     |                    ------------ ^^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 4]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 4]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1578:37\n     |\n1578 |             lits: vec![Literal::new(b\"123\")],\n     |                        ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1584:37\n     |\n1584 |             lits: vec![Literal::new(b\"abc\")],\n     |                        ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:37\n     |\n1589 |     let hir1 = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                     ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0599]: no variant or associated item named `OtherKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1590:37\n     |\n1590 |     let hir2 = Hir { kind: HirKind::OtherKind, info: HirInfo::new() };\n     |                                     ^^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `OtherKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1591:55\n     |\n1591 |     let mut lits = Literals { lits: vec![Literal::new(b\"test\")], limit_size: 15, limit_class: 10 };\n     |                                          ------------ ^^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 4]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 4]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let hir = Hir {",
                "        kind: HirKind::SomeKind,",
                "        info: HirInfo::new(),",
                "    };",
                "    let mut lits = Literals {",
                "        lits: vec![Literal::new(b\"foo\"), Literal::new(b\"bar\")],",
                "        limit_size: 12,",
                "        limit_class: 12,",
                "    };",
                "    let es = vec![hir.clone(), hir.clone(), hir.clone(), hir.clone(), hir.clone()];",
                "    ",
                "    alternate_literals(&es, &mut lits, |_, lits3| {",
                "        lits3.set_limit_size(1);",
                "        // Ensure that lits3 is not empty and try to induce a failure scenario",
                "        lits3.union(Literals {",
                "            lits: vec![Literal::new(b\"x\")],",
                "            limit_size: 1,",
                "            limit_class: 1,",
                "        });",
                "        // Attempt to union incompatible literals",
                "        lits3.union(Literals {",
                "            lits: vec![Literal::new(b\"y\"), Literal::new(b\"z\")],",
                "            limit_size: 1,",
                "            limit_class: 1,",
                "        });",
                "    });",
                "}"
              ],
              "oracles": [
                [
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"foo\"), Literal::new(b\"bar\")], limit_size: 12, limit_class: 12 };",
                  "    let es = vec![hir.clone(), hir.clone(), hir.clone(), hir.clone(), hir.clone()];",
                  "    lits3.set_limit_size(1);",
                  "    assert!(!lits3.is_empty());"
                ],
                [
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"foo\"), Literal::new(b\"bar\")], limit_size: 12, limit_class: 12 };",
                  "    let es = vec![hir.clone(), hir.clone(), hir.clone(), hir.clone(), hir.clone()];",
                  "    lits3.set_limit_size(1);",
                  "    assert!(!lits2.union(Literals { lits: vec![Literal::new(b\"x\")], limit_size: 1, limit_class: 1 }));"
                ],
                [
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"foo\"), Literal::new(b\"bar\")], limit_size: 12, limit_class: 12 };",
                  "    let es = vec![hir.clone(), hir.clone(), hir.clone(), hir.clone(), hir.clone()];",
                  "    lits3.set_limit_size(1);",
                  "    assert!(!lits3.union(Literals { lits: vec![Literal::new(b\"y\"), Literal::new(b\"z\")], limit_size: 1, limit_class: 1 }));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let hir = Hir {",
                  "        kind: HirKind::SomeKind,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"foo\"), Literal::new(b\"bar\")],",
                  "        limit_size: 12,",
                  "        limit_class: 12,",
                  "    };",
                  "    let es = vec![hir.clone(), hir.clone(), hir.clone(), hir.clone(), hir.clone()];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(1);",
                  "        // Ensure that lits3 is not empty and try to induce a failure scenario",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"x\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "        // Attempt to union incompatible literals",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"y\"), Literal::new(b\"z\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "    });",
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"foo\"), Literal::new(b\"bar\")], limit_size: 12, limit_class: 12 };",
                  "    let es = vec![hir.clone(), hir.clone(), hir.clone(), hir.clone(), hir.clone()];",
                  "    lits3.set_limit_size(1);",
                  "    assert!(!lits3.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let hir = Hir {",
                  "        kind: HirKind::SomeKind,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"foo\"), Literal::new(b\"bar\")],",
                  "        limit_size: 12,",
                  "        limit_class: 12,",
                  "    };",
                  "    let es = vec![hir.clone(), hir.clone(), hir.clone(), hir.clone(), hir.clone()];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(1);",
                  "        // Ensure that lits3 is not empty and try to induce a failure scenario",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"x\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "        // Attempt to union incompatible literals",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"y\"), Literal::new(b\"z\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "    });",
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"foo\"), Literal::new(b\"bar\")], limit_size: 12, limit_class: 12 };",
                  "    let es = vec![hir.clone(), hir.clone(), hir.clone(), hir.clone(), hir.clone()];",
                  "    lits3.set_limit_size(1);",
                  "    assert!(!lits2.union(Literals { lits: vec![Literal::new(b\"x\")], limit_size: 1, limit_class: 1 }));",
                  "}"
                ],
                [
                  "{",
                  "    let hir = Hir {",
                  "        kind: HirKind::SomeKind,",
                  "        info: HirInfo::new(),",
                  "    };",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new(b\"foo\"), Literal::new(b\"bar\")],",
                  "        limit_size: 12,",
                  "        limit_class: 12,",
                  "    };",
                  "    let es = vec![hir.clone(), hir.clone(), hir.clone(), hir.clone(), hir.clone()];",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, lits3| {",
                  "        lits3.set_limit_size(1);",
                  "        // Ensure that lits3 is not empty and try to induce a failure scenario",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"x\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "        // Attempt to union incompatible literals",
                  "        lits3.union(Literals {",
                  "            lits: vec![Literal::new(b\"y\"), Literal::new(b\"z\")],",
                  "            limit_size: 1,",
                  "            limit_class: 1,",
                  "        });",
                  "    });",
                  "    let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };",
                  "    let mut lits = Literals { lits: vec![Literal::new(b\"foo\"), Literal::new(b\"bar\")], limit_size: 12, limit_class: 12 };",
                  "    let es = vec![hir.clone(), hir.clone(), hir.clone(), hir.clone(), hir.clone()];",
                  "    lits3.set_limit_size(1);",
                  "    assert!(!lits3.union(Literals { lits: vec![Literal::new(b\"y\"), Literal::new(b\"z\")], limit_size: 1, limit_class: 1 }));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1585:52\n     |\n1585 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1588:5\n     |\n1588 |     lits3.set_limit_size(1);\n     |     ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:14\n     |\n1589 |     assert!(!lits3.is_empty());\n     |              ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind,\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n1564 |         lits: vec![Literal::new(b\"foo\"), Literal::new(b\"bar\")],\n     |                    ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:55\n     |\n1564 |         lits: vec![Literal::new(b\"foo\"), Literal::new(b\"bar\")],\n     |                                          ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |             lits: vec![Literal::new(b\"x\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1580:37\n     |\n1580 |             lits: vec![Literal::new(b\"y\"), Literal::new(b\"z\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1580:57\n     |\n1580 |             lits: vec![Literal::new(b\"y\"), Literal::new(b\"z\")],\n     |                                            ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                            |            |\n     |                                            |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                            arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1585:36\n     |\n1585 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                    ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1586:55\n     |\n1586 |     let mut lits = Literals { lits: vec![Literal::new(b\"foo\"), Literal::new(b\"bar\")], limit_size: 12, limit_class: 12 };\n     |                                          ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1586:77\n     |\n1586 |     let mut lits = Literals { lits: vec![Literal::new(b\"foo\"), Literal::new(b\"bar\")], limit_size: 12, limit_class: 12 };\n     |                                                                ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                                                                |            |\n     |                                                                |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                                                                arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1585:52\n     |\n1585 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1588:5\n     |\n1588 |     lits3.set_limit_size(1);\n     |     ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits2` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:14\n     |\n1589 |     assert!(!lits2.union(Literals { lits: vec![Literal::new(b\"x\")], limit_size: 1, limit_class: 1 }));\n     |              ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind,\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n1564 |         lits: vec![Literal::new(b\"foo\"), Literal::new(b\"bar\")],\n     |                    ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:55\n     |\n1564 |         lits: vec![Literal::new(b\"foo\"), Literal::new(b\"bar\")],\n     |                                          ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |             lits: vec![Literal::new(b\"x\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1580:37\n     |\n1580 |             lits: vec![Literal::new(b\"y\"), Literal::new(b\"z\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1580:57\n     |\n1580 |             lits: vec![Literal::new(b\"y\"), Literal::new(b\"z\")],\n     |                                            ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                            |            |\n     |                                            |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                            arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1585:36\n     |\n1585 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                    ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1586:55\n     |\n1586 |     let mut lits = Literals { lits: vec![Literal::new(b\"foo\"), Literal::new(b\"bar\")], limit_size: 12, limit_class: 12 };\n     |                                          ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1586:77\n     |\n1586 |     let mut lits = Literals { lits: vec![Literal::new(b\"foo\"), Literal::new(b\"bar\")], limit_size: 12, limit_class: 12 };\n     |                                                                ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                                                                |            |\n     |                                                                |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                                                                arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1589:61\n     |\n1589 |     assert!(!lits2.union(Literals { lits: vec![Literal::new(b\"x\")], limit_size: 1, limit_class: 1 }));\n     |                                                ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                                |            |\n     |                                                |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                                arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 15 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1561:15\n     |\n1561 |         info: HirInfo::new(),\n     |               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1585:52\n     |\n1585 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                                    ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1588:5\n     |\n1588 |     lits3.set_limit_size(1);\n     |     ^^^^^ help: a local variable with a similar name exists: `lits`\n\nerror[E0425]: cannot find value `lits3` in this scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:14\n     |\n1589 |     assert!(!lits3.union(Literals { lits: vec![Literal::new(b\"y\"), Literal::new(b\"z\")], limit_size: 1, limit_class: 1 }));\n     |              ^^^^^ help: a local variable with a similar name exists: `lits`\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1560:24\n     |\n1560 |         kind: HirKind::SomeKind,\n     |                        ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:33\n     |\n1564 |         lits: vec![Literal::new(b\"foo\"), Literal::new(b\"bar\")],\n     |                    ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                    |            |\n     |                    |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1564:55\n     |\n1564 |         lits: vec![Literal::new(b\"foo\"), Literal::new(b\"bar\")],\n     |                                          ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1574:37\n     |\n1574 |             lits: vec![Literal::new(b\"x\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1580:37\n     |\n1580 |             lits: vec![Literal::new(b\"y\"), Literal::new(b\"z\")],\n     |                        ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                        |            |\n     |                        |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                        arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1580:57\n     |\n1580 |             lits: vec![Literal::new(b\"y\"), Literal::new(b\"z\")],\n     |                                            ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                            |            |\n     |                                            |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                            arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1585:36\n     |\n1585 |     let hir = Hir { kind: HirKind::SomeKind, info: HirInfo::new() };\n     |                                    ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1586:55\n     |\n1586 |     let mut lits = Literals { lits: vec![Literal::new(b\"foo\"), Literal::new(b\"bar\")], limit_size: 12, limit_class: 12 };\n     |                                          ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                                          |            |\n     |                                          |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                                          arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1586:77\n     |\n1586 |     let mut lits = Literals { lits: vec![Literal::new(b\"foo\"), Literal::new(b\"bar\")], limit_size: 12, limit_class: 12 };\n     |                                                                ------------ ^^^^^^- help: try using a conversion method: `.to_vec()`\n     |                                                                |            |\n     |                                                                |            expected `Vec<u8>`, found `&[u8; 3]`\n     |                                                                arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 3]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1589:61\n     |\n1589 |     assert!(!lits3.union(Literals { lits: vec![Literal::new(b\"y\"), Literal::new(b\"z\")], limit_size: 1, limit_class: 1 }));\n     |                                                ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                                |            |\n     |                                                |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                                arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1589:81\n     |\n1589 |     assert!(!lits3.union(Literals { lits: vec![Literal::new(b\"y\"), Literal::new(b\"z\")], limit_size: 1, limit_class: 1 }));\n     |                                                                    ------------ ^^^^- help: try using a conversion method: `.to_vec()`\n     |                                                                    |            |\n     |                                                                    |            expected `Vec<u8>`, found `&[u8; 1]`\n     |                                                                    arguments to this function are incorrect\n     |\n     = note: expected struct `Vec<u8>`\n             found reference `&'static [u8; 1]`\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0308, E0425, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 16 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    },
    {
      "chain_id": 5,
      "prompt_conds": [
        "// constraint: e in es is false\n",
        "// constraint: lits.cross_product(&lits2) is true\n"
      ],
      "input_infer": "es: [non-empty array], lits: Literals with limit_size > 0, lits2: Literals with limit_size <= lits.limit_size / 5, f: valid function, ensure non-empty return from f\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    // Define a valid function for `f`",
                "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                "        let lit = Literal::new(); // Use appropriate initialization for Literal",
                "        lits3.add(lit);",
                "    };",
                "",
                "    // Construct test data",
                "    let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                "    let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                "    let es = vec![expr1, expr2];",
                "",
                "    let mut lits = Literals {",
                "        lits: vec![Literal::new()], // Use appropriate initialization for Literal",
                "        limit_size: 100,",
                "        limit_class: 10,",
                "    };",
                "",
                "    alternate_literals(&es, &mut lits, f);",
                "}"
              ],
              "oracles": [
                [
                  "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                  "    let lit = Literal::new();",
                  "    lits3.add(lit);",
                  "    };",
                  "    let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let es = vec![expr1, expr2];",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new()],",
                  "    limit_size: 100,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert_eq!(lits.limit_size(), 100);"
                ],
                [
                  "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                  "    let lit = Literal::new();",
                  "    lits3.add(lit);",
                  "    };",
                  "    let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let es = vec![expr1, expr2];",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new()],",
                  "    limit_size: 100,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert_eq!(lits.limit_class, 10);"
                ],
                [
                  "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                  "    let lit = Literal::new();",
                  "    lits3.add(lit);",
                  "    };",
                  "    let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let es = vec![expr1, expr2];",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new()],",
                  "    limit_size: 100,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert!(!lits.is_empty());"
                ],
                [
                  "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                  "    let lit = Literal::new();",
                  "    lits3.add(lit);",
                  "    };",
                  "    let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let es = vec![expr1, expr2];",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new()],",
                  "    limit_size: 100,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert!(lits.literals().len() > 0);"
                ],
                [
                  "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                  "    let lit = Literal::new();",
                  "    lits3.add(lit);",
                  "    };",
                  "    let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let es = vec![expr1, expr2];",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new()],",
                  "    limit_size: 100,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert!(alternate_literals(&es, &mut lits, f).is_some());"
                ],
                [
                  "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                  "    let lit = Literal::new();",
                  "    lits3.add(lit);",
                  "    };",
                  "    let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let es = vec![expr1, expr2];",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new()],",
                  "    limit_size: 100,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert!(lits.cross_product(&lits.to_empty()).is_ok());"
                ],
                [
                  "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                  "    let lit = Literal::new();",
                  "    lits3.add(lit);",
                  "    };",
                  "    let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let es = vec![expr1, expr2];",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new()],",
                  "    limit_size: 100,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert!(lits.any_complete());"
                ],
                [
                  "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                  "    let lit = Literal::new();",
                  "    lits3.add(lit);",
                  "    };",
                  "    let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let es = vec![expr1, expr2];",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new()],",
                  "    limit_size: 100,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert!(!lits.contains_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    // Define a valid function for `f`",
                  "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                  "        let lit = Literal::new(); // Use appropriate initialization for Literal",
                  "        lits3.add(lit);",
                  "    };",
                  "",
                  "    // Construct test data",
                  "    let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let es = vec![expr1, expr2];",
                  "",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new()], // Use appropriate initialization for Literal",
                  "        limit_size: 100,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    alternate_literals(&es, &mut lits, f);",
                  "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                  "    let lit = Literal::new();",
                  "    lits3.add(lit);",
                  "    };",
                  "    let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let es = vec![expr1, expr2];",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new()],",
                  "    limit_size: 100,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert_eq!(lits.limit_size(), 100);",
                  "}"
                ],
                [
                  "{",
                  "    // Define a valid function for `f`",
                  "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                  "        let lit = Literal::new(); // Use appropriate initialization for Literal",
                  "        lits3.add(lit);",
                  "    };",
                  "",
                  "    // Construct test data",
                  "    let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let es = vec![expr1, expr2];",
                  "",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new()], // Use appropriate initialization for Literal",
                  "        limit_size: 100,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    alternate_literals(&es, &mut lits, f);",
                  "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                  "    let lit = Literal::new();",
                  "    lits3.add(lit);",
                  "    };",
                  "    let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let es = vec![expr1, expr2];",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new()],",
                  "    limit_size: 100,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert_eq!(lits.limit_class, 10);",
                  "}"
                ],
                [
                  "{",
                  "    // Define a valid function for `f`",
                  "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                  "        let lit = Literal::new(); // Use appropriate initialization for Literal",
                  "        lits3.add(lit);",
                  "    };",
                  "",
                  "    // Construct test data",
                  "    let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let es = vec![expr1, expr2];",
                  "",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new()], // Use appropriate initialization for Literal",
                  "        limit_size: 100,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    alternate_literals(&es, &mut lits, f);",
                  "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                  "    let lit = Literal::new();",
                  "    lits3.add(lit);",
                  "    };",
                  "    let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let es = vec![expr1, expr2];",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new()],",
                  "    limit_size: 100,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert!(!lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    // Define a valid function for `f`",
                  "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                  "        let lit = Literal::new(); // Use appropriate initialization for Literal",
                  "        lits3.add(lit);",
                  "    };",
                  "",
                  "    // Construct test data",
                  "    let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let es = vec![expr1, expr2];",
                  "",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new()], // Use appropriate initialization for Literal",
                  "        limit_size: 100,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    alternate_literals(&es, &mut lits, f);",
                  "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                  "    let lit = Literal::new();",
                  "    lits3.add(lit);",
                  "    };",
                  "    let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let es = vec![expr1, expr2];",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new()],",
                  "    limit_size: 100,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert!(lits.literals().len() > 0);",
                  "}"
                ],
                [
                  "{",
                  "    // Define a valid function for `f`",
                  "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                  "        let lit = Literal::new(); // Use appropriate initialization for Literal",
                  "        lits3.add(lit);",
                  "    };",
                  "",
                  "    // Construct test data",
                  "    let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let es = vec![expr1, expr2];",
                  "",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new()], // Use appropriate initialization for Literal",
                  "        limit_size: 100,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    alternate_literals(&es, &mut lits, f);",
                  "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                  "    let lit = Literal::new();",
                  "    lits3.add(lit);",
                  "    };",
                  "    let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let es = vec![expr1, expr2];",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new()],",
                  "    limit_size: 100,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert!(alternate_literals(&es, &mut lits, f).is_some());",
                  "}"
                ],
                [
                  "{",
                  "    // Define a valid function for `f`",
                  "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                  "        let lit = Literal::new(); // Use appropriate initialization for Literal",
                  "        lits3.add(lit);",
                  "    };",
                  "",
                  "    // Construct test data",
                  "    let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let es = vec![expr1, expr2];",
                  "",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new()], // Use appropriate initialization for Literal",
                  "        limit_size: 100,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    alternate_literals(&es, &mut lits, f);",
                  "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                  "    let lit = Literal::new();",
                  "    lits3.add(lit);",
                  "    };",
                  "    let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let es = vec![expr1, expr2];",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new()],",
                  "    limit_size: 100,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert!(lits.cross_product(&lits.to_empty()).is_ok());",
                  "}"
                ],
                [
                  "{",
                  "    // Define a valid function for `f`",
                  "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                  "        let lit = Literal::new(); // Use appropriate initialization for Literal",
                  "        lits3.add(lit);",
                  "    };",
                  "",
                  "    // Construct test data",
                  "    let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let es = vec![expr1, expr2];",
                  "",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new()], // Use appropriate initialization for Literal",
                  "        limit_size: 100,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    alternate_literals(&es, &mut lits, f);",
                  "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                  "    let lit = Literal::new();",
                  "    lits3.add(lit);",
                  "    };",
                  "    let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let es = vec![expr1, expr2];",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new()],",
                  "    limit_size: 100,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert!(lits.any_complete());",
                  "}"
                ],
                [
                  "{",
                  "    // Define a valid function for `f`",
                  "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                  "        let lit = Literal::new(); // Use appropriate initialization for Literal",
                  "        lits3.add(lit);",
                  "    };",
                  "",
                  "    // Construct test data",
                  "    let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let es = vec![expr1, expr2];",
                  "",
                  "    let mut lits = Literals {",
                  "        lits: vec![Literal::new()], // Use appropriate initialization for Literal",
                  "        limit_size: 100,",
                  "        limit_class: 10,",
                  "    };",
                  "",
                  "    alternate_literals(&es, &mut lits, f);",
                  "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                  "    let lit = Literal::new();",
                  "    lits3.add(lit);",
                  "    };",
                  "    let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                  "    let es = vec![expr1, expr2];",
                  "    let mut lits = Literals {",
                  "    lits: vec![Literal::new()],",
                  "    limit_size: 100,",
                  "    limit_class: 10,",
                  "    };",
                  "    assert!(!lits.contains_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:53\n     |\n1566 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:53\n     |\n1567 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1581:53\n     |\n1581 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1582:53\n     |\n1582 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:19\n     |\n1561 |         let lit = Literal::new(); // Use appropriate initialization for Literal\n     |                   ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1561 |         let lit = Literal::new(/* Vec<u8> */); // Use appropriate initialization for Literal\n     |                               ~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1566:29\n     |\n1566 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1566 |     let expr1 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1567:29\n     |\n1567 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1567 |     let expr2 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1571:20\n     |\n1571 |         lits: vec![Literal::new()], // Use appropriate initialization for Literal\n     |                    ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1571 |         lits: vec![Literal::new(/* Vec<u8> */)], // Use appropriate initialization for Literal\n     |                                ~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1578:15\n     |\n1578 |     let lit = Literal::new();\n     |               ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1578 |     let lit = Literal::new(/* Vec<u8> */);\n     |                           ~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1581:29\n     |\n1581 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1581 |     let expr1 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1582:29\n     |\n1582 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1582 |     let expr2 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1585:16\n     |\n1585 |     lits: vec![Literal::new()],\n     |                ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1585 |     lits: vec![Literal::new(/* Vec<u8> */)],\n     |                            ~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:53\n     |\n1566 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:53\n     |\n1567 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1581:53\n     |\n1581 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1582:53\n     |\n1582 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:19\n     |\n1561 |         let lit = Literal::new(); // Use appropriate initialization for Literal\n     |                   ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1561 |         let lit = Literal::new(/* Vec<u8> */); // Use appropriate initialization for Literal\n     |                               ~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1566:29\n     |\n1566 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1566 |     let expr1 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1567:29\n     |\n1567 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1567 |     let expr2 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1571:20\n     |\n1571 |         lits: vec![Literal::new()], // Use appropriate initialization for Literal\n     |                    ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1571 |         lits: vec![Literal::new(/* Vec<u8> */)], // Use appropriate initialization for Literal\n     |                                ~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1578:15\n     |\n1578 |     let lit = Literal::new();\n     |               ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1578 |     let lit = Literal::new(/* Vec<u8> */);\n     |                           ~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1581:29\n     |\n1581 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1581 |     let expr1 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1582:29\n     |\n1582 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1582 |     let expr2 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1585:16\n     |\n1585 |     lits: vec![Literal::new()],\n     |                ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1585 |     lits: vec![Literal::new(/* Vec<u8> */)],\n     |                            ~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:53\n     |\n1566 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:53\n     |\n1567 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1581:53\n     |\n1581 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1582:53\n     |\n1582 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:19\n     |\n1561 |         let lit = Literal::new(); // Use appropriate initialization for Literal\n     |                   ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1561 |         let lit = Literal::new(/* Vec<u8> */); // Use appropriate initialization for Literal\n     |                               ~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1566:29\n     |\n1566 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1566 |     let expr1 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1567:29\n     |\n1567 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1567 |     let expr2 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1571:20\n     |\n1571 |         lits: vec![Literal::new()], // Use appropriate initialization for Literal\n     |                    ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1571 |         lits: vec![Literal::new(/* Vec<u8> */)], // Use appropriate initialization for Literal\n     |                                ~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1578:15\n     |\n1578 |     let lit = Literal::new();\n     |               ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1578 |     let lit = Literal::new(/* Vec<u8> */);\n     |                           ~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1581:29\n     |\n1581 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1581 |     let expr1 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1582:29\n     |\n1582 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1582 |     let expr2 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1585:16\n     |\n1585 |     lits: vec![Literal::new()],\n     |                ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1585 |     lits: vec![Literal::new(/* Vec<u8> */)],\n     |                            ~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:53\n     |\n1566 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:53\n     |\n1567 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1581:53\n     |\n1581 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1582:53\n     |\n1582 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:19\n     |\n1561 |         let lit = Literal::new(); // Use appropriate initialization for Literal\n     |                   ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1561 |         let lit = Literal::new(/* Vec<u8> */); // Use appropriate initialization for Literal\n     |                               ~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1566:29\n     |\n1566 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1566 |     let expr1 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1567:29\n     |\n1567 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1567 |     let expr2 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1571:20\n     |\n1571 |         lits: vec![Literal::new()], // Use appropriate initialization for Literal\n     |                    ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1571 |         lits: vec![Literal::new(/* Vec<u8> */)], // Use appropriate initialization for Literal\n     |                                ~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1578:15\n     |\n1578 |     let lit = Literal::new();\n     |               ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1578 |     let lit = Literal::new(/* Vec<u8> */);\n     |                           ~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1581:29\n     |\n1581 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1581 |     let expr1 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1582:29\n     |\n1582 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1582 |     let expr2 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1585:16\n     |\n1585 |     lits: vec![Literal::new()],\n     |                ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1585 |     lits: vec![Literal::new(/* Vec<u8> */)],\n     |                            ~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:53\n     |\n1566 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:53\n     |\n1567 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1581:53\n     |\n1581 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1582:53\n     |\n1582 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:19\n     |\n1561 |         let lit = Literal::new(); // Use appropriate initialization for Literal\n     |                   ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1561 |         let lit = Literal::new(/* Vec<u8> */); // Use appropriate initialization for Literal\n     |                               ~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1566:29\n     |\n1566 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1566 |     let expr1 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1567:29\n     |\n1567 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1567 |     let expr2 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1571:20\n     |\n1571 |         lits: vec![Literal::new()], // Use appropriate initialization for Literal\n     |                    ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1571 |         lits: vec![Literal::new(/* Vec<u8> */)], // Use appropriate initialization for Literal\n     |                                ~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1578:15\n     |\n1578 |     let lit = Literal::new();\n     |               ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1578 |     let lit = Literal::new(/* Vec<u8> */);\n     |                           ~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1581:29\n     |\n1581 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1581 |     let expr1 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1582:29\n     |\n1582 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1582 |     let expr2 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1585:16\n     |\n1585 |     lits: vec![Literal::new()],\n     |                ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1585 |     lits: vec![Literal::new(/* Vec<u8> */)],\n     |                            ~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `is_some` found for unit type `()` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:51\n     |\n1589 |     assert!(alternate_literals(&es, &mut lits, f).is_some());\n     |                                                   ^^^^^^^ method not found in `()`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:53\n     |\n1566 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:53\n     |\n1567 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1581:53\n     |\n1581 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1582:53\n     |\n1582 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:19\n     |\n1561 |         let lit = Literal::new(); // Use appropriate initialization for Literal\n     |                   ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1561 |         let lit = Literal::new(/* Vec<u8> */); // Use appropriate initialization for Literal\n     |                               ~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1566:29\n     |\n1566 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1566 |     let expr1 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1567:29\n     |\n1567 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1567 |     let expr2 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1571:20\n     |\n1571 |         lits: vec![Literal::new()], // Use appropriate initialization for Literal\n     |                    ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1571 |         lits: vec![Literal::new(/* Vec<u8> */)], // Use appropriate initialization for Literal\n     |                                ~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1578:15\n     |\n1578 |     let lit = Literal::new();\n     |               ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1578 |     let lit = Literal::new(/* Vec<u8> */);\n     |                           ~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1581:29\n     |\n1581 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1581 |     let expr1 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1582:29\n     |\n1582 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1582 |     let expr2 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1585:16\n     |\n1585 |     lits: vec![Literal::new()],\n     |                ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1585 |     lits: vec![Literal::new(/* Vec<u8> */)],\n     |                            ~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `is_ok` found for type `bool` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1589:50\n     |\n1589 |     assert!(lits.cross_product(&lits.to_empty()).is_ok());\n     |                                                  ^^^^^ method not found in `bool`\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0308, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 14 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:53\n     |\n1566 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:53\n     |\n1567 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1581:53\n     |\n1581 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1582:53\n     |\n1582 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:19\n     |\n1561 |         let lit = Literal::new(); // Use appropriate initialization for Literal\n     |                   ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1561 |         let lit = Literal::new(/* Vec<u8> */); // Use appropriate initialization for Literal\n     |                               ~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1566:29\n     |\n1566 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1566 |     let expr1 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1567:29\n     |\n1567 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1567 |     let expr2 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1571:20\n     |\n1571 |         lits: vec![Literal::new()], // Use appropriate initialization for Literal\n     |                    ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1571 |         lits: vec![Literal::new(/* Vec<u8> */)], // Use appropriate initialization for Literal\n     |                                ~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1578:15\n     |\n1578 |     let lit = Literal::new();\n     |               ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1578 |     let lit = Literal::new(/* Vec<u8> */);\n     |                           ~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1581:29\n     |\n1581 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1581 |     let expr1 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1582:29\n     |\n1582 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1582 |     let expr2 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1585:16\n     |\n1585 |     lits: vec![Literal::new()],\n     |                ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1585 |     lits: vec![Literal::new(/* Vec<u8> */)],\n     |                            ~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1566:53\n     |\n1566 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:53\n     |\n1567 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1581:53\n     |\n1581 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1582:53\n     |\n1582 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                                                     ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:19\n     |\n1561 |         let lit = Literal::new(); // Use appropriate initialization for Literal\n     |                   ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1561 |         let lit = Literal::new(/* Vec<u8> */); // Use appropriate initialization for Literal\n     |                               ~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1566:29\n     |\n1566 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1566 |     let expr1 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1567:29\n     |\n1567 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1567 |     let expr2 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1571:20\n     |\n1571 |         lits: vec![Literal::new()], // Use appropriate initialization for Literal\n     |                    ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1571 |         lits: vec![Literal::new(/* Vec<u8> */)], // Use appropriate initialization for Literal\n     |                                ~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1578:15\n     |\n1578 |     let lit = Literal::new();\n     |               ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1578 |     let lit = Literal::new(/* Vec<u8> */);\n     |                           ~~~~~~~~~~~~~~~\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1581:29\n     |\n1581 |     let expr1 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1581 |     let expr1 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n    --> regex-syntax/src/hir/literal/mod.rs:1582:29\n     |\n1582 |     let expr2 = Hir { kind: HirKind::Literal, info: HirInfo::new() };\n     |                             ^^^^^^^^^^^^^^^^ expected `HirKind`, found enum constructor\n     |\n    ::: regex-syntax/src/hir/mod.rs:175:5\n     |\n175  |     Literal(Literal),\n     |     ------- `Literal` defines an enum variant constructor here, which should be called\n     |\n     = note:          expected enum `hir::HirKind`\n             found enum constructor `fn(hir::Literal) -> hir::HirKind {hir::HirKind::Literal}`\nhelp: use parentheses to construct this tuple variant\n     |\n1582 |     let expr2 = Hir { kind: HirKind::Literal(/* hir::Literal */), info: HirInfo::new() };\n     |                                             ++++++++++++++++++++\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1585:16\n     |\n1585 |     lits: vec![Literal::new()],\n     |                ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1585 |     lits: vec![Literal::new(/* Vec<u8> */)],\n     |                            ~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0308, E0432, E0433.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 13 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    // Define a valid function for `f`",
                "    let mut f = |e: &Hir, lits3: &mut Literals| {",
                "        let lit = Literal::new(); // Use appropriate initialization for Literal",
                "        lits3.add(lit);",
                "    };",
                "",
                "    // Construct test data",
                "    let expr = Hir { kind: HirKind::Literal, info: HirInfo::new() };",
                "    let es = vec![expr];",
                "",
                "    let mut lits = Literals {",
                "        lits: vec![Literal::new()], // Use appropriate initialization for Literal",
                "        limit_size: 100,",
                "        limit_class: 10,",
                "    };",
                "    ",
                "    let mut lits2 = lits.to_empty();",
                "    lits2.set_limit_size(lits.limit_size / 5);",
                "",
                "    // Execute the function under test",
                "    alternate_literals(&es, &mut lits, f);",
                "}"
              ],
              "oracles": [],
              "codes": [],
              "can_compile": [],
              "repaired": []
            }
          ]
        }
      ]
    },
    {
      "chain_id": 6,
      "prompt_conds": [
        "// constraint: e in es is false\n",
        "// constraint: lits.cross_product(&lits2) is false\n"
      ],
      "input_infer": "es: [Hir::new(false)]; lits: &mut Literals { lits: Vec::from([Literal::new()]), limit_size: 1, limit_class: 1 }\n",
      "answers": [
        {
          "uses": [],
          "has_test_mod": false,
          "common": [],
          "chain_tests": [
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                "    let es = vec![hir_instance];",
                "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                "    ",
                "    alternate_literals(&es, &mut lits, |_, _| {});",
                "}"
              ],
              "oracles": [
                [
                  "    let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    alternate_literals(&es, &mut lits, |_, _| {});",
                  "    assert_eq!(lits.is_empty(), true);"
                ],
                [
                  "    let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    alternate_literals(&es, &mut lits, |_, _| {});",
                  "    assert_eq!(lits.num_bytes(), 0);"
                ],
                [
                  "    let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    alternate_literals(&es, &mut lits, |_, _| {});",
                  "    assert_eq!(lits.limits(), 1);"
                ],
                [
                  "    let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    alternate_literals(&es, &mut lits, |_, _| {});",
                  "    assert_eq!(lits.limit_class(), 1);"
                ],
                [
                  "    let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    alternate_literals(&es, &mut lits, |_, _| {});",
                  "    assert_eq!(lits.lits.len(), 1);"
                ],
                [
                  "    let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    alternate_literals(&es, &mut lits, |_, _| {});",
                  "    assert!(lits.lits[0].is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, _| {});",
                  "    let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    alternate_literals(&es, &mut lits, |_, _| {});",
                  "    assert_eq!(lits.is_empty(), true);",
                  "}"
                ],
                [
                  "{",
                  "    let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, _| {});",
                  "    let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    alternate_literals(&es, &mut lits, |_, _| {});",
                  "    assert_eq!(lits.num_bytes(), 0);",
                  "}"
                ],
                [
                  "{",
                  "    let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, _| {});",
                  "    let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    alternate_literals(&es, &mut lits, |_, _| {});",
                  "    assert_eq!(lits.limits(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, _| {});",
                  "    let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    alternate_literals(&es, &mut lits, |_, _| {});",
                  "    assert_eq!(lits.limit_class(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, _| {});",
                  "    let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    alternate_literals(&es, &mut lits, |_, _| {});",
                  "    assert_eq!(lits.lits.len(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, _| {});",
                  "    let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    alternate_literals(&es, &mut lits, |_, _| {});",
                  "    assert!(lits.lits[0].is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1559:58\n     |\n1559 |     let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n1564 |     let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:42\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1566:42\n     |\n1566 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1566 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1559:58\n     |\n1559 |     let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n1564 |     let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:42\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1566:42\n     |\n1566 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1566 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1559:58\n     |\n1559 |     let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n1564 |     let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:42\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1566:42\n     |\n1566 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1566 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nerror[E0599]: no method named `limits` found for struct `literal::Literals` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1568:21\n     |\n45   | pub struct Literals {\n     | ------------------- method `limits` not found for this struct\n...\n1568 |     assert_eq!(lits.limits(), 1);\n     |                     ^^^^^^\n     |\nhelp: there is a method `limit_size` with a similar name\n     |\n1568 |     assert_eq!(lits.limit_size(), 1);\n     |                     ~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 6 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1559:58\n     |\n1559 |     let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n1564 |     let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:42\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1566:42\n     |\n1566 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1566 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1559:58\n     |\n1559 |     let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n1564 |     let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:42\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1566:42\n     |\n1566 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1566 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1559:58\n     |\n1559 |     let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1564:58\n     |\n1564 |     let hir_instance = Hir { kind: HirKind::Empty, info: HirInfo::default() };\n     |                                                          ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:42\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1566:42\n     |\n1566 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1566 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 5 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };",
                "    let es = vec![hir_instance];",
                "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                "    ",
                "    alternate_literals(&es, &mut lits, |_, _| {});",
                "}"
              ],
              "oracles": [
                [
                  "    let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    let mut lits2 = lits.to_empty();",
                  "    let mut lits3 = lits.to_empty();",
                  "    lits3.set_limit_size(lits.limit_size() / 5);",
                  "    assert!(lits3.is_empty());"
                ],
                [
                  "    let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    let mut lits2 = lits.to_empty();",
                  "    let mut lits3 = lits.to_empty();",
                  "    lits3.set_limit_size(lits.limit_size() / 5);",
                  "    assert!(!lits2.union(lits3));"
                ],
                [
                  "    let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    let mut lits2 = lits.to_empty();",
                  "    let mut lits3 = lits.to_empty();",
                  "    lits3.set_limit_size(lits.limit_size() / 5);",
                  "    assert!(lits.is_empty());"
                ],
                [
                  "    let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    let mut lits2 = lits.to_empty();",
                  "    let mut lits3 = lits.to_empty();",
                  "    lits3.set_limit_size(lits.limit_size() / 5);",
                  "    assert!(!lits.cross_product(&lits2));"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, _| {});",
                  "    let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    let mut lits2 = lits.to_empty();",
                  "    let mut lits3 = lits.to_empty();",
                  "    lits3.set_limit_size(lits.limit_size() / 5);",
                  "    assert!(lits3.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, _| {});",
                  "    let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    let mut lits2 = lits.to_empty();",
                  "    let mut lits3 = lits.to_empty();",
                  "    lits3.set_limit_size(lits.limit_size() / 5);",
                  "    assert!(!lits2.union(lits3));",
                  "}"
                ],
                [
                  "{",
                  "    let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, _| {});",
                  "    let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    let mut lits2 = lits.to_empty();",
                  "    let mut lits3 = lits.to_empty();",
                  "    lits3.set_limit_size(lits.limit_size() / 5);",
                  "    assert!(lits.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, _| {});",
                  "    let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    let mut lits2 = lits.to_empty();",
                  "    let mut lits3 = lits.to_empty();",
                  "    lits3.set_limit_size(lits.limit_size() / 5);",
                  "    assert!(!lits.cross_product(&lits2));",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1559:63\n     |\n1559 |     let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };\n     |                                                               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1564:63\n     |\n1564 |     let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };\n     |                                                               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `New` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1559:45\n     |\n1559 |     let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };\n     |                                             ^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `New` not found for this enum\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:42\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `New` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:45\n     |\n1564 |     let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };\n     |                                             ^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `New` not found for this enum\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1566:42\n     |\n1566 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1566 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1559:63\n     |\n1559 |     let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };\n     |                                                               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1564:63\n     |\n1564 |     let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };\n     |                                                               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `New` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1559:45\n     |\n1559 |     let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };\n     |                                             ^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `New` not found for this enum\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:42\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `New` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:45\n     |\n1564 |     let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };\n     |                                             ^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `New` not found for this enum\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1566:42\n     |\n1566 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1566 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1559:63\n     |\n1559 |     let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };\n     |                                                               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1564:63\n     |\n1564 |     let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };\n     |                                                               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `New` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1559:45\n     |\n1559 |     let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };\n     |                                             ^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `New` not found for this enum\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:42\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `New` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:45\n     |\n1564 |     let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };\n     |                                             ^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `New` not found for this enum\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1566:42\n     |\n1566 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1566 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1559:63\n     |\n1559 |     let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };\n     |                                                               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1564:63\n     |\n1564 |     let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };\n     |                                                               ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `New` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1559:45\n     |\n1559 |     let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };\n     |                                             ^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `New` not found for this enum\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:42\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `New` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1564:45\n     |\n1564 |     let hir_instance = Hir { kind: HirKind::New(false), info: HirInfo::default() };\n     |                                             ^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `New` not found for this enum\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1566:42\n     |\n1566 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1566 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false
              ]
            },
            {
              "attrs": [],
              "prefix": [
                "{",
                "    let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
                "    let es = vec![hir_instance];",
                "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                "    ",
                "    alternate_literals(&es, &mut lits, |_, _| {",
                "        let mut lits_inner = Literals::empty();",
                "        lits_inner.set_limit_size(0); // This should trigger the cross_product to be false",
                "    });",
                "}"
              ],
              "oracles": [
                [
                  "    let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    let lits2 = lits.to_empty();",
                  "    assert!(lits2.is_empty());"
                ],
                [
                  "    let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    let lits2 = lits.to_empty();",
                  "    assert_eq!(lits.limit_size(), 1);"
                ],
                [
                  "    let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    let lits2 = lits.to_empty();",
                  "    assert_eq!(lits.limit_class, 1);"
                ],
                [
                  "    let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    let lits2 = lits.to_empty();",
                  "    assert_eq!(lits.cross_product(&lits2), false);"
                ],
                [
                  "    let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    let lits2 = lits.to_empty();",
                  "    lits.cut();",
                  "    assert!(lits.is_empty());"
                ]
              ],
              "codes": [
                [
                  "{",
                  "    let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, _| {",
                  "        let mut lits_inner = Literals::empty();",
                  "        lits_inner.set_limit_size(0); // This should trigger the cross_product to be false",
                  "    });",
                  "    let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    let lits2 = lits.to_empty();",
                  "    assert!(lits2.is_empty());",
                  "}"
                ],
                [
                  "{",
                  "    let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, _| {",
                  "        let mut lits_inner = Literals::empty();",
                  "        lits_inner.set_limit_size(0); // This should trigger the cross_product to be false",
                  "    });",
                  "    let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    let lits2 = lits.to_empty();",
                  "    assert_eq!(lits.limit_size(), 1);",
                  "}"
                ],
                [
                  "{",
                  "    let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, _| {",
                  "        let mut lits_inner = Literals::empty();",
                  "        lits_inner.set_limit_size(0); // This should trigger the cross_product to be false",
                  "    });",
                  "    let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    let lits2 = lits.to_empty();",
                  "    assert_eq!(lits.limit_class, 1);",
                  "}"
                ],
                [
                  "{",
                  "    let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, _| {",
                  "        let mut lits_inner = Literals::empty();",
                  "        lits_inner.set_limit_size(0); // This should trigger the cross_product to be false",
                  "    });",
                  "    let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    let lits2 = lits.to_empty();",
                  "    assert_eq!(lits.cross_product(&lits2), false);",
                  "}"
                ],
                [
                  "{",
                  "    let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    ",
                  "    alternate_literals(&es, &mut lits, |_, _| {",
                  "        let mut lits_inner = Literals::empty();",
                  "        lits_inner.set_limit_size(0); // This should trigger the cross_product to be false",
                  "    });",
                  "    let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };",
                  "    let es = vec![hir_instance];",
                  "    let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };",
                  "    let lits2 = lits.to_empty();",
                  "    lits.cut();",
                  "    assert!(lits.is_empty());",
                  "}"
                ]
              ],
              "can_compile": [
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1559:61\n     |\n1559 |     let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };\n     |                                                             ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:61\n     |\n1567 |     let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };\n     |                                                             ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1559:45\n     |\n1559 |     let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };\n     |                                             ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:42\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:45\n     |\n1567 |     let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };\n     |                                             ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1569:42\n     |\n1569 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1569 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1559:61\n     |\n1559 |     let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };\n     |                                                             ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:61\n     |\n1567 |     let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };\n     |                                                             ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1559:45\n     |\n1559 |     let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };\n     |                                             ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:42\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:45\n     |\n1567 |     let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };\n     |                                             ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1569:42\n     |\n1569 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1569 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n    Blocking waiting for file lock on package cache\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1559:61\n     |\n1559 |     let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };\n     |                                                             ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:61\n     |\n1567 |     let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };\n     |                                                             ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1559:45\n     |\n1559 |     let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };\n     |                                             ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:42\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:45\n     |\n1567 |     let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };\n     |                                             ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1569:42\n     |\n1569 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1569 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1559:61\n     |\n1559 |     let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };\n     |                                                             ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:61\n     |\n1567 |     let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };\n     |                                                             ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1559:45\n     |\n1559 |     let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };\n     |                                             ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:42\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:45\n     |\n1567 |     let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };\n     |                                             ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1569:42\n     |\n1569 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1569 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                },
                {
                  "Err": "warning: /home/utgen/workspace/regex/bench/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-capi/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-syntax/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\nwarning: /home/utgen/workspace/regex/regex-debug/Cargo.toml: no edition set: defaulting to the 2015 edition while the latest is 2021\n   Compiling proc-macro2 v1.0.95\n   Compiling syn v1.0.109\n   Compiling quote v1.0.40\n   Compiling ntest_test_cases v0.9.3\n   Compiling ntest_timeout v0.9.3\n   Compiling ntest v0.9.3\n   Compiling regex-syntax v0.6.0 (/home/utgen/workspace/regex/regex-syntax)\nerror[E0432]: unresolved import `ntest`\n    --> regex-syntax/src/hir/literal/mod.rs:1555:8\n     |\n1555 |    use ntest::timeout;\n     |        ^^^^^ maybe a missing crate `ntest`?\n     |\n     = help: consider adding `extern crate ntest` to use the `ntest` crate\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1559:61\n     |\n1559 |     let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };\n     |                                                             ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nerror[E0433]: failed to resolve: use of undeclared type `HirInfo`\n    --> regex-syntax/src/hir/literal/mod.rs:1567:61\n     |\n1567 |     let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };\n     |                                                             ^^^^^^^ use of undeclared type `HirInfo`\n     |\nhelp: consider importing this struct\n     |\n1554 +    use hir::HirInfo;\n     |\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1445:16\n     |\n1445 |             '0'...'7' => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n     = note: `#[warn(ellipsis_inclusive_range_patterns)]` on by default\n\nwarning: `...` range patterns are deprecated\n    --> regex-syntax/src/ast/parse.rs:1456:16\n     |\n1456 |             '8'...'9' if !self.parser().octal => {\n     |                ^^^ help: use `..=` for an inclusive range\n     |\n     = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n     = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `Primitive`\n    --> regex-syntax/src/ast/parse.rs:2261:49\n     |\n2261 |     use super::{Parser, ParserI, ParserBuilder, Primitive};\n     |                                                 ^^^^^^^^^\n     |\n     = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused macro definition: `assert_eq`\n    --> regex-syntax/src/ast/parse.rs:2265:18\n     |\n2265 |     macro_rules! assert_eq {\n     |                  ^^^^^^^^^\n     |\n     = note: `#[warn(unused_macros)]` on by default\n\nwarning: unused import: `super::*`\n    --> regex-syntax/src/ast/mod.rs:1482:9\n     |\n1482 |     use super::*;\n     |         ^^^^^^^^\n\nwarning: unused import: `ast::parse::Parser`\n   --> regex-syntax/src/error.rs:288:9\n    |\n288 |     use ast::parse::Parser;\n    |         ^^^^^^^^^^^^^^^^^^\n\nwarning: unused import: `ParserBuilder`\n    --> regex-syntax/src/hir/literal/mod.rs:1004:9\n     |\n1004 |     use ParserBuilder;\n     |         ^^^^^^^^^^^^^\n\nwarning: unused imports: `Position` and `self`\n    --> regex-syntax/src/hir/translate.rs:1094:15\n     |\n1094 |     use ast::{self, Ast, Position, Span};\n     |               ^^^^       ^^^^^^^^\n\nwarning: unused import: `ascii_class`\n    --> regex-syntax/src/hir/translate.rs:1099:36\n     |\n1099 |     use super::{TranslatorBuilder, ascii_class};\n     |                                    ^^^^^^^^^^^\n\nwarning: unused imports: `contains_simple_case_mapping` and `simple_fold`\n   --> regex-syntax/src/unicode.rs:375:17\n    |\n375 |     use super::{contains_simple_case_mapping, simple_fold};\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^  ^^^^^^^^^^^\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:21\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:37\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: `...` range patterns are deprecated\n   --> regex-syntax/src/lib.rs:195:53\n    |\n195 |         b'_' | b'0' ... b'9' | b'a' ... b'z' | b'A' ... b'Z'  => true,\n    |                                                     ^^^ help: use `..=` for an inclusive range\n    |\n    = warning: this is accepted in the current edition (Rust 2015) but is a hard error in Rust 2021!\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\nwarning: unused import: `super::*`\n   --> regex-syntax/src/lib.rs:202:9\n    |\n202 |     use super::*;\n    |         ^^^^^^^^\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:45:38\n   |\n45 |             Error::Parse(ref x) => x.description(),\n   |                                      ^^^^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by default\n\nwarning: use of deprecated method `std::error::Error::description`: use the Display impl or to_string()\n  --> regex-syntax/src/error.rs:46:42\n   |\n46 |             Error::Translate(ref x) => x.description(),\n   |                                          ^^^^^^^^^^^\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1559:45\n     |\n1559 |     let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };\n     |                                             ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1561:42\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1561 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nerror[E0599]: no variant or associated item named `SomeKind` found for enum `hir::HirKind` in the current scope\n    --> regex-syntax/src/hir/literal/mod.rs:1567:45\n     |\n1567 |     let hir_instance = Hir { kind: HirKind::SomeKind, info: HirInfo::default() };\n     |                                             ^^^^^^^^ variant or associated item not found in `HirKind`\n     |\n    ::: regex-syntax/src/hir/mod.rs:170:1\n     |\n170  | pub enum HirKind {\n     | ---------------- variant or associated item `SomeKind` not found for this enum\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n    --> regex-syntax/src/hir/literal/mod.rs:1569:42\n     |\n1569 |     let mut lits = Literals { lits: vec![Literal::new()], limit_size: 1, limit_class: 1 };\n     |                                          ^^^^^^^^^^^^-- argument #1 of type `Vec<u8>` is missing\n     |\nnote: associated function defined here\n    --> regex-syntax/src/hir/literal/mod.rs:881:12\n     |\n881  |     pub fn new(bytes: Vec<u8>) -> Literal {\n     |            ^^^ --------------\nhelp: provide the argument\n     |\n1569 |     let mut lits = Literals { lits: vec![Literal::new(/* Vec<u8> */)], limit_size: 1, limit_class: 1 };\n     |                                                      ~~~~~~~~~~~~~~~\n\nwarning: variable does not need to be mutable\n   --> regex-syntax/src/hir/literal/mod.rs:687:17\n    |\n687 |             let mut buf = &mut buf[..i];\n    |                 ----^^^\n    |                 |\n    |                 help: remove this `mut`\n    |\n    = note: `#[warn(unused_mut)]` on by default\n\nSome errors have detailed explanations: E0061, E0432, E0433, E0599.\nFor more information about an error, try `rustc --explain E0061`.\nwarning: `regex-syntax` (lib test) generated 17 warnings\nerror: could not compile `regex-syntax` (lib test) due to 7 previous errors; 17 warnings emitted\n"
                }
              ],
              "repaired": [
                false,
                false,
                false,
                false,
                false
              ]
            }
          ]
        }
      ]
    }
  ]
}